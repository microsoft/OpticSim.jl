<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Primitives · OpticSim.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">OpticSim.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Geometry</span><ul><li class="is-active"><a class="tocitem" href>Primitives</a><ul class="internal"><li><a class="tocitem" href="#Surfaces"><span>Surfaces</span></a></li><li><a class="tocitem" href="#Parametric-Surfaces"><span>Parametric Surfaces</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Bounding-Boxes"><span>Bounding Boxes</span></a></li></ul></li><li><a class="tocitem" href="../csg/">CSG</a></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li><a class="tocitem" href="../vis/">Visualization</a></li><li><a class="tocitem" href="../glasscat/">Glass Functions</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry</a></li><li class="is-active"><a href>Primitives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Primitives</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/microsoft/OpticSim.jl/blob/master/docs/src/primitives.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Primitives"><a class="docs-heading-anchor" href="#Primitives">Primitives</a><a id="Primitives-1"></a><a class="docs-heading-anchor-permalink" href="#Primitives" title="Permalink"></a></h1><p>All geometry is built up from a small(ish) number of primitives and a number of constructive solid geometry (CSG) operations (see <a href="../csg/#CSG">CSG</a>). Primitives are split into two types, <code>Surface</code>s and <code>ParametricSurface</code>s, the latter being a subset of the former. <code>Surface</code>s are standalone surfaces which cannot be used in CSG operations, e.g. an aperture or rectangle. <code>ParametricSurface</code>s are valid csg objects and can be composed into very complex structures.</p><h2 id="Surfaces"><a class="docs-heading-anchor" href="#Surfaces">Surfaces</a><a id="Surfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Surfaces" title="Permalink"></a></h2><p>A surface can be any surface in 3D space, it can be bounded and not create a half-space (i.e. not partition space into <em>inside</em> and <em>outside</em>).</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Surface" href="#OpticSim.Surface"><code>OpticSim.Surface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Surface{T&lt;:Real}</code></pre><p><code>T</code> is the number type used to represent the surface, e.g., <code>Float64</code>. Basic <code>Surface</code>s are <em>not</em> valid CSG objects, they function only in a stand-alone capacity.</p><p><strong>Must</strong> implement the following:</p><pre><code class="language-julia">surfaceintersection(surface::Surface{T}, ray::AbstractRay{T,3}) -&gt; Union{EmptyInterval{T},Interval{T}}
normal(surface::Surface{T}) -&gt; SVector{3,T}
interface(surface::Surface{T}) -&gt; OpticalInterface{T}
makemesh(surface::Surface{T}) -&gt; TriangleMesh{T}</code></pre><p>In a conventional ray tracer the surface intersection function would only return the first surface the ray intersects. Because our ray tracer does CSG operations the surface intersection function intersects the ray with all leaf surfaces which are part of the CSG tree. </p><p>Each leaf surface returns one or more 1D intervals along the ray. These intervals contain the part of the ray which is inside the surface. The intervals computed at the leaves are propagated upward through the CSG tree and the CSG operations of union, intersection, and difference are applied to generate new intervals which are themselves propagated upward.</p><p>The result is a union of 1D intervals, which may be disjoint, a single interval, or empty. The union of intervals represents the parts of the ray which are inside the CSG object.</p><p>Inside is well defined for halfspaces such as cylinders and spheres which divide space into two parts, but not for Bezier or NURBS patches which generally do not enclose a volume.  For surfaces which are not halfspaces the notion of inside is defined locally by computing the angle between the incoming ray and the normal of the surface at the point of intersection. All surfaces must be defined so that the normal points to the outside of the surface. </p><p>A negative dot product between the incoming ray and the normal indicates the ray is coming from the outside of the surface and heading toward the inside. A positive dot product indicates the ray is coming from the inside of the surface and heading toward the outside.</p><p>Intervals are defined along the ray which is being intersected with the surface, so they are one dimensional. For example, assume we have a ray with origin o on the outside of a plane and an intersection with the plane at point int = o + td where t is a scalar and d is the unit direction of the ray. The inside interval will be (Intersection(t),Infinity). This interval begins at the intersection point on the plane and continues to positive infinity. The Intersection struct stores both the parametric value t and the 3D point of intersection to make various operations more efficient. But the interval operations only depend on the parametric value t.</p><p>If the origin o is on the inside of the plane then the inside interval will be (RayOrigin,Intersection(t)). Only the part of the ray from the ray origin to the intersection point is inside the plane. </p><p>It is the programmer&#39;s responsibility to return Interval results from surfaceintersection that maintain these properties.</p><p>The following must be impemented only if the surface is being used as a detector</p><pre><code class="language-julia">uv(surface::Surface{T}, p::SVector{3,T}) -&gt; SVector{2,T}
uvtopix(surface::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -&gt; Tuple{Int,Int}
onsurface(surface::Surface{T}, p::SVector{3,T}) -&gt; Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L38-L74">source</a></section></article><h3 id="Basic-Shapes"><a class="docs-heading-anchor" href="#Basic-Shapes">Basic Shapes</a><a id="Basic-Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Shapes" title="Permalink"></a></h3><p>These are the simple shapes with are provided already, they act only as standalone objects and cannot be used in CSG objects. Adding a new <code>Surface</code> is easy, the new structure must simply follow the interface defined above.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Ellipse" href="#OpticSim.Ellipse"><code>OpticSim.Ellipse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ellipse{T} &lt;: Surface{T}</code></pre><p>Elliptical surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p><p><strong>Can be used as a detector in <a href="../systems/#OpticSim.OpticalSystem"><code>OpticalSystem</code></a>s.</strong></p><pre><code class="language-julia">Ellipse(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a ellipse centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Ellipse.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Circle" href="#OpticSim.Circle"><code>OpticSim.Circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))</code></pre><p>Shortcut method to create a circle. The minimal case returns a circle centred at the origin with <code>normal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Ellipse.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Rectangle" href="#OpticSim.Rectangle"><code>OpticSim.Rectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rectangle{T} &lt;: Surface{T}</code></pre><p>Rectangular surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p><p><strong>Can be used as a detector in <a href="../systems/#OpticSim.OpticalSystem"><code>OpticalSystem</code></a>s.</strong></p><pre><code class="language-julia">Rectangle(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a rectangle centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Rectangle.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Hexagon" href="#OpticSim.Hexagon"><code>OpticSim.Hexagon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hexagon{T} &lt;: Surface{T}</code></pre><p>Hexagonal surface, not a valid CSG object. The rotation of the hexagon around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p><pre><code class="language-julia">Hexagon(side_length::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a rectangle centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Hexagon.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Triangle" href="#OpticSim.Triangle"><code>OpticSim.Triangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Triangle{T} &lt;: Surface{T}</code></pre><p>Triangular surface, not a valid CSG object. Primarily used as a component part of <a href="#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> or to enable intersection of <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a>s. Can never be used directly as an optical surface as it doesn&#39;t have an <a href="../interfaces/#OpticSim.OpticalInterface"><code>OpticalInterface</code></a>.</p><pre><code class="language-julia">Triangle(v1::SVector{3,T}, v2::SVector{3,T}, v3::SVector{3,T}, [uv1::SVector{2,T}, uv2::SVector{2,T}, uv3::SVector{2,T}])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Triangle.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.TriangleMesh" href="#OpticSim.TriangleMesh"><code>OpticSim.TriangleMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TriangleMesh{T} &lt;: Surface{T}</code></pre><p>An array of <a href="#OpticSim.Triangle"><code>Triangle</code></a>s forming a mesh. Used for visualization purposes only.</p><pre><code class="language-julia">TriangleMesh(tris::Vector{Triangle{T}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Triangle.jl#L129-L138">source</a></section></article><h3 id="Stops"><a class="docs-heading-anchor" href="#Stops">Stops</a><a id="Stops-1"></a><a class="docs-heading-anchor-permalink" href="#Stops" title="Permalink"></a></h3><p>A number of simple occlusive apertures are provided as constructing such objects using CSG can be inefficient and error-prone.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.InfiniteStop" href="#OpticSim.InfiniteStop"><code>OpticSim.InfiniteStop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteStop{T,P&lt;:StopShape} &lt;: Surface{T}</code></pre><p>Stop surface with infinite extent (outside of the aperture). <code>P</code> refers to the shape of the aperture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.FiniteStop" href="#OpticSim.FiniteStop"><code>OpticSim.FiniteStop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteStop{T,P&lt;:StopShape,Q&lt;:StopShape} &lt;: Surface{T}</code></pre><p>Stop surface with finite extent. <code>P</code> refers to the shape of the aperture and <code>Q</code> represents the shape of the bounds of the stop surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularAperture" href="#OpticSim.RectangularAperture"><code>OpticSim.RectangularAperture</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a plane i.e. <code>InfiniteStop{T,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L191-L197">source</a></section><section><div><pre><code class="language-julia">RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a rectangle i.e. <code>FiniteStop{T,RectangularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularAperture" href="#OpticSim.CircularAperture"><code>OpticSim.CircularAperture</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a plane i.e. <code>InfiniteStop{T,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L231-L235">source</a></section><section><div><pre><code class="language-julia">CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a circular aperture in a rectangle i.e. <code>FiniteStop{T,CircularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L242-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Annulus" href="#OpticSim.Annulus"><code>OpticSim.Annulus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a circle i.e. <code>FiniteStop{T,CircularStopShape,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Stop.jl#L262-L266">source</a></section></article><h2 id="Parametric-Surfaces"><a class="docs-heading-anchor" href="#Parametric-Surfaces">Parametric Surfaces</a><a id="Parametric-Surfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Surfaces" title="Permalink"></a></h2><p>A parametric surface must partition space into two valid half-spaces, i.e. <em>inside</em> and <em>outside</em>. The surface must also be parameterized by two variables, nominally <code>u</code> and <code>v</code>. Typically these surfaces cannot be intersected with a ray analytically and so must be triangulated and an iterative solution found.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ParametricSurface" href="#OpticSim.ParametricSurface"><code>OpticSim.ParametricSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParametricSurface{T,N} &lt;: Surface{T}</code></pre><p><code>T</code> is the number type used to represent the surface, e.g., <code>Float64</code>. <code>N</code> is the dimension of the space the surface is embedded in. <code>ParametricSurface</code>s are valid CSG objects, in some cases (where analytic intersection isn&#39;t possible) they must be wrapped in an <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a> for use.</p><p><strong>Must</strong> implement the following:</p><pre><code class="language-julia">uv(surface::ParametricSurface{T,N}, p::SVector{N,T}) -&gt; SVector{2,T}
uvrange(surface::ParametricSurface{T,N}) -&gt; Tuple{Tuple{T,T},Tuple{T,T}}
point(surface::ParametricSurface{T,N}, u::T, v::T) -&gt; SVector{N,T}
partials(surface::ParametricSurface{T,N}, u::T, v::T) -&gt; Tuple{SVector{N,T}, SVector{N,T}}
normal(surface::ParametricSurface{T,N}, u::T, v::T) -&gt; SVector{N,T}
inside(surface::ParametricSurface{T,N}, p: :SVector{N,T}) -&gt; Bool
onsurface(surface::ParametricSurface{T,N}, p::SVector{N,T}) -&gt; Bool
surfaceintersection(surface::ParametricSurface{T,N}, AbstractRay::Ray{T,N}) -&gt; Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}
interface(surface::ParametricSurface{T,N}) -&gt; OpticalInterface{T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L78-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.AcceleratedParametricSurface" href="#OpticSim.AcceleratedParametricSurface"><code>OpticSim.AcceleratedParametricSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AcceleratedParametricSurface{T,N,S} &lt;: ParametricSurface{T,N}</code></pre><p>Wrapper class for <a href="#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s where analytical intersection isn&#39;t feasible (e.g. <a href="#OpticSim.ZernikeSurface"><code>ZernikeSurface</code></a>, <a href="#OpticSim.ChebyshevSurface"><code>ChebyshevSurface</code></a>). The surface is instead triangulated and an iterative (newton raphson) process carried out to determine precise ray intersection points. <code>S</code> is the type of the ParametricSurface being wrapped.</p><pre><code class="language-julia">AcceleratedParametricSurface(surf::ParametricSurface{T,N}, numsamples::Int = 17; interface::NullOrFresnel{T} = nullinterface(T))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/AccelSurface.jl#L23-L33">source</a></section></article><h3 id="Parametric-Surface-Types"><a class="docs-heading-anchor" href="#Parametric-Surface-Types">Parametric Surface Types</a><a id="Parametric-Surface-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Surface-Types" title="Permalink"></a></h3><p>These are the available types of parametric surfaces which are already implemented, all of which can be used in the creation of CSG objects. New <code>ParametricSurface</code>s can be added with relative ease providing they follow the interface defined above.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Cylinder" href="#OpticSim.Cylinder"><code>OpticSim.Cylinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cylinder{T,N} &lt;: ParametricSurface{T,N}</code></pre><p>Cylinder of infinite height centered at the origin, oriented along the z-axis. <code>visheight</code> is used for visualization purposes only, <strong>note that this does not fully represent the surface</strong>.</p><pre><code class="language-julia">Cylinder(radius::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Cylinder.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Plane" href="#OpticSim.Plane"><code>OpticSim.Plane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plane{T,N} &lt;: ParametricSurface{T,N}</code></pre><p>Infinite planar surface where the positive normal side is outside the surface.</p><p>By default this will not create any geometry for visualization, the optional <code>vishalfsizeu</code> and <code>vishalfsizev</code> arguments can be used to draw the plane as a rectangle for visualization <strong>note that this does not fully represent the surface</strong>. In this case, the rotation of the rectangle around the normal to the plane is defined by <code>visvec</code> - <code>surfacenormal×visvec</code> is taken as the vector along the u axis.</p><pre><code class="language-julia">Plane(surfacenormal::SVector{N,T}, pointonplane::SVector{N,T}; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])
Plane(nx::T, ny::T, nz::T, x::T, y::T, z::T; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Plane.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Sphere" href="#OpticSim.Sphere"><code>OpticSim.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Sphere{T,N} &lt;: ParametricSurface{T,N}</code></pre><p>Spherical surface centered at the origin.</p><pre><code class="language-julia">Sphere(radius::T = 1.0; interface::NullOrFresnel{T} = nullinterface(T))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Sphere.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.SphericalCap" href="#OpticSim.SphericalCap"><code>OpticSim.SphericalCap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SphericalCap{T} &lt;: ParametricSurface{T}</code></pre><p>Spherical cap surface, creates a half-space which is essentially the subtraction of a sphere from an infinite plane. Only the spherical cap itself is visualized, not the plane. The positive normal side is outside the surface.</p><p><strong>Can be used as a detector in <a href="../systems/#OpticSim.OpticalSystem"><code>OpticalSystem</code></a>s.</strong></p><pre><code class="language-julia">SphericalCap(radius::T, ϕmax::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a spherical cap centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/SphericalCap.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ZernikeSurface" href="#OpticSim.ZernikeSurface"><code>OpticSim.ZernikeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZernikeSurface{T,N,P,Q} &lt;: ParametricSurface{T,N}</code></pre><p>Surface incorporating the Zernike polynomials - radius, conic and aspherics are defined relative to absolute semi-diameter, Zernike terms are normalized according to the <code>normradius</code> parameter. <code>T</code> is the datatype, <code>N</code> is the dimensionality, <code>P</code> is the number of Zernike terms and <code>Q</code> is the number of aspheric terms. Only even aspheric terms are supported.</p><p>The surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of <code>0 &lt;= ρ &lt;= 1</code> the height of the surface is not necessarily well defined, so NaN may be returned.</p><p>For convenience the input <code>zcoeff</code> can be indexed using either OSA or Noll convention, indicated using the <code>indexing</code> argument as either <code>ZernikeIndexingOSA</code> or <code>ZernikeIndexingNoll</code>.</p><pre><code class="language-julia">ZernikeSurface(semidiameter, radius = Inf, conic = 0, zcoeff = nothing, aspherics = nothing, normradius = semidiameter, indexing = ZernikeIndexingOSA)</code></pre><p><code>zcoeff</code> and <code>aspherics</code> should be vectors containing tuples of the form <code>(i, v)</code> where <code>i</code> is either the index of the Zernike term for the corresponding <code>indexing</code>, or the polynomial power of the aspheric term (must be even) and <code>v</code> is the corresponding coefficient <span>$A_i$</span> or <span>$\alpha_i$</span> respectively..</p><p>The sag is defined by the equation</p><p class="math-container">\[z(r,\phi) = \frac{cr^2}{1 + \sqrt{1 - (1+k)c^2r^2}} + \sum_{i}^{Q}\alpha_ir^{2i} + \sum_{i}^PA_iZ_i(\rho, \phi)\]</p><p>where <span>$\rho = \frac{r}{\texttt{normradius}}$</span>, <span>$c = \frac{1}{\texttt{radius}}$</span>, <span>$k = \texttt{conic}$</span> and <span>$Z_n$</span> is the nᵗʰ Zernike polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Zernike.jl#L136-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BezierSurface" href="#OpticSim.BezierSurface"><code>OpticSim.BezierSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BezierSurface{P,S,N,M} &lt;: SplineSurface{P,S,N,M}</code></pre><p>Bezier surface defined by grid of control points.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>This surface does not create a valid half-space, requires updates to function correctly.</p></div></div><pre><code class="language-julia">BezierSurface{P,S,N,M}(controlpoints::AbstractArray{&lt;:AbstractArray{S,1},2})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Curves/Bezier.jl#L79-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BSplineSurface" href="#OpticSim.BSplineSurface"><code>OpticSim.BSplineSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSplineSurface{P,S,N,M} &lt;: SplineSurface{P,S,N,M}</code></pre><p>Curve order is the same in the u and v direction and fixed over all spans. u and v knot vectors are allowed to be different - <em>may change this to make them both the same</em>.</p><p>Control points in the u direction correspond to columns, with the lowest value of u corresponding to row 1. Control points in the v direction correspond to rows, with the lowest value of v corresponding to col 1.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>This surface does not create a valid half-space, requires updates to function correctly.</p></div></div><pre><code class="language-julia">BSplineSurface{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{&lt;:AbstractArray{S,1},2})
BSplineSurface{P,S,N,M}(uknots::KnotVector{S}, vknots::KnotVector{S}, controlpoints::AbstractArray{&lt;:AbstractArray{S,1},2})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Curves/BSpline.jl#L81-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QTypeSurface" href="#OpticSim.QTypeSurface"><code>OpticSim.QTypeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QTypeSurface{T,D,M,N} &lt;: ParametricSurface{T,D}</code></pre><p>Surface incorporating the QType polynomials - radius and conic are defined relative to absolute semi-diameter, QType terms are normalized according to the <code>normradius</code> parameter. <code>T</code> is the datatype, <code>D</code> is the dimensionality, <code>M</code> and <code>N</code> are the maximum QType terms used.</p><p>The surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 &lt;= ρ &lt;= 1 the height of the surface is not necessarily well defined, so NaN may be returned.</p><pre><code class="language-julia">QTypeSurface(semidiameter; radius = Inf, conic = 0.0, αcoeffs = nothing, βcoeffs = nothing, normradius = semidiameter)</code></pre><p><code>αcoeffs</code> and <code>βcoeffs</code> should be a vector of tuples of the form <code>(m, n, v)</code> where <code>v</code> is the value of the coefficient <span>$α_n^m$</span> or <span>$β_n^m$</span> respectively.</p><p>The sag is defined by the equation</p><p class="math-container">\[\begin{aligned}
z(r,\phi) = &amp; \frac{cr^2}{1 + \sqrt{1 - (1+k)c^2r^2}} + \frac{\sqrt{1 + kc^2r^2}}{\sqrt{1-(1+k)c^2r^2}} \cdot \\
             &amp; \left\{ \rho^2(1-\rho^2)\sum_{n=0}^{N}\alpha_n^0 Q_n^0 (\rho^2) + \sum_{m=1}^{M}\rho^m\sum_{n=0}^N \left[ \alpha_n^m\cos{m\phi} +\beta_n^m\sin{m\phi}\right]Q_n^m(\rho^2) \right\}
\end{aligned}\]</p><p>where <span>$\rho = \frac{r}{\texttt{normradius}}$</span>, <span>$c = \frac{1}{\texttt{radius}}$</span>, <span>$k = \texttt{conic}$</span> and <span>$Q_n^m$</span> is the QType polynomial index <span>$m$</span>, <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Qtype.jl#L416-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ChebyshevSurface" href="#OpticSim.ChebyshevSurface"><code>OpticSim.ChebyshevSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ChebyshevSurface{T,N,P,Q} &lt;: ParametricSurface{T,N}</code></pre><p>Rectangular surface incorporating Chebyshev polynomials as well as radius and conic terms. <code>T</code> is the datatype, <code>N</code> is the dimensionality, <code>P</code> is the number of Chebyshev terms in u and <code>Q</code> is the number of Chebyshev terms in v.</p><p>The surface is centered at the origin and treated as being the cap of an infinite rectangular prism, thus creating a true half-space. <strong>Note that the surface is vertically offset so that the center (i.e., <code>(u,v) == (0,0)</code>) lies at 0 on the z-axis.</strong></p><pre><code class="language-julia">ChebyshevSurface(halfsizeu, halfsizev, chebycoeff; radius = Inf, conic = 0)</code></pre><p><code>chebycoeff</code> is a vector containing tuples of the form <code>(i, j, v)</code> where <code>v</code> is the value of the coefficient <span>$c_{ij}$</span>.</p><p>The sag is defined by the equation</p><p class="math-container">\[z(u,v) = \frac{c(u^2 + v^2)^2}{1 + \sqrt{1 - (1+k)c^2(u^2 + v^2)}} + \sum_{i}^{P}\sum_{j}^{Q}c_{ij}T_i(u)T_j(v)\]</p><p>where <span>$c = \frac{1}{\texttt{radius}}$</span>, <span>$k = \texttt{conic}$</span> and <span>$T_n$</span> is the nᵗʰ Chebyshev polynomial of the first kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/Chebyshev.jl#L110-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridSagSurface" href="#OpticSim.GridSagSurface"><code>OpticSim.GridSagSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridSagSurface{T,N,S&lt;:Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}},Nu,Nv} &lt;: ParametricSurface{T,N}</code></pre><p>Either a Zernike (circular) or Chebyshev (rectangular) surface with grid sag height added to the base sag. The surface shape is determined by either a linear or a bicubic spline interpolation of the <code>Nu×Nv</code> grid of sag values, set by the <code>interpolation</code> argument taking either <code>GridSagLinear</code> or <code>GridSagBicubic</code>.</p><p>Each entry in the grid is a vector of the form <span>$[z, \frac{\partial z}{\partial x}, \frac{\partial z}{\partial y}, \frac{\partial^2 z}{\partial x \partial y}]$</span>. The first data item corresponds to the lower left corner of the surface, that is, the corner defined by the -u and -v limit. Each point that follows is read across the face of the surface from left to right moving upwards. If zero is given for the partials (and using bicubic interpolation) then the partials will be approximated using finite differences.</p><p>The sag grid can be decentered from the surface in uv space, if so the surface may become wild outside of the area over which the grid is defined. It is advised to clip the surface to the valid area using CSG operations in this case.</p><p>A surface can also be generated from a <code>.GRD</code> file by passing in the filename as the first and only positional argument. In this case the surface will be rectangular with optional radius and conic.</p><p>See docs for <a href="#OpticSim.ZernikeSurface"><code>ZernikeSurface</code></a> and <a href="#OpticSim.ChebyshevSurface"><code>ChebyshevSurface</code></a> for details of the base surface.</p><pre><code class="language-julia">GridSagSurface(basesurface::Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}}, sag_grid::AbstractArray{T,3}; interpolation = GridSagBicubic, decenteruv = (0, 0))
GridSagSurface{T}(filename::String; radius = Inf, conic = 0, interpolation = GridSagBicubic)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/GridSag.jl#L29-L51">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><p>These are some useful functions related to <code>Surface</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real" href="#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real"><code>OpticSim.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point(surf::ParametricSurface{T}, u::T, v::T) -&gt; SVector{3,T}
point(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; SVector{3,T}</code></pre><p>Returns the 3D point on <code>surf</code> at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.normal" href="#OpticSim.normal"><code>OpticSim.normal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal(surf::ParametricSurface{T}, u::T, v::T) -&gt; SVector{3,T}
normal(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; SVector{3,T}</code></pre><p>Returns the normal to <code>surf</code> at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real" href="#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real"><code>OpticSim.partials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partials(surf::ParametricSurface{T}, u::T, v::T) -&gt; (SVector{3,T}, SVector{3,T})
partials(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; (SVector{3,T}, SVector{3,T})</code></pre><p>Returns a tuple of the 3D partial derivatives of <code>surf</code> with respect to u and v at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uvrange" href="#OpticSim.uvrange"><code>OpticSim.uvrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uvrange(s::ParametricSurface)
uvrange(::Type{S}) where {S&lt;:ParametricSurface}</code></pre><p>Returns a tuple of the form: <code>((umin, umax), (vmin, vmax))</code> specifying the limits of the parameterisation for this surface type. Also implemented for some <code>Surface</code>s which are not <code>ParametricSurface</code>s (e.g. <code>Rectangle</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L151-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uv" href="#OpticSim.uv"><code>OpticSim.uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uv(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; SVector{2,T}
uv(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; SVector{2,T}</code></pre><p>Returns the uv coordinate on <code>surf</code> of a point, <code>p</code>, in 3D space. If <code>onsurface(surf, p)</code> is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uvtopix" href="#OpticSim.uvtopix"><code>OpticSim.uvtopix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -&gt; Tuple{Int,Int}</code></pre><p>Converts a uvcoordinate on <code>surf</code> to an integer index to a pixel in an image of size <code>imsize</code>. Not implemented on all <code>Surface</code> objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an <a href="../systems/#OpticSim.OpticalSystem"><code>OpticalSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Primitives/NonCSG/Rectangle.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real" href="#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real"><code>OpticSim.inside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inside(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; Bool
inside(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>inside</em> <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real" href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real"><code>OpticSim.onsurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onsurface(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; Bool
onsurface(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>on</em> <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.interface" href="#OpticSim.interface"><code>OpticSim.interface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interface(surf::Surface{T}) -&gt; OpticalInterface{T}</code></pre><p>Return the <a href="../interfaces/#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> associated with <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/AccelSurface.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{S}, Tuple{AcceleratedParametricSurface{S,N,S1} where S1&lt;:ParametricSurface{S,N},AbstractRay{S,N}}} where N where S" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{S}, Tuple{AcceleratedParametricSurface{S,N,S1} where S1&lt;:ParametricSurface{S,N},AbstractRay{S,N}}} where N where S"><code>OpticSim.surfaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}</code></pre><p>Calculates the intersection of <code>r</code> with a surface of any type, <code>surf</code>. Note that some surfaces cannot be intersected analytically so must be wrapped in an <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a> in order to be intersected.</p><p>Returns an <a href="../csg/#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no <a href="../csg/#OpticSim.Intersection"><code>Intersection</code></a>, an <a href="../csg/#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections and a <a href="../csg/#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/AccelSurface.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.samplesurface" href="#OpticSim.samplesurface"><code>OpticSim.samplesurface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)</code></pre><p>Sample a parametric surface on an even <code>numsamples</code>×<code>numsamples</code> grid in UV space with provided function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.triangulate" href="#OpticSim.triangulate"><code>OpticSim.triangulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)</code></pre><p>Create an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.makemesh" href="#OpticSim.makemesh"><code>OpticSim.makemesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makemesh(object, subdivisions::Int = 30) -&gt; TriangleMesh</code></pre><p>Creates a <a href="#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> from an object, either a <a href="#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>, <a href="../csg/#OpticSim.CSGTree"><code>CSGTree</code></a> or certain surfaces (e.g. <code>Circle</code>, <code>Rectangle</code>). This is used for visualization purposes only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/Surface.jl#L251-L256">source</a></section></article><h2 id="Bounding-Boxes"><a class="docs-heading-anchor" href="#Bounding-Boxes">Bounding Boxes</a><a id="Bounding-Boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounding-Boxes" title="Permalink"></a></h2><p>Bounding boxes are mostly used internally for efficiency, but are also exposed to the user for visualization (and any other) purposes. All bounding boxes are axis aligned.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BoundingBox" href="#OpticSim.BoundingBox"><code>OpticSim.BoundingBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundingBox{T&lt;:Real}</code></pre><p>Axis-aligned three-dimensional bounding box.</p><pre><code class="language-julia">BoundingBox(xmin::T, xmax::T, ymin::T, ymax::T, zmin::T, zmax::T)
BoundingBox(s::Surface{T})
BoundingBox(s::ParametricSurface{T,3}, transform::RigidBodyTransform{T} = identitytransform(T))
BoundingBox(c::CSGTree{T})
BoundingBox(tri::Triangle{T})
BoundingBox(triangles::AbstractVector{Triangle{T}})
BoundingBox(points::AbstractArray{SVector{3,T}})
BoundingBox(la::LensAssembly{T})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/BoundingBox.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.doesintersect" href="#OpticSim.doesintersect"><code>OpticSim.doesintersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -&gt; Bool</code></pre><p>Tests whether <code>r</code> intersects an axis-aligned <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a>, <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/BoundingBox.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T&lt;:Real" href="#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T&lt;:Real"><code>OpticSim.surfaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfaceintersection(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -&gt; Union{EmptyInterval{T},Interval{T}}</code></pre><p>Calculates the intersection of <code>r</code> with an axis-aligned <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a>, <code>bbox</code>.</p><p>Returns an <a href="../csg/#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no intersection or an <a href="../csg/#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections. Note that the uv of the returned intersection is always <strong>0</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/43bab8b3dc256e00ef781d55d5e216f64f558820/src/Geometry/BoundingBox.jl#L259-L266">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../csg/">CSG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 March 2021 18:25">Thursday 25 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
