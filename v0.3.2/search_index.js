var documenterSearchIndex = {"docs":
[{"location":"glasscat/#GlassCat","page":"Glass Functions","title":"GlassCat","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Julia module for importing and using AGF glass specifications.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"The entire AGF glass catalog is specified in AGFGlassCat.jl. This Julia source file is generated automatically when ] build OpticSim is called. The build script downloads AGF files to deps/downloads/glasscat/ and then uses these to generate corresponding Julia source files at src/GlassCat/data/. These steps are run automatically on setup when the package is first installed using ] add OpticSim, creating a sufficient working environment for our example/test code.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Adding new AGF sources is done by editing deps/sources.txt. Minimally, you must provide a name (e.g. SCHOTT) and sha256sum for the AGF file, which can then be placed manually into deps/downloads/glasscat/[NAME].agf. Instead of manually sourcing the AGF file, you can also provide a download link for the build script. deps/sources.txt already contains examples of all possible use cases. After updating the file, execute ] build OpticSim to rebuild AGFGlassCat.jl.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Source names will be used as module names, so follow the standard convections: alphanumeric, no leading numbers, begin with an uppercase letter. Furthermore, optical systems in the examples file expect glass catalogs to have specific names. The default setup includes HOYA, NIKON, OHARA, SCHOTT and Sumita; changing these names could break some examples.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Glass types are accessed like so: OpticSim.GlassCat.CATALOG_NAME.GLASS_NAME, e.g.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.Sumita.LAK7\nOpticSim.GlassCat.SCHOTT.PK3","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"All glasses and catalogs are exported in their respective modules, so it is possible to invoke using calls for convenience, e.g.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"using OpticSim\nGlassCat.Sumita.LAK7\nusing OpticSim.GlassCat\nSCHOTT.PK3\nusing OpticsSim.GlassCat.SCHOTT\nN_BK7","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Autocompletion can be used to see available catalogs and glasses. All catalog glasses are of type OpticSim.GlassCat.Glass. Note that special characters in glass/catalog names are replaced with _. There is a special type and constant value for air: OpticSim.GlassCat.Air.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Unitful.jl is used to manage units, meaning any valid unit can be used for all arguments, e.g., wavelength can be passed in as μm or nm (or cm, mm, m, etc.). Non-unitful options are also available, in which case units are assumed to be μm, °C and Atm for length, temperature and pressure respectively.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"TEMP_REF and PRESSURE_REF are constants:","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"const TEMP_REF = 20.0 # °C\nconst PRESSURE_REF = 1.0 # Atm","category":"page"},{"location":"glasscat/#Types","page":"Glass Functions","title":"Types","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.AbstractGlass\nOpticSim.GlassCat.Glass\nOpticSim.GlassCat.Air\nOpticSim.GlassCat.GlassID","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.AbstractGlass","page":"Glass Functions","title":"OpticSim.GlassCat.AbstractGlass","text":"Abstract type encapsulating all glasses.\n\n\n\n\n\n","category":"type"},{"location":"glasscat/#OpticSim.GlassCat.Glass","page":"Glass Functions","title":"OpticSim.GlassCat.Glass","text":"Stores all attributes relating to a glass type specified in an .AGF glass catalog.\n\nNever used directly, instead created using catalog glasses, e.g. GlassCat.SCHOTT.N_BK7.\n\nIn order to prevent type ambiguities in OpticSim.jl we can't have this type paramaterized.\n\n\n\n\n\n","category":"type"},{"location":"glasscat/#OpticSim.GlassCat.Air","page":"Glass Functions","title":"OpticSim.GlassCat.Air","text":"Special glass to represent air. Refractive index is defined to always be 1.0 for any temperature and pressure (other indices are relative to this).\n\n\n\n\n\n","category":"constant"},{"location":"glasscat/#OpticSim.GlassCat.GlassID","page":"Glass Functions","title":"OpticSim.GlassCat.GlassID","text":"Object identifying a glass, containing a type (e.g. MODEL, MIL, OTHER or AGF) depending on how the glass is defined, and an integer ID. Air is AIR:0, others are on the form AGF:N, for example.\n\n\n\n\n\n","category":"type"},{"location":"glasscat/#Functions","page":"Glass Functions","title":"Functions","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.index\nOpticSim.GlassCat.absairindex\nOpticSim.GlassCat.absorption","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.index","page":"Glass Functions","title":"OpticSim.GlassCat.index","text":"index(glass::AbstractGlass, wavelength; temperature=20°C, pressure=1Atm)\n\nCompute the refractive index of glass at wavelength, optionally at specified temperature and pressure. Result is relative to the refractive index of air at given temperature and pressure.\n\nIf unitless, arguments are interpretted as μm, °C and Atm respectively.\n\nThis is defined to always equal 1.0 for Air at any temperature and pressure, use absairindex for the absolute refractive index of air at a given temperature and pressure.\n\nExamples\n\njulia> index(GlassCat.Sumita.LAK7, 700u\"nm\")\n1.646494204478318\n\njulia> index(GlassCat.SCHOTT.N_BK7, 0.55, temperature = 22.0)\n1.51852824383283\n\njulia> index(GlassCat.HOYA.FF1, 532u\"nm\", temperature = 25u\"°C\", pressure = 1.3)\n1.5144848290944655\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.absairindex","page":"Glass Functions","title":"OpticSim.GlassCat.absairindex","text":"absairindex(wavelength; temperature=20°C, pressure=1Atm)\n\nCompute the absolute refractive index of air at wavelength, optionally at specified temperature and pressure. If unitless, arguments are interpretted as μm, °C and Atm respectively.\n\nExamples\n\njulia> absairindex(700u\"nm\")\n1.000271074905147\n\njulia> absairindex(0.7, temperature=27.0)\n1.000264738846504\n\njulia> absairindex(532u\"nm\", temperature = 25u\"°C\", pressure = 1.3)\n1.0003494991178161\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.absorption","page":"Glass Functions","title":"OpticSim.GlassCat.absorption","text":"absorption(glass::AbstractGlass, wavelength; temperature=20°C, pressure=1Atm)\n\nCompute the intensity absorption per mm of glass at wavelength, optionally at specified temperature and pressure. Transmission values are linearly interpolated from the adjacent values in the data table of glass, if wavelength is below the minimum or above the maximum in the table then the nearest value is taken.\n\nAbsorption is defined as frac-log(t)tau where t is the transmission value and tau is the thickness, both of which are provided in the data table.\n\nIf unitless, arguments are interpretted as μm, °C and Atm respectively.\n\nExamples\n\njulia> absorption(GlassCat.Sumita.LAK7, 700u\"nm\")\n0.0006018072325563021\n\njulia> absorption(GlassCat.SCHOTT.N_BK7, 0.55, temperature = 22.0)\n0.00016504471175660636\n\njulia> absorption(GlassCat.SCHOTT.PSK3, 532u\"nm\", temperature = 25u\"°C\", pressure = 1.3)\n0.00020855284788532435\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.glassfromMIL\nOpticSim.GlassCat.modelglass","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.glassfromMIL","page":"Glass Functions","title":"OpticSim.GlassCat.glassfromMIL","text":"glassfromMIL(glasscode::Union{Float64,Int}) -> Glass\n\nGenerates a glass object for the given glass code based on U.S. military standard MIL-G-174, see the MIL specification for further details.\n\nThe glass code is a six-digit number specifying the glass according to its refractive index Nd at d-light (587.5618nm), and its Abbe number Vd also taken at d-light. The resulting glass code is the value of Nd - 1 rounded to three digits, followed by Vd rounded to three digits, with all decimal points ignored. For example, N_BK7 has Nd = 1.5168 and Vd = 64.17, giving a six-digit glass code of 517642.\n\nFor Nd > 1.999 the format 1.123642 can be used representing Nd = 2.123 and Vd = 64.2.\n\nAccuracy is poor given the low precision of the input parameters, the mean error to measured data may be significant. Behavior may differ from other optical simulation tools when using MIL glasses. The approximate dispersion calculation used these glasses is generally only valid for visible wavelengths, in this case a limit of 360nm to 750nm is imposed.\n\nExamples\n\njulia> index(glassfromMIL(517642), 0.5875618)\n1.5170003960064509\n\njulia> index(glassfromMIL(1.134642), 0.5875618)\n2.1340008686098946\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.modelglass","page":"Glass Functions","title":"OpticSim.GlassCat.modelglass","text":"modelglass(Nd::Float64, Vd::Float64, ΔPgF::Float64) -> Glass\n\nGenerates a glass object for the given refractive index at d-light (587.5618nm), Nd, the Abbe number also at d-light, Vd, and partial dispersion, ΔPgF. The mean error to measured data for these models is typically small - usually < 0.0001. Behavior may differ from other optical simulation tools when using model glasses.\n\nThe approximate dispersion calculation used for these glasses is generally only valid for visible wavelengths, in this case a limit of 360nm to 750nm is imposed.\n\nExamples\n\njulia> index(modelglass(1.5168, 64.17, 0.0), 0.5875618)\n1.5168003970108495\n\njulia> index(modelglass(1.2344, 61.57, 0.003), 0.678)\n1.2329425902693352\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.glasscatalogs\nOpticSim.GlassCat.glasses\nOpticSim.GlassCat.info\nOpticSim.GlassCat.findglass\nOpticSim.GlassCat.isair","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.glasscatalogs","page":"Glass Functions","title":"OpticSim.GlassCat.glasscatalogs","text":"glasscatalogs()\n\nReturns the complete list of glass catalogs available from GlassCat.\n\nExample\n\njulia> glasscatalogs()\n41-element Array{Any,1}:\n OpticSim.GlassCat.AMTIR\n OpticSim.GlassCat.ANGSTROMLINK\n OpticSim.GlassCat.APEL\n OpticSim.GlassCat.ARCHER\n OpticSim.GlassCat.ARTON\n OpticSim.GlassCat.AUER_LIGHTING\n OpticSim.GlassCat.BIREFRINGENT\n ⋮\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.info","page":"Glass Functions","title":"OpticSim.GlassCat.info","text":"info([io::IO], glass::AbstractGlass)\n\nPrint out all data associated with glass in an easily readable format.\n\nExamples\n\njulia> info(GlassCat.RPO.IG4)\nID:                                                AGF:52\nDispersion formula:                                Schott (1)\nDispersion formula coefficients:\n     a₀:                                           6.91189161\n     a₁:                                           -0.000787956404\n     a₂:                                           -4.22296071\n     a₃:                                           142.900646\n     a₄:                                           -1812.32748\n     a₅:                                           7766.33028\nValid wavelengths:                                 3.0μm to 12.0μm\nReference temperature:                              20.0°C\nThermal ΔRI coefficients:\n     D₀:                                           3.24e-5\n     D₁:                                           0.0\n     D₂:                                           0.0\n     E₀:                                           0.0\n     E₁:                                           0.0\n     λₜₖ:                                          0.0\nTCE (÷1e-6):                                       20.4\nIgnore thermal expansion:                          false\nDensity (p):                                       4.47g/m³\nΔPgF:                                              0.0\nRI at sodium D-Line (587nm):                       1.0\nAbbe Number:                                       0.0\nCost relative to N_BK7:                              ?\nStatus:                                            Standard (0)\nMelt frequency:                                    0\nExclude substitution:                              false\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.findglass","page":"Glass Functions","title":"OpticSim.GlassCat.findglass","text":"findglass(condition::Function) -> Vector{Glass}\n\nReturns the list of glasses which satisfy condition where condition::(Glass -> Bool).\n\nExample\n\njulia> findglass(x -> (x.Nd > 2.3 && x.λmin < 0.5 && x.λmax > 0.9))\n8-element Array{GlassCat.Glass,1}:\n BIREFRINGENT.TEO2_E\n BIREFRINGENT.PBMOO4\n BIREFRINGENT.LINBO3\n INFRARED.CLEARTRAN_OLD\n INFRARED.CLEARTRAN\n INFRARED.SRTIO3\n INFRARED.ZNS_BROAD\n INFRARED.ZNS_VIS\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.glassname\nOpticSim.GlassCat.glassid\nOpticSim.GlassCat.glassforid","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.glassname","page":"Glass Functions","title":"OpticSim.GlassCat.glassname","text":"glassname(g::Union{AbstractGlass,GlassID})\n\nGet the name (including catalog) of the glass, or glass with this ID.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.glassid","page":"Glass Functions","title":"OpticSim.GlassCat.glassid","text":"glassid(g::AbstractGlass) -> GlassID\n\nGet the ID of the glass, see GlassID.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.glassforid","page":"Glass Functions","title":"OpticSim.GlassCat.glassforid","text":"glassforid(ID::GlassID)\n\nGet the glass for a given ID.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.polyfit_indices\nOpticSim.GlassCat.plot_indices","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.polyfit_indices","page":"Glass Functions","title":"OpticSim.GlassCat.polyfit_indices","text":"polyfit_indices(wavelengths, n_rel; degree=5)\n\nFit a polynomial to indices at wavelengths, optionally specifying the degree of the polynomial. Returns tuple of array of fitted indices at wavelengths and the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.plot_indices","page":"Glass Functions","title":"OpticSim.GlassCat.plot_indices","text":"plot_indices(glass::AbstractGlass; polyfit=false, fiterror=false, degree=5, temperature=20°C, pressure=1Atm, nsamples=300, sampling_domain=\"wavelength\")\n\nPlot the refractive index for glass for nsamples within its valid range of wavelengths, optionally at temperature and pressure. polyfit will show a polynomial of optionally specified degree fitted to the data, fiterror will also show the fitting error of the result. sampling_domain specifies whether the samples will be spaced uniformly in \"wavelength\" or \"wavenumber\".\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We are currently in the early stages of implementing optimization for lens surfaces.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We have had success using Optim.jl and ForwardDiff.jl among other packages, though ForwardDiff.jl gradient and hessian pre-compilation can be very slow for complex systems.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Other optimization packages should integrate easily with the system too: JuMP.jl, Ipopt.jl and NLOpt.jl are some options.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Merit functions must currently be implemented by the user, this is quite straight-forward as trace returns the vast majority of information that could be needed in the form of a LensTrace which hits the detector (or nothing if the ray doesn't reach the detector).","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"There are some helper functions implemented for AxisymmetricOpticalSystems which can make optimization of basic systems much easier:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"OpticSim.Optimization\nOpticSim.Optimization.optimizationvariables\nOpticSim.Optimization.updateoptimizationvariables","category":"page"},{"location":"optimization/#OpticSim.Optimization","page":"Optimization","title":"OpticSim.Optimization","text":"Optimization interface consists of two functions optimizationvariables and updateoptimizationvariables. optimizationvariables packs variables to be optimized into a vector. updateoptimizationvariables receives a vector of variables and creates a new optical system with the variable values.\n\n\n\n\n\n","category":"module"},{"location":"optimization/#OpticSim.Optimization.optimizationvariables","page":"Optimization","title":"OpticSim.Optimization.optimizationvariables","text":"optimizationvariables(a::AxisymmetricOpticalSystem{T}) -> Vector{T}\n\nPack variables that have been marked to be optimized into a vector in a form suitable for the optimizer. Variables are marked for optimization by having a true value in the :OptimizeName column, where Name can be Radius, Thickness or Conic.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#OpticSim.Optimization.updateoptimizationvariables","page":"Optimization","title":"OpticSim.Optimization.updateoptimizationvariables","text":"updateoptimizationvariables(a::AxisymmetricOpticalSystem{T}, optimizationvariables::Vector{S}) -> AxisymmetricOpticalSystem{S}\n\nCreates a new optical system with updated variables corresponding to the optimization variables.\n\n\n\n\n\n","category":"function"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"It is of course possible to write your own optimization loop for more complex (i.e. non-AxisymmetricOpticalSystem) systems and this should work without issue.","category":"page"},{"location":"optimization/#Example","page":"Optimization","title":"Example","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"using OpticSim\nusing ForwardDiff\nusing Optim\n\nfunction objective(a::AbstractVector{T}, b::AxisymmetricOpticalSystem{T}, samples::Int = 3) where {T}\n    # RMSE spot size\n    system = Optimization.updateoptimizationvariables(b, a)\n    # distribute rays evenly across entrance pupil using HexapolarField\n    field = HexapolarField(system, collimated = true, samples = samples)\n    error = zero(T)\n    hits = 0\n    for r in field\n        traceres = trace(system, r, test = true)\n        if traceres !== nothing # ignore rays which miss\n            hitpoint = point(traceres)\n            if abs(hitpoint[1]) > eps(T) && abs(hitpoint[2]) > eps(T)\n                dist_to_axis = hitpoint[1]^2 + hitpoint[2]^2\n                error += dist_to_axis\n            end\n            hits += 1\n        end\n    end\n    if hits > 0\n        error = sqrt(error / hits)\n    end\n    # if hits == 0 returns 0 - not ideal!\n    return error\nend\n\nstart, lower, upper = Optimization.optimizationvariables(system)\noptimobjective = arg -> objective(arg, system)\ngcfg = ForwardDiff.GradientConfig(optimobjective, start, ForwardDiff.Chunk{1}()) # speed up ForwardDiff significantly\nhcfg = ForwardDiff.HessianConfig(optimobjective, start, ForwardDiff.Chunk{1}())\ng! = (G, x) -> ForwardDiff.gradient!(G, optimobjective, x, gcfg)\nh! = (H, x) -> ForwardDiff.hessian!(H, optimobjective, x, hcfg)\ndf = TwiceDifferentiable(optimobjective, g!, h!, start)\ndfc = TwiceDifferentiableConstraints(lower, upper) # constrain the optimization to avoid e.g. thickness < 0\nres = optimize(df, dfc, start, algo, Optim.Options(show_trace = true, iterations = 100, allow_f_increases = true))\nfinal = Optim.minimizer(res)\nnew_system = Optimization.updateoptimizationvariables(system, final)","category":"page"},{"location":"systems/#Optical-Systems","page":"Systems","title":"Optical Systems","text":"","category":"section"},{"location":"systems/#Assemblies","page":"Systems","title":"Assemblies","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"All systems are made up of a LensAssembly which contains all the optical components in the system, excluding any sources (see Emitters) and the detector (see below).","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"LensAssembly","category":"page"},{"location":"systems/#OpticSim.LensAssembly","page":"Systems","title":"OpticSim.LensAssembly","text":"LensAssembly{T<:Real}\n\nStructure which contains the elements of the optical system, these can be CSGTree or Surface objects.\n\nIn order to prevent type ambiguities bespoke structs are created for each possible number of elements e.g. LensAssembly3. These are parameterized by the types of the elements to prevent ambiguities. Basic surface types such as Rectangle (which can occur in large numbers) are stored independently in Vectors, so type paramters are only needed for CSG objects.\n\nEach struct looks like this:\n\nstruct LensAssemblyN{T,T1,T2,...,TN} <: LensAssembly{T}\n    axis::SVector{3,T}\n    rectangles::Vector{Rectangle{T}}\n    ellipses::Vector{Ellipse{T}}\n    hexagons::Vector{Hexagon{T}}\n    paraxials::Vector{ParaxialLens{T}}\n    E1::T1\n    E2::T2\n    ...\n    EN::TN\nend\n\nWhere Ti <: Union{Surface{T},CSGTree{T}}.\n\nTo create a LensAssembly object the following functions can be used:\n\nLensAssembly(elements::Vararg{Union{Surface{T},CSGTree{T},LensAssembly{T}}}; axis = SVector(0.0, 0.0, 1.0)) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"systems/#Images","page":"Systems","title":"Images","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"The detector image is stored within the system as a HierarchicalImage for memory efficiency.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"HierarchicalImage\nOpticSim.reset!\nOpticSim.sum!","category":"page"},{"location":"systems/#OpticSim.HierarchicalImage","page":"Systems","title":"OpticSim.HierarchicalImage","text":"HierarchicalImage{T<:Number} <: AbstractArray{T,2}\n\nImage type which dynamically allocated memory for pixels when their value is set, the value of unset pixels is assumed to be zero.\n\nThis is used for the detector image of OpticalSystems which can typically be very high resolution, but often have a large proportion of the image blank.\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.reset!","page":"Systems","title":"OpticSim.reset!","text":"reset!(a::HierarchicalImage{T})\n\nResets the pixels in the image to zero(T). Do this rather than image .= zero(T) because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.sum!","page":"Systems","title":"OpticSim.sum!","text":"sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})\n\nAdd the contents of b to a in an efficient way.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"There are two types of OpticalSystem which can be used depending on the requirements.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"OpticalSystem\nCSGOpticalSystem\nAxisymmetricOpticalSystem\ntemperature\npressure\ndetectorimage\nresetdetector!\nassembly\nsemidiameter","category":"page"},{"location":"systems/#OpticSim.OpticalSystem","page":"Systems","title":"OpticSim.OpticalSystem","text":"OpticalSystem{T<:Real}\n\nAbstract type for any optical system, must parameterized by the datatype of entities within the system T.\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.CSGOpticalSystem","page":"Systems","title":"OpticSim.CSGOpticalSystem","text":"CSGOpticalSystem{T,D<:Real,S<:Surface{T},L<:LensAssembly{T}} <: OpticalSystem{T}\n\nAn optical system containing a lens assembly with all optical elements and a detector surface with associated image. The system can be at a specified temperature and pressure.\n\nThere are two number types in the type signature. The T type parameter is the numeric type for geometry in the optical system, the D type parameter is the numeric type of the pixels in the detector image. This way you can have Float64 geometry, where high precision is essential, but the pixels in the detector can be Float32 since precision is much less critical for image data.\n\nThe detector can be any Surface which implements uv, uvtopix and onsurface, typically this is one of Rectangle, Ellipse or SphericalCap.\n\nCSGOpticalSystem(assembly::LensAssembly, detector::Surface, detectorpixelsx = 1000, detectorpixelsy = 1000, ::Type{D} = Float32; temperature = OpticSim.GlassCat.TEMP_REF, pressure = OpticSim.GlassCat.PRESSURE_REF)\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.AxisymmetricOpticalSystem","page":"Systems","title":"OpticSim.AxisymmetricOpticalSystem","text":"AxisymmetricOpticalSystem{T,C<:CSGOpticalSystem{T}} <: OpticalSystem{T}\n\nOptical system which has lens elements and an image detector, created from a DataFrame containing prescription data.\n\nThese tags are supported for columns: :Radius, :SemiDiameter, :Surface, :Thickness, :Conic, :Aspherics, :Reflectance, :Material, :OptimizeRadius, :OptimizeThickness, :OptimizeConic. These tags are supported for entries in a :Surface column: :Object, :Image, :Stop Assumes the :Image row will be the last row in the DataFrame.\n\nIn practice a CSGOpticalSystem is generated automatically and stored within this system.\n\nAxisymmetricOpticalSystem{T}(prescription::DataFrame, detectorpixelsx = 1000, detectorpixelsy:: = 1000, ::Type{D} = Float32; temperature = OpticSim.GlassCat.TEMP_REF, pressure = OpticSim.GlassCat.PRESSURE_REF)\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.temperature","page":"Systems","title":"OpticSim.temperature","text":"temperature(system::OpticalSystem{T}) -> T\n\nGet the temperature of system in °C.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.pressure","page":"Systems","title":"OpticSim.pressure","text":"pressure(system::OpticalSystem{T}) -> T\n\nGet the pressure of system in Atm.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.detectorimage","page":"Systems","title":"OpticSim.detectorimage","text":"detectorimage(system::OpticalSystem{T}) -> HierarchicalImage{D}\n\nGet the detector image of system. D is the datatype of the detector image and is not necessarily the same as the datatype of the system T.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.resetdetector!","page":"Systems","title":"OpticSim.resetdetector!","text":"resetdetector!(system::OpticalSystem{T})\n\nReset the deterctor image of system to zero.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.assembly","page":"Systems","title":"OpticSim.assembly","text":"assembly(system::OpticalSystem{T}) -> LensAssembly{T}\n\nGet the LensAssembly of system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.semidiameter","page":"Systems","title":"OpticSim.semidiameter","text":"semidiameter(system::AxisymmetricOpticalSystem{T}) -> T\n\nGet the semidiameter of system, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Tracing","page":"Systems","title":"Tracing","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"We can trace an individual OpticalRay through the system (or directly through a LensAssembly), or we can trace using an OpticalRayGenerator to create a large number of rays.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"trace\ntraceMT\ntracehits\ntracehitsMT\nOpticSim.LensTrace","category":"page"},{"location":"systems/#OpticSim.trace","page":"Systems","title":"OpticSim.trace","text":"trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)\n\nReturns the ray as it exits the assembly in the form of a LensTrace object if it hits any element in the assembly, otherwise nothing. Recursive rays are offset by a small amount (RAY_OFFSET) to prevent it from immediately reintersecting the same lens element.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the assembly.\n\n\n\n\n\ntrace(system::OpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)\n\nTraces system with ray, if test is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a LensTrace if the ray hits the detector or nothing otherwise.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the system.\n\n\n\n\n\ntrace(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the detector image of the system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.traceMT","page":"Systems","title":"OpticSim.traceMT","text":"traceMT(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the accumulated detector image from all threads.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.tracehits","page":"Systems","title":"OpticSim.tracehits","text":"tracehits(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.tracehitsMT","page":"Systems","title":"OpticSim.tracehitsMT","text":"tracehitsMT(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector, accumulated from all threads.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.LensTrace","page":"Systems","title":"OpticSim.LensTrace","text":"LensTrace{T<:Real,N}\n\nContains an intersection point and the ray segment leading to it from within an optical trace. The ray carries the path length, power, wavelength, number of intersections and source number, all of which are accessible directly on this class too.\n\nHas the following accessor methods:\n\nray(a::LensTrace{T,N}) -> OpticalRay{T,N}\nintersection(a::LensTrace{T,N}) -> Intersection{T,N}\npower(a::LensTrace{T,N}) -> T\nwavelength(a::LensTrace{T,N}) -> T\npathlength(a::LensTrace{T,N}) -> T\npoint(a::LensTrace{T,N}) -> SVector{N,T}\nuv(a::LensTrace{T,N}) -> SVector{2,T}\nsourcenum(a::LensTrace{T,N}) -> Int\nnhits(a::LensTrace{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Lenses-and-Other-Optical-Components","page":"Lenses","title":"Lenses and Other Optical Components","text":"","category":"section"},{"location":"lenses/#Lenses","page":"Lenses","title":"Lenses","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"A number of helper functions are provided to make constructing simple lenses easier. Firstly ordinary thick lenses:","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"SphericalLens\nConicLens\nAsphericLens\nFresnelLens","category":"page"},{"location":"lenses/#OpticSim.SphericalLens","page":"Lenses","title":"OpticSim.SphericalLens","text":"SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))\n\nConstructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.ConicLens","page":"Lenses","title":"OpticSim.ConicLens","text":"ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))\n\nConstructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.AsphericLens","page":"Lenses","title":"OpticSim.AsphericLens","text":"AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))\n\nCosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.FresnelLens","page":"Lenses","title":"OpticSim.FresnelLens","text":"FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = OpticSim.GlassCat.Air)\n\nCreate a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on groovedepth. For negative radii the vertex on the central surface is at frontvertex, so the total thickness of the lens is thickness + groovedepth. Aspherics currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"As well as idealized lenses:","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"ParaxialLens","category":"page"},{"location":"lenses/#OpticSim.ParaxialLens","page":"Lenses","title":"OpticSim.ParaxialLens","text":"ParaxialLens{T} <: Surface{T}\n\nsurfacenormal is the output direction of the lens. Paraxial lens cannot act as the interface between two materials, hence only a single outside material is specified, by default Air.\n\nCreate with the following functions\n\nParaxialLensEllipse(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = OpticSim.GlassCat.Air, decenteruv = (0.0, 0.0))\nParaxialLensRect(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = OpticSim.GlassCat.Air, decenteruv = (0.0, 0.0))\nParaxialLensHex(focaldistance, side_length, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = OpticSim.GlassCat.Air, decenteruv = (0.0, 0.0))\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Other-Components","page":"Lenses","title":"Other Components","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"We also have some holographic elements implemented, note that these have not been extensively tested and should not be treated as wholely accurate at this stage.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"It is relatively simple to extend the existing code to add these kinds of specialized surfaces providing a paired OpticalInterface subclass is also defined. In this case the WrapperSurface can often serve as a suitable base for extension.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"WrapperSurface\nThinGratingSurface\nHologramSurface\nMultiHologramSurface","category":"page"},{"location":"lenses/#OpticSim.WrapperSurface","page":"Lenses","title":"OpticSim.WrapperSurface","text":"WrapperSurface{T,S<:Surface{T}} <: Surface{T}\n\nA generic surface type which serves as a basis for extension of Surfaces for custom OpticalInterface subclasses. Essentially just forwards all Surface and ParametricSurface methods to a field of the WrapperSurface named surface. Also provides a generic implementation of surfaceintersection which tests for an intersection with the underlying surface and returns either an EmptyInterval or a half space (never a closed interval).\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.ThinGratingSurface","page":"Lenses","title":"OpticSim.ThinGratingSurface","text":"ThinGratingSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with ThinGratingInterface.\n\nThinGratingSurface(surface::Surface{T}, interface::ThinGratingInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.HologramSurface","page":"Lenses","title":"OpticSim.HologramSurface","text":"HologramSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with HologramInterface.\n\nHologramSurface(surface::Surface{T}, interface::HologramInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.MultiHologramSurface","page":"Lenses","title":"OpticSim.MultiHologramSurface","text":"MultiHologramSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with MultiHologramInterface.\n\nMultiHologramSurface(surface::Surface{T}, interface::MultiHologramInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Eye-Models","page":"Lenses","title":"Eye Models","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"Eye models are often very useful in simulation of head mounted display systems. We have two models implemented currently.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"ModelEye\nArizonaEye","category":"page"},{"location":"lenses/#OpticSim.ModelEye","page":"Lenses","title":"OpticSim.ModelEye","text":"ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::RigidBodyTransform{T} = identitytransform(T))\n\nGeometrically accurate model of the human eye focussed at infinity with variable pupil_radius. The eye is added to the provided assembly to create a CSGOpticalSystem with the retina of the eye as the detector.\n\nThe eye can be positioned in the scene using the transform argument and the resolution of the detector specified with detpixels. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nnsamples determines the resolution at which accelerated surfaces within the eye are triangulated.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.ArizonaEye","page":"Lenses","title":"OpticSim.ArizonaEye","text":"ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)\n\nThe popular Arizona eye model taken from this definition. The accommodation of the eye can be varied in this model. Returns a DataFrame specifying the prescription of the eye model.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"There are a number of powerful visualization tools available, we primarily rely on 3D visualization of systems using Makie.","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"There are a number of helper methods, as well as the ability to draw objects, surfaces, points, rays and more individually. For example, looking at rays passing through a system in 3D and 2D:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"using OpticSim","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100)\nVis.save(\"assets/vis_ex_3d.png\") # hide\nVis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100, drawsys=true, resolution = (1000, 700))\nVis.make2dy()\nVis.save(\"assets/vis_ex_2d.png\"); nothing #hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: 3D visualization example) (Image: 2D visualization example)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"And the image on the detector for a trace of a system:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.drawtraceimage(Examples.cooketriplet(), test=true)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"using Images # hide\nim = Vis.drawtraceimage(Examples.cooketriplet(Float64, 400), test=true)\nsave(\"assets/vis_ex_im.png\", colorview(Gray, real.(im ./ maximum(im)))); nothing # hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: detector image example)","category":"page"},{"location":"vis/#Basic-Drawing","page":"Visualization","title":"Basic Drawing","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"These methods are all you need to build up a visualization piece by piece. For example:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"obj = csgintersection(Sphere(0.5), Plane(0.0, 1.0, 0.0, 0.0, 0.1, 0.0))()\nray1 = Ray([0.0, -0.1, 1.0], [0.0, 0.0, -1.0])\nray2 = Ray([0.8, 0.0, 0.0], [-1.0, 0.0, 0.0])\nVis.draw(obj)\nVis.draw!(ray1, rayscale=0.2)\nVis.draw!(ray2, rayscale=0.2, color=:blue)\nVis.draw!(surfaceintersection(obj, ray1), color=:red)\nVis.draw!(surfaceintersection(obj, ray2), color=:green)\nVis.save(\"assets/vis_ex_3d_parts.png\"); nothing # hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: basic drawing example)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"OpticSim.Vis.scene\nOpticSim.Vis.draw\nOpticSim.Vis.draw!(::Any; kwargs...)\nOpticSim.Vis.save","category":"page"},{"location":"vis/#OpticSim.Vis.scene","page":"Visualization","title":"OpticSim.Vis.scene","text":"scene(resolution = (1000, 1000))\n\nCreate a new Makie scene with the given resolution including control buttons.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.draw","page":"Visualization","title":"OpticSim.Vis.draw","text":"draw(ob; resolution = (1000, 1000), kwargs...)\n\nDraw an object in a new scene. kwargs depends on the object type.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.draw!-Tuple{Any}","page":"Visualization","title":"OpticSim.Vis.draw!","text":"draw!([scene = currentscene], ob; kwargs...)\n\nDraw an object in an existing scene. kwargs depends on the object type.\n\n\n\n\n\n","category":"method"},{"location":"vis/#OpticSim.Vis.save","page":"Visualization","title":"OpticSim.Vis.save","text":"save(path::String)\n\nSave the current Makie scene to an image file.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Helper-Methods","page":"Visualization","title":"Helper Methods","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"These are the helper methods to provide common visualizations more easily, as used above. Another example:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.surfacesag(AcceleratedParametricSurface(TestData.zernikesurface2()), (256, 256), (1.55, 1.55))","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"using Plots; include(\"../../test/TestData/TestData.jl\") # hide\np = Vis.surfacesag(AcceleratedParametricSurface(TestData.zernikesurface2()), (256, 256), (1.55, 1.55))\nPlots.savefig(p, \"assets/surface_sag.svg\"); nothing # hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: surface sag example)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"OpticSim.Vis.drawtracerays\nOpticSim.Vis.drawtraceimage\nOpticSim.Vis.spotdiag\nOpticSim.Vis.surfacesag\nOpticSim.Vis.eyebox_eval_eye\nOpticSim.Vis.eyebox_eval_planar","category":"page"},{"location":"vis/#OpticSim.Vis.drawtracerays","page":"Visualization","title":"OpticSim.Vis.drawtracerays","text":"drawtracerays(system::Q; raygenerator::S = UniformOpticalSource(CollimatedSource(GridRectOriginPoints(5, 5, 5.0, 5.0, position = SVector(0.0, 0.0, 10.0))), 0.55), test::Bool = false, trackallrays::Bool = false, colorbysourcenum::Bool = false, colorbynhits::Bool = false, rayfilter::Union{Nothing,Function} = onlydetectorrays, kwargs...)\n\nDisplays a model of the optical system. raygenerator is an iterator that generates rays. If trackallrays is true then ray paths from the emitter will be displayed otherwise just the final rays that intersect the image detector will be shown, not the entire ray path. colorbysourcenum and colorbynhits will color rays accordingly, otherwise rays will be colored according to their wavelength.\n\nBy default only ray paths that eventually intersect the detector surface are displayed. If you want to display all ray paths set rayfilter = nothing.\n\nAlso drawtracerays! to add to an existing scene, with drawsys and drawgen to specify whether system and raygenerator should be drawn respectively.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.drawtraceimage","page":"Visualization","title":"OpticSim.Vis.drawtraceimage","text":"drawtraceimage(system::Q; raygenerator::S = UniformOpticalSource(CollimatedSource(GridRectOriginPoints(25, 25, 5.0, 5.0, position = SVector(0.0, 0.0, 10.0))), 0.55), test::Bool = false)\n\nTraces rays from raygenerator through system and shows and returns the detector image. verbose will print progress updates.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.spotdiag","page":"Visualization","title":"OpticSim.Vis.spotdiag","text":"spotdiag(sys::CSGOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; size = (500, 500), kwargs...)\n\nPlot a spot diagram for an arbitrary CSGOpticalSystem and OpticalRayGenerator. All rays from raygenerator will be traced through sys and their intersection location on the detector plotted.\n\nAlso spotdiag! of the same arguments to add to an existing plot.\n\n\n\n\n\nspotdiag(sys::AxisymmetricOpticalSystem{T}; size = (500, 500), hexapolar::Bool = true, collimated::Bool = true, samples::Int = 5, wavelength::T = 0.55, sourceangle::T = zero(T), sourcepos::SVector{3,T} = SVector{3,T}(0.0, 0.0, 10.0), kwargs...)\n\nPlot a spot diagram for an AxisymmetricOpticalSystem, rays are distributed across the entrance pupil of the system either in a hexapolar of rectangular grid pattern depending on hexapolar.\n\nThe input rays can be collimated, in which case the sourceangle parameter determines their direction. Otherwise rays are treated as coming from a point source at sourcepos.\n\nAlso spotdiag! of the same arguments to add to an existing plot.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.surfacesag","page":"Visualization","title":"OpticSim.Vis.surfacesag","text":"surfacesag(object::Union{CSGTree{T},Surface{T}}, resolution::Tuple{Int,Int}, halfsizes::Tuple{T,T}; offset::T = T(10), position::SVector{3,T} = SVector{3,T}(0.0, 0.0, 10.0), direction::SVector{3,T} = SVector{3,T}(0.0, 0.0, -1.0), rotationvec::SVector{3,T} = SVector{3,T}(0.0, 1.0, 0.0))\n\nCalculates and displays the surface sag of an arbitrary Surface or CSGTree.\n\nRays are shot in a grid of size defined by resolution across a arectangular area defined by halfsizes. This rectangle is centred at postion with normal along direction and rotation defined by rotationvec. offset is subtracted from the sag measurements to provide values relative to the appropriate zero level.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.eyebox_eval_eye","page":"Visualization","title":"OpticSim.Vis.eyebox_eval_eye","text":"eyebox_eval_eye(assembly::LensAssembly{T}, raygen::OpticalRayGenerator{T}, eye_rotation_x::T, eye_rotation_y::T, sample_points_x::Int, sample_points_y::Int; pupil_radius::T = T(2.0), resolution::Int = 512, eye_transform::RigidBodyTransform{T} = identitytransform(T))\n\nVisualise the images formed when tracing assembly with a human eye for an evenly sampled sample_points_x × sample_points_y grid in the angular range of eyeball rotations -eye_rotation_x:eye_rotation_x and -eye_rotation_y:eye_rotation_y in each dimension respectively. resolution is the size of the detector image (necessarily square).\n\nThe eye must be positioned appropriately relative to the system using eye_transform, this should transform the eye to the correct position and orientation when at 0 rotation in both dimensions. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nThe result is displayed as a 4D image - the image seen by the eye is shown in 2D as normal with sliders to vary eye rotation in x and y. The idea being that the whole image should be visible for all rotations in the range.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.eyebox_eval_planar","page":"Visualization","title":"OpticSim.Vis.eyebox_eval_planar","text":"eyebox_eval_planar(assembly::LensAssembly{T}, raygen::OpticalRayGenerator{T}, eyebox::Rectangle{T}, sample_points_x::Int, sample_points_y::Int, vsize::T; pupil_radius::T = T(2.0), resolution::Int = 512)\n\nVisualise the images formed when tracing assembly for multiple pupil positions within a planar eyebox. Any angles which are present in a circle radius pupil_radius around each sampling point on an even sample_points_x × sample_points_y grid on the eyebox are added to the sub-image at that grid point.\n\nA paraxial lens focal length 1mm is placed at the eyebox and a detector of size vsize × vsizemm placed 1mm behind it. The normal of the detector rectangle should point towards the system (and away from the fake detector). Any rays which miss the detector are ignored.\n\nThe pupil is always fully contained in the eyebox, i.e., the extreme sample position in u would be eyebox.halfsizeu - pupil_radius, for example.\n\nThe result is displayed as a 4D image - each sub-image is shown as normal with sliders to vary eye rotation in x and y. The idea being that the whole FoV should be visible for all rotations in the range.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Complete-Drawing-Functions","page":"Visualization","title":"Complete Drawing Functions","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"As mentioned above, Vis.draw! can be used to draw a large variety of objects, each with their own additional arguments. Here is a full list of the available drawing function and their associated options.","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"OpticSim.Vis.draw!","category":"page"},{"location":"vis/#OpticSim.Vis.draw!","page":"Visualization","title":"OpticSim.Vis.draw!","text":"draw!([scene = currentscene], ob; kwargs...)\n\nDraw an object in an existing scene. kwargs depends on the object type.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, surf::Surface{T}; numdivisions = 20, normals = false, normalcolor = :blue, kwargs...)\n\nTransforms surf into a mesh using makemesh and draws the result. normals of the surface can be drawn at evenly sampled points with provided normalcolor. numdivisions determines the resolution with which the mesh is triangulated. kwargs is passed on to the TriangleMesh drawing function.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, tmesh::TriangleMesh{T}; linewidth = 3, shaded = true, wireframe = false, color = :orange, normals = false, normalcolor = :blue, transparency = false, kwargs...)\n\nDraw a TriangleMesh, optionially with a visible wireframe. kwargs are passed on to Makie.mesh.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, meshes::Vararg{S}; colors::Bool = false, kwargs...) where {T<:Real,S<:Union{TriangleMesh{T},Surface{T}}}\n\nDraw a series of TriangleMesh or Surface objects, if colors is true then each mesh will be colored automatically with a diverse series of colors. kwargs are is passed on to the drawing function for each element.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, csg::Union{CSGTree,CSGGenerator}; numdivisions::Int = 20, kwargs...)\n\nConvert a CSG object (CSGTree or CSGGenerator) to a mesh using makemesh with resolution set by numdivisions and draw the resulting TriangleMesh.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, bbox::BoundingBox{T}; kwargs...)\n\nDraw a BoundingBox as a wireframe, ie series of lines.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, ass::LensAssembly; kwargs...)\n\nDraw each element in a LensAssembly, with each element automatically colored differently.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, sys::OpticalSystem; kwargs...)\n\nDraw each element in the lens assembly of an OpticalSystem, with each element automatically colored differently, as well as the detector of the system.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, origingenerator::RayOriginGenerator; kwargs...)\n\nDraw the surface representing origingenerator.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, raygen::OpticalRayGenerator, norays::Bool = false; kwargs...)\n\nDraw the surface representing raygen, as well as some sample OpticalRays eminating from it (providing norays is false).\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, raygen::GeometricRayGenerator, norays::Bool = false; kwargs...)\n\nDraw the surface representing raygen, as well as some sample Rays eminating from it (providing norays is false).\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, rays::AbstractVector{<:AbstractRay{T,N}}; kwargs...)\n\nDraw a vector of Ray or OpticalRay objects.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, traces::AbstractVector{LensTrace{T,N}}; kwargs...)\n\nDraw a vector of LensTrace objects.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, trace::LensTrace{T,N}; colorbysourcenum::Bool = false, colorbynhits::Bool = false, kwargs...)\n\nDraw a LensTrace as a line which can be colored automatically by its sourcenum or nhits attributes. The alpha is determined by the power attribute of trace.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, ray::OpticalRay{T,N}; colorbysourcenum::Bool = false, colorbynhits::Bool = false, kwargs...)\n\nDraw an OpticalRay which can be colored automatically by its sourcenum or nhits attributes. The alpha of the ray is determined by the power attribute of ray. kwargs are passed to draw!(scene, ray::Ray).\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, ray::Ray{T,N}; color = :yellow, rayscale = 1.0, kwargs...)\n\nDraw a Ray in a given color optionally scaling the size using rayscale. kwargs are passed to Makie.arrows.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, du::DisjointUnion{T}; kwargs...)\n\nDraw each Interval in a DisjointUnion.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, intervals::AbstractVector{Interval{T}}; kwargs...)\n\nDraw a vector of Intervals.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, interval::Interval{T}; kwargs...)\n\nDraw an Interval as a line with circles at each Intersection point.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, intersection::Intersection; normal::Bool = false, kwargs...)\n\nDraw an Intersection as a circle, optionally showing the surface normal at the point.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, lines::AbstractVector{Tuple{AbstractVector{T},AbstractVector{T}}}; kwargs...)\n\nDraw a vector of lines.\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, line::Tuple{AbstractVector{T},AbstractVector{T}}; color = :yellow, kwargs...)\n\nDraw a line between two points, kwargs are passed to Makie.linesegments.\n\n\n\n\n\ndraw!(s::MakieLayout.LScene, point::AbstractVector{T}; kwargs...)\n\nDraw a single point, kwargs are passed to draw!(scene, points::AbstractVector{AbstractVector{T}}).\n\n\n\n\n\ndraw!(scene::MakieLayout.LScene, points::AbstractVector{AbstractVector{T}}; markersize = 20, color = :black, kwargs...)\n\nDraw a vector of points. kwargs are passed to Makie.scatter.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Known-Issues","page":"Visualization","title":"Known Issues","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"If the Makie plot is printing to the console rather than showing properly in a separate window then call Vis.AbstractPlotting.__init__(). This will only occur when using a system image including the OpticSim package.","category":"page"},{"location":"interfaces/#Optical-Interfaces","page":"Interfaces","title":"Optical Interfaces","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"Every Surface must have an OpticalInterface associated with it to defined the behavior of any ray when it intersects that surface.","category":"page"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"OpticSim.OpticalInterface\nOpticSim.NullInterface\nFresnelInterface\nParaxialInterface\nThinGratingInterface\nHologramInterface\nMultiHologramInterface","category":"page"},{"location":"interfaces/#OpticSim.OpticalInterface","page":"Interfaces","title":"OpticSim.OpticalInterface","text":"OpticalInterface{T<:Real}\n\nAny subclass of OpticalInterface must implement the following:\n\nprocessintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nSee documentation for processintersection for details.\n\nThese methods are also commonly implemented, but not essential:\n\ninsidematerialid(i::OpticalInterface{T}) -> OpticSim.GlassCat.AbstractGlass\noutsidematerialid(i::OpticalInterface{T}) -> OpticSim.GlassCat.AbstractGlass\nreflectance(i::OpticalInterface{T}) -> T\ntransmission(i::OpticalInterface{T}) -> T\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.NullInterface","page":"Interfaces","title":"OpticSim.NullInterface","text":"NullInterface{T} <: OpticalInterface{T}\n\nInterface which will be ignored totally by any rays, used only in construction of CSG objects.\n\nNullInterface(T = Float64)\nNullInterface{T}()\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.FresnelInterface","page":"Interfaces","title":"OpticSim.FresnelInterface","text":"FresnelInterface{T} <: OpticalInterface{T}\n\nInterface between two materials with behavior defined according to the Fresnel equations, with a specified reflectance and transmission. Assumes unpolarized light.\n\nFresnelInterface{T}(insidematerial, outsidematerial; reflectance = 0, transmission = 1)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.ParaxialInterface","page":"Interfaces","title":"OpticSim.ParaxialInterface","text":"ParaxialInterface{T} <: OpticalInterface{T}\n\nInterface describing an idealized planar lens, i.e. one that is thin and with no aberrations.\n\nIn general this interface should not be constructed directly, the ParaxialLensEllipse and ParaxialLensRect functions should be used to create a ParaxialLens object directly.\n\nParaxialInterface(focallength::T, centroid::SVector{3,T}, outsidematerial::Y)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.ThinGratingInterface","page":"Interfaces","title":"OpticSim.ThinGratingInterface","text":"ThinGratingInterface{T} <: OpticalInterface{T}\n\nInterface representing an idealized thin grating. period is in microns, vector should lie in the plane of the surface. Transmission and reflectance can be specified for an arbitrary number of orders up to 10, selected using the maxorder and minorder parameters. If nothing then reflectance is assumed to be 0 and transmission is assumed to be 1.\n\nThinGratingInterface(vector, period, insidematerial, outsidematerial; maxorder = 1, minorder = -1, reflectance = nothing, transmission = nothing)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.HologramInterface","page":"Interfaces","title":"OpticSim.HologramInterface","text":"HologramInterface{T} <: OpticalInterface{T}\n\nInterface representing a thick hologram (though geometrically thin). The efficiency, η, is calculated using Kogelnik's coupled wave theory so is only valid for the first order. If the zero order is included then it has efficiency 1 - η. Also assumes that the HOE was recorded under similar conditions to the playback conditions, thickness is in microns.\n\nBeatState arguments can be one of ConvergingBeam, DivergingBeam and CollimatedBeam. In the first two cases signalpointordir and referencepointordir are 3D point in global coordinate space. For CollimatedBeam they are normalized direction vectors.\n\nFor reference, see:\n\nCoupled Wave Theory for Thick Hologram Gratings - H Kogelnik, 1995\nSequential and non-sequential simulation of volume holographic gratings - M Kick et al, 2018\n\nHologramInterface(signalpointordir::SVector{3,T}, signalbeamstate::BeamState, referencepointordir::SVector{3,T}, referencebeamstate::BeamState, recordingλ::T, thickness::T, beforematerial, substratematerial, aftermaterial, signalrecordingmaterial, referencerecordingmaterial, RImodulation::T, include0order  = false)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.MultiHologramInterface","page":"Interfaces","title":"OpticSim.MultiHologramInterface","text":"MultiHologramInterface{T} <: OpticalInterface{T}\n\nInterface to represent multiple overlapped HologramInterfaces on a single surface. Each ray randomly selects an interface to use.\n\nMultiHologramInterface(interfaces::Vararg{HologramInterface{T}})\nMultiHologramInterface(interfaces::Vector{HologramInterface{T}})\n\n\n\n\n\n","category":"type"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"The critical behavior of each interface is defined in the processintersection function:","category":"page"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"OpticSim.processintersection","category":"page"},{"location":"interfaces/#OpticSim.processintersection","page":"Interfaces","title":"OpticSim.processintersection","text":"processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nProcesses an intersection of an OpticalRay with an OpticalInterface, distinct behaviors must be implemented for each subclass of OpticalInterface.\n\npoint is the 3D intersection point in global space, normal is the surface normal at the intersection point.\n\nIf test is true then the behavior of the ray should be deterministic. firstray indicates that this ray is the first segment of the trace and therefore the origin is not offset.\n\nThe values returned are the normalized direction of the ray after the intersection, the instantaneous power of the ray after the intersection and the optical path length of the ray up to the intersection.\n\nnothing is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration nothing should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return nothing.\n\n\n\n\n\n","category":"function"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"OpticSim.jl is still under active development. Here are things we are considering:","category":"page"},{"location":"roadmap/#User-Interface","page":"Roadmap","title":"User Interface","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Improvements to visualization tools\nBetter control of 3D/2D system views\nMore drawing options (e.g. wireframe)\nMore analysis tools e.g. grids of spot diagrams, OPD diagrams etc.\nInteractive editor, probably in a spreadsheet format or similar\nEasily usable optimization features","category":"page"},{"location":"roadmap/#Optimization","page":"Roadmap","title":"Optimization","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Performance improvements\nMore rigorous local optimization (better parameter limits)\nGlobal optimization/smart initialization\nBetter interface (particularly for merit function design)","category":"page"},{"location":"roadmap/#Raytracing","page":"Roadmap","title":"Raytracing","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Improvements to ray energy accuracy\nImprove HOE implementations\nFinish implementation of Bezier and BSpline surfaces (mostly done)","category":"page"},{"location":"roadmap/#Other","page":"Roadmap","title":"Other","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Properly support Julia 1.6 once released\nAdd automatic 'run on azure' options\nSome long standing bug fixes/improvements to implementations","category":"page"},{"location":"roadmap/#Long-Term","page":"Roadmap","title":"Long-Term","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Simulation of gradient index (GRIN) materials\nSimulation of meta-materials\nCSG file import/export\nSimulate physical effects of thermal variation (physical expansion)\nSupport polarization of rays and elements relying on this","category":"page"},{"location":"primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"All geometry is built up from a small(ish) number of primitives and a number of constructive solid geometry (CSG) operations (see CSG). Primitives are split into two types, Surfaces and ParametricSurfaces, the latter being a subset of the former. Surfaces are standalone surfaces which cannot be used in CSG operations, e.g. an aperture or rectangle. ParametricSurfaces are valid csg objects and can be composed into very complex structures.","category":"page"},{"location":"primitives/#Surfaces","page":"Primitives","title":"Surfaces","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A surface can be any surface in 3D space, it can be bounded and not create a half-space (i.e. not partition space into inside and outside).","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Surface","category":"page"},{"location":"primitives/#OpticSim.Surface","page":"Primitives","title":"OpticSim.Surface","text":"Surface{T<:Real}\n\nT is the number type used to represent the surface, e.g., Float64. Basic Surfaces are not valid CSG objects, they function only in a stand-alone capacity.\n\nMust implement the following:\n\nsurfaceintersection(surface::Surface{T}, ray::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\nnormal(surface::Surface{T}) -> SVector{3,T}\ninterface(surface::Surface{T}) -> OpticalInterface{T}\nmakemesh(surface::Surface{T}) -> TriangleMesh{T}\n\nIn a conventional ray tracer the surface intersection function would only return the first surface the ray intersects. Because our ray tracer does CSG operations the surface intersection function intersects the ray with all leaf surfaces which are part of the CSG tree. \n\nEach leaf surface returns one or more 1D intervals along the ray. These intervals contain the part of the ray which is inside the surface. The intervals computed at the leaves are propagated upward through the CSG tree and the CSG operations of union, intersection, and difference are applied to generate new intervals which are themselves propagated upward.\n\nThe result is a union of 1D intervals, which may be disjoint, a single interval, or empty. The union of intervals represents the parts of the ray which are inside the CSG object.\n\nInside is well defined for halfspaces such as cylinders and spheres which divide space into two parts, but not for Bezier or NURBS patches which generally do not enclose a volume.  For surfaces which are not halfspaces the notion of inside is defined locally by computing the angle between the incoming ray and the normal of the surface at the point of intersection. All surfaces must be defined so that the normal points to the outside of the surface. \n\nA negative dot product between the incoming ray and the normal indicates the ray is coming from the outside of the surface and heading toward the inside. A positive dot product indicates the ray is coming from the inside of the surface and heading toward the outside.\n\nIntervals are defined along the ray which is being intersected with the surface, so they are one dimensional. For example, assume we have a ray with origin o on the outside of a plane and an intersection with the plane at point int = o + td where t is a scalar and d is the unit direction of the ray. The inside interval will be (Intersection(t),Infinity). This interval begins at the intersection point on the plane and continues to positive infinity. The Intersection struct stores both the parametric value t and the 3D point of intersection to make various operations more efficient. But the interval operations only depend on the parametric value t.\n\nIf the origin o is on the inside of the plane then the inside interval will be (RayOrigin,Intersection(t)). Only the part of the ray from the ray origin to the intersection point is inside the plane. \n\nIt is the programmer's responsibility to return Interval results from surfaceintersection that maintain these properties.\n\nThe following must be impemented only if the surface is being used as a detector\n\nuv(surface::Surface{T}, p::SVector{3,T}) -> SVector{2,T}\nuvtopix(surface::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\nonsurface(surface::Surface{T}, p::SVector{3,T}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Basic-Shapes","page":"Primitives","title":"Basic Shapes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are the simple shapes with are provided already, they act only as standalone objects and cannot be used in CSG objects. Adding a new Surface is easy, the new structure must simply follow the interface defined above.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Ellipse\nCircle\nRectangle\nHexagon\nTriangle\nTriangleMesh","category":"page"},{"location":"primitives/#OpticSim.Ellipse","page":"Primitives","title":"OpticSim.Ellipse","text":"Ellipse{T} <: Surface{T}\n\nElliptical surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in OpticalSystems.\n\nEllipse(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a ellipse centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Circle","page":"Primitives","title":"OpticSim.Circle","text":"Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))\n\nShortcut method to create a circle. The minimal case returns a circle centred at the origin with normal = [0, 0, 1].\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.Rectangle","page":"Primitives","title":"OpticSim.Rectangle","text":"Rectangle{T} <: Surface{T}\n\nRectangular surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in OpticalSystems.\n\nRectangle(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Hexagon","page":"Primitives","title":"OpticSim.Hexagon","text":"Hexagon{T} <: Surface{T}\n\nHexagonal surface, not a valid CSG object. The rotation of the hexagon around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nHexagon(side_length::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Triangle","page":"Primitives","title":"OpticSim.Triangle","text":"Triangle{T} <: Surface{T}\n\nTriangular surface, not a valid CSG object. Primarily used as a component part of TriangleMesh or to enable intersection of AcceleratedParametricSurfaces. Can never be used directly as an optical surface as it doesn't have an OpticalInterface.\n\nTriangle(v1::SVector{3,T}, v2::SVector{3,T}, v3::SVector{3,T}, [uv1::SVector{2,T}, uv2::SVector{2,T}, uv3::SVector{2,T}])\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.TriangleMesh","page":"Primitives","title":"OpticSim.TriangleMesh","text":"TriangleMesh{T} <: Surface{T}\n\nAn array of Triangles forming a mesh. Used for visualization purposes only.\n\nTriangleMesh(tris::Vector{Triangle{T}})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Stops","page":"Primitives","title":"Stops","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A number of simple occlusive apertures are provided as constructing such objects using CSG can be inefficient and error-prone.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"InfiniteStop\nFiniteStop\nRectangularAperture\nCircularAperture\nAnnulus","category":"page"},{"location":"primitives/#OpticSim.InfiniteStop","page":"Primitives","title":"OpticSim.InfiniteStop","text":"InfiniteStop{T,P<:StopShape} <: Surface{T}\n\nStop surface with infinite extent (outside of the aperture). P refers to the shape of the aperture.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.FiniteStop","page":"Primitives","title":"OpticSim.FiniteStop","text":"FiniteStop{T,P<:StopShape,Q<:StopShape} <: Surface{T}\n\nStop surface with finite extent. P refers to the shape of the aperture and Q represents the shape of the bounds of the stop surface.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.RectangularAperture","page":"Primitives","title":"OpticSim.RectangularAperture","text":"RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a plane i.e. InfiniteStop{T,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\nRectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a rectangle i.e. FiniteStop{T,RectangularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.CircularAperture","page":"Primitives","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a plane i.e. InfiniteStop{T,CircularStopShape}.\n\n\n\n\n\nCircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a circular aperture in a rectangle i.e. FiniteStop{T,CircularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.Annulus","page":"Primitives","title":"OpticSim.Annulus","text":"Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a circle i.e. FiniteStop{T,CircularStopShape,CircularStopShape}.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Parametric-Surfaces","page":"Primitives","title":"Parametric Surfaces","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A parametric surface must partition space into two valid half-spaces, i.e. inside and outside. The surface must also be parameterized by two variables, nominally u and v. Typically these surfaces cannot be intersected with a ray analytically and so must be triangulated and an iterative solution found.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"ParametricSurface\nAcceleratedParametricSurface","category":"page"},{"location":"primitives/#OpticSim.ParametricSurface","page":"Primitives","title":"OpticSim.ParametricSurface","text":"ParametricSurface{T,N} <: Surface{T}\n\nT is the number type used to represent the surface, e.g., Float64. N is the dimension of the space the surface is embedded in. ParametricSurfaces are valid CSG objects, in some cases (where analytic intersection isn't possible) they must be wrapped in an AcceleratedParametricSurface for use.\n\nMust implement the following:\n\nuv(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> SVector{2,T}\nuvrange(surface::ParametricSurface{T,N}) -> Tuple{Tuple{T,T},Tuple{T,T}}\npoint(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\npartials(surface::ParametricSurface{T,N}, u::T, v::T) -> Tuple{SVector{N,T}, SVector{N,T}}\nnormal(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\ninside(surface::ParametricSurface{T,N}, p: :SVector{N,T}) -> Bool\nonsurface(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> Bool\nsurfaceintersection(surface::ParametricSurface{T,N}, AbstractRay::Ray{T,N}) -> Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}\ninterface(surface::ParametricSurface{T,N}) -> OpticalInterface{T}\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.AcceleratedParametricSurface","page":"Primitives","title":"OpticSim.AcceleratedParametricSurface","text":"AcceleratedParametricSurface{T,N,S} <: ParametricSurface{T,N}\n\nWrapper class for ParametricSurfaces where analytical intersection isn't feasible (e.g. ZernikeSurface, ChebyshevSurface). The surface is instead triangulated and an iterative (newton raphson) process carried out to determine precise ray intersection points. S is the type of the ParametricSurface being wrapped.\n\nAcceleratedParametricSurface(surf::ParametricSurface{T,N}, numsamples::Int = 17; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Parametric-Surface-Types","page":"Primitives","title":"Parametric Surface Types","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are the available types of parametric surfaces which are already implemented, all of which can be used in the creation of CSG objects. New ParametricSurfaces can be added with relative ease providing they follow the interface defined above.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Cylinder\nPlane\nSphere\nSphericalCap\nZernikeSurface\nBezierSurface\nBSplineSurface\nQTypeSurface\nChebyshevSurface\nGridSagSurface","category":"page"},{"location":"primitives/#OpticSim.Cylinder","page":"Primitives","title":"OpticSim.Cylinder","text":"Cylinder{T,N} <: ParametricSurface{T,N}\n\nCylinder of infinite height centered at the origin, oriented along the z-axis. visheight is used for visualization purposes only, note that this does not fully represent the surface.\n\nCylinder(radius::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Plane","page":"Primitives","title":"OpticSim.Plane","text":"Plane{T,N} <: ParametricSurface{T,N}\n\nInfinite planar surface where the positive normal side is outside the surface.\n\nBy default this will not create any geometry for visualization, the optional vishalfsizeu and vishalfsizev arguments can be used to draw the plane as a rectangle for visualization note that this does not fully represent the surface. In this case, the rotation of the rectangle around the normal to the plane is defined by visvec - surfacenormal×visvec is taken as the vector along the u axis.\n\nPlane(surfacenormal::SVector{N,T}, pointonplane::SVector{N,T}; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\nPlane(nx::T, ny::T, nz::T, x::T, y::T, z::T; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Sphere","page":"Primitives","title":"OpticSim.Sphere","text":"Sphere{T,N} <: ParametricSurface{T,N}\n\nSpherical surface centered at the origin.\n\nSphere(radius::T = 1.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.SphericalCap","page":"Primitives","title":"OpticSim.SphericalCap","text":"SphericalCap{T} <: ParametricSurface{T}\n\nSpherical cap surface, creates a half-space which is essentially the subtraction of a sphere from an infinite plane. Only the spherical cap itself is visualized, not the plane. The positive normal side is outside the surface.\n\nCan be used as a detector in OpticalSystems.\n\nSphericalCap(radius::T, ϕmax::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a spherical cap centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.ZernikeSurface","page":"Primitives","title":"OpticSim.ZernikeSurface","text":"ZernikeSurface{T,N,P,Q} <: ParametricSurface{T,N}\n\nSurface incorporating the Zernike polynomials - radius, conic and aspherics are defined relative to absolute semi-diameter, Zernike terms are normalized according to the normradius parameter. T is the datatype, N is the dimensionality, P is the number of Zernike terms and Q is the number of aspheric terms. Only even aspheric terms are supported.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nFor convenience the input zcoeff can be indexed using either OSA or Noll convention, indicated using the indexing argument as either ZernikeIndexingOSA or ZernikeIndexingNoll.\n\nZernikeSurface(semidiameter, radius = Inf, conic = 0, zcoeff = nothing, aspherics = nothing, normradius = semidiameter, indexing = ZernikeIndexingOSA)\n\nzcoeff and aspherics should be vectors containing tuples of the form (i, v) where i is either the index of the Zernike term for the corresponding indexing, or the polynomial power of the aspheric term (must be even) and v is the corresponding coefficient A_i or alpha_i respectively..\n\nThe sag is defined by the equation\n\nz(rphi) = fraccr^21 + sqrt1 - (1+k)c^2r^2 + sum_i^Qalpha_ir^2i + sum_i^PA_iZ_i(rho phi)\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Z_n is the nᵗʰ Zernike polynomial.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.BezierSurface","page":"Primitives","title":"OpticSim.BezierSurface","text":"BezierSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nBezier surface defined by grid of control points.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBezierSurface{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.BSplineSurface","page":"Primitives","title":"OpticSim.BSplineSurface","text":"BSplineSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nCurve order is the same in the u and v direction and fixed over all spans. u and v knot vectors are allowed to be different - may change this to make them both the same.\n\nControl points in the u direction correspond to columns, with the lowest value of u corresponding to row 1. Control points in the v direction correspond to rows, with the lowest value of v corresponding to col 1.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBSplineSurface{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\nBSplineSurface{P,S,N,M}(uknots::KnotVector{S}, vknots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.QTypeSurface","page":"Primitives","title":"OpticSim.QTypeSurface","text":"QTypeSurface{T,D,M,N} <: ParametricSurface{T,D}\n\nSurface incorporating the QType polynomials - radius and conic are defined relative to absolute semi-diameter, QType terms are normalized according to the normradius parameter. T is the datatype, D is the dimensionality, M and N are the maximum QType terms used.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nQTypeSurface(semidiameter; radius = Inf, conic = 0.0, αcoeffs = nothing, βcoeffs = nothing, normradius = semidiameter)\n\nαcoeffs and βcoeffs should be a vector of tuples of the form (m, n, v) where v is the value of the coefficient α_n^m or β_n^m respectively.\n\nThe sag is defined by the equation\n\nbeginaligned\nz(rphi) =  fraccr^21 + sqrt1 - (1+k)c^2r^2 + fracsqrt1 + kc^2r^2sqrt1-(1+k)c^2r^2 cdot \n              left rho^2(1-rho^2)sum_n=0^Nalpha_n^0 Q_n^0 (rho^2) + sum_m=1^Mrho^msum_n=0^N left alpha_n^mcosmphi +beta_n^msinmphirightQ_n^m(rho^2) right\nendaligned\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Q_n^m is the QType polynomial index m, n.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.ChebyshevSurface","page":"Primitives","title":"OpticSim.ChebyshevSurface","text":"ChebyshevSurface{T,N,P,Q} <: ParametricSurface{T,N}\n\nRectangular surface incorporating Chebyshev polynomials as well as radius and conic terms. T is the datatype, N is the dimensionality, P is the number of Chebyshev terms in u and Q is the number of Chebyshev terms in v.\n\nThe surface is centered at the origin and treated as being the cap of an infinite rectangular prism, thus creating a true half-space. Note that the surface is vertically offset so that the center (i.e., (u,v) == (0,0)) lies at 0 on the z-axis.\n\nChebyshevSurface(halfsizeu, halfsizev, chebycoeff; radius = Inf, conic = 0)\n\nchebycoeff is a vector containing tuples of the form (i, j, v) where v is the value of the coefficient c_ij.\n\nThe sag is defined by the equation\n\nz(uv) = fracc(u^2 + v^2)^21 + sqrt1 - (1+k)c^2(u^2 + v^2) + sum_i^Psum_j^Qc_ijT_i(u)T_j(v)\n\nwhere c = frac1textttradius, k = textttconic and T_n is the nᵗʰ Chebyshev polynomial of the first kind.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.GridSagSurface","page":"Primitives","title":"OpticSim.GridSagSurface","text":"GridSagSurface{T,N,S<:Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}},Nu,Nv} <: ParametricSurface{T,N}\n\nEither a Zernike (circular) or Chebyshev (rectangular) surface with grid sag height added to the base sag. The surface shape is determined by either a linear or a bicubic spline interpolation of the Nu×Nv grid of sag values, set by the interpolation argument taking either GridSagLinear or GridSagBicubic.\n\nEach entry in the grid is a vector of the form z fracpartial zpartial x fracpartial zpartial y fracpartial^2 zpartial x partial y. The first data item corresponds to the lower left corner of the surface, that is, the corner defined by the -u and -v limit. Each point that follows is read across the face of the surface from left to right moving upwards. If zero is given for the partials (and using bicubic interpolation) then the partials will be approximated using finite differences.\n\nThe sag grid can be decentered from the surface in uv space, if so the surface may become wild outside of the area over which the grid is defined. It is advised to clip the surface to the valid area using CSG operations in this case.\n\nA surface can also be generated from a .GRD file by passing in the filename as the first and only positional argument. In this case the surface will be rectangular with optional radius and conic.\n\nSee docs for ZernikeSurface and ChebyshevSurface for details of the base surface.\n\nGridSagSurface(basesurface::Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}}, sag_grid::AbstractArray{T,3}; interpolation = GridSagBicubic, decenteruv = (0, 0))\nGridSagSurface{T}(filename::String; radius = Inf, conic = 0, interpolation = GridSagBicubic)\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Functions","page":"Primitives","title":"Functions","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are some useful functions related to Surface objects.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"point(::ParametricSurface{T}, ::T, ::T) where {T<:Real}\nnormal\npartials(::ParametricSurface{T}, ::T, ::T) where {T<:Real}\nuvrange\nuv\nOpticSim.uvtopix\ninside(s::ParametricSurface{T,3}, x::T, y::T, z::T) where {T<:Real}\nonsurface(s::ParametricSurface{T,3}, x::T, y::T, z::T) where {T<:Real}\ninterface\nsurfaceintersection(surf::AcceleratedParametricSurface{S,N}, r::AbstractRay{S,N}) where {S,N}\nsamplesurface\ntriangulate\nmakemesh","category":"page"},{"location":"primitives/#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T<:Real","page":"Primitives","title":"OpticSim.point","text":"point(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\npoint(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the 3D point on surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.normal","page":"Primitives","title":"OpticSim.normal","text":"normal(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\nnormal(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the normal to surf at the given uv coordinate.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T<:Real","page":"Primitives","title":"OpticSim.partials","text":"partials(surf::ParametricSurface{T}, u::T, v::T) -> (SVector{3,T}, SVector{3,T})\npartials(surf::ParametricSurface{T}, uv::SVector{2,T}) -> (SVector{3,T}, SVector{3,T})\n\nReturns a tuple of the 3D partial derivatives of surf with respect to u and v at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.uvrange","page":"Primitives","title":"OpticSim.uvrange","text":"uvrange(s::ParametricSurface)\nuvrange(::Type{S}) where {S<:ParametricSurface}\n\nReturns a tuple of the form: ((umin, umax), (vmin, vmax)) specifying the limits of the parameterisation for this surface type. Also implemented for some Surfaces which are not ParametricSurfaces (e.g. Rectangle).\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.uv","page":"Primitives","title":"OpticSim.uv","text":"uv(surf::ParametricSurface{T}, p::SVector{3,T}) -> SVector{2,T}\nuv(surf::ParametricSurface{T}, x::T, y::T, z::T) -> SVector{2,T}\n\nReturns the uv coordinate on surf of a point, p, in 3D space. If onsurface(surf, p) is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.uvtopix","page":"Primitives","title":"OpticSim.uvtopix","text":"uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\n\nConverts a uvcoordinate on surf to an integer index to a pixel in an image of size imsize. Not implemented on all Surface objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an OpticalSystem.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T<:Real","page":"Primitives","title":"OpticSim.inside","text":"inside(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\ninside(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside surf.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T<:Real","page":"Primitives","title":"OpticSim.onsurface","text":"onsurface(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\nonsurface(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on surf.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.interface","page":"Primitives","title":"OpticSim.interface","text":"interface(surf::Surface{T}) -> OpticalInterface{T}\n\nReturn the OpticalInterface associated with surf.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{S}, Tuple{AcceleratedParametricSurface{S,N,S1} where S1<:ParametricSurface{S,N},AbstractRay{S,N}}} where N where S","page":"Primitives","title":"OpticSim.surfaceintersection","text":"surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}\n\nCalculates the intersection of r with a surface of any type, surf. Note that some surfaces cannot be intersected analytically so must be wrapped in an AcceleratedParametricSurface in order to be intersected.\n\nReturns an EmptyInterval if there is no Intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.samplesurface","page":"Primitives","title":"OpticSim.samplesurface","text":"samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)\n\nSample a parametric surface on an even numsamples×numsamples grid in UV space with provided function\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.triangulate","page":"Primitives","title":"OpticSim.triangulate","text":"triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)\n\nCreate an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.makemesh","page":"Primitives","title":"OpticSim.makemesh","text":"makemesh(object, subdivisions::Int = 30) -> TriangleMesh\n\nCreates a TriangleMesh from an object, either a ParametricSurface, CSGTree or certain surfaces (e.g. Circle, Rectangle). This is used for visualization purposes only.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Bounding-Boxes","page":"Primitives","title":"Bounding Boxes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Bounding boxes are mostly used internally for efficiency, but are also exposed to the user for visualization (and any other) purposes. All bounding boxes are axis aligned.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"BoundingBox\ndoesintersect\nsurfaceintersection(::BoundingBox{T}, ::AbstractRay{T,3}) where {T<:Real}","category":"page"},{"location":"primitives/#OpticSim.BoundingBox","page":"Primitives","title":"OpticSim.BoundingBox","text":"BoundingBox{T<:Real}\n\nAxis-aligned three-dimensional bounding box.\n\nBoundingBox(xmin::T, xmax::T, ymin::T, ymax::T, zmin::T, zmax::T)\nBoundingBox(s::Surface{T})\nBoundingBox(s::ParametricSurface{T,3}, transform::RigidBodyTransform{T} = identitytransform(T))\nBoundingBox(c::CSGTree{T})\nBoundingBox(tri::Triangle{T})\nBoundingBox(triangles::AbstractVector{Triangle{T}})\nBoundingBox(points::AbstractArray{SVector{3,T}})\nBoundingBox(la::LensAssembly{T})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.doesintersect","page":"Primitives","title":"OpticSim.doesintersect","text":"doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Bool\n\nTests whether r intersects an axis-aligned BoundingBox, bbox.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T<:Real","page":"Primitives","title":"OpticSim.surfaceintersection","text":"surfaceintersection(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\n\nCalculates the intersection of r with an axis-aligned BoundingBox, bbox.\n\nReturns an EmptyInterval if there is no intersection or an Interval if there is one or two intersections. Note that the uv of the returned intersection is always 0.\n\n\n\n\n\n","category":"method"},{"location":"emitters/#Emitters","page":"Emitters","title":"Emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters create rays in a certain pattern, usually controlled by some parameters. The are constructed in a modular way, e.g.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, StaticArrays # hide\nVis.draw(UniformOpticalSource(CollimatedSource(HexapolarOriginPoints(4, 1.0, 1.0, position = SVector(0.0, 0.0, 10.0), direction = SVector(0.0, sind(30), -cosd(30)))), 0.55))\nVis.save(\"assets/source1.png\") # hide\nnothing #hide","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"(Image: Emitter example 1 image)","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, StaticArrays # hide\nVis.draw(UniformOpticalSource(GridSource(OriginPoint{Float64}(1, position = SVector(0.0, 0.0, 10.0), direction = SVector(0.0, 0.0, -1.0)), 5, 5, π / 4, π / 4), 0.65))\nVis.save(\"assets/source2.png\") # hide\nnothing #hide","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"(Image: Emitter example 2 image)","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, StaticArrays # hide\nVis.draw(CosineOpticalSource(RandomSource(OriginPoint{Float64}(200, direction = SVector(0.0, 0.0, 1.0))), 1.0, 0.45))\nVis.save(\"assets/source3.png\") # hide\nnothing #hide","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"(Image: Emitter example 3 image)","category":"page"},{"location":"emitters/#Rays","page":"Emitters","title":"Rays","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Ray\nOpticalRay\nOpticSim.generateray","category":"page"},{"location":"emitters/#OpticSim.Ray","page":"Emitters","title":"OpticSim.Ray","text":"Ray{T,N} <: AbstractRay{T,N}\n\nPurely geometric ray, defined as origin + alpha * direction.\n\nRay(origin::SVector{N,T}, direction::SVector{N,T})\n\nHas the following accessor methods:\n\ndirection(ray::Ray{T,N}) -> SVector{N,T}\norigin(ray::Ray{T,N}) -> SVector{N,T}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.OpticalRay","page":"Emitters","title":"OpticSim.OpticalRay","text":"OpticalRay{T,N} <: AbstractRay{T,N}\n\nRay with power, wavelength and optical path length.\n\nNOTE: we use monte carlo integration to get accurate results on the detector, this means that all rays essentially hit the detector with power = 1 and some rays are thrown away at any interface to correctly match the reflection/transmission at that interface. For inspection purposes we also track the 'instantaneous' power of the ray in the power field of the OpticalRay.\n\nOpticalRay(ray::Ray{T,N}, power::T, wavelength::T, opl=zero(T))\nOpticalRay(origin::SVector{N,T}, direction::SVector{N,T}, power::T, wavelength::T, opl=zero(T))\n\nHas the following accessor methods:\n\nray(r::OpticalRay{T,N}) -> Ray{T,N}\ndirection(r::OpticalRay{T,N}) -> SVector{N,T}\norigin(r::OpticalRay{T,N}) -> SVector{N,T}\npower(r::OpticalRay{T,N}) -> T\nwavelength(r::OpticalRay{T,N}) -> T\npathlength(r::OpticalRay{T,N}) -> T\nsourcepower(r::OpticalRay{T,N}) -> T\nnhits(r::OpticalRay{T,N}) -> Int\nsourcenum(r::OpticalRay{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.generateray","page":"Emitters","title":"OpticSim.generateray","text":"generateray(o::GeometricRayGenerator{T}, n::Int) -> Ray{T,3}\n\nGenerate geometric rays distributed according to the type of the generator. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for GridSource, for example.\n\n\n\n\n\ngenerateray(o::OpticalRayGenerator{T}, n::Int) -> OpticalRay{T,3}\n\nGenerate optical rays distributed according to the type of the generator. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for generators using GridSource or GridRectOriginPoints, for example.\n\n\n\n\n\ngenerateray(a::PixelSource{T}, n::Int) -> OpticalRay{T,3}\n\nGenerates optical rays from all subpixels in the pixel. One ray is generated from each subpixel sequentially before looping back to the start.\n\n\n\n\n\ngenerateray(a::OpticalSourceArray{T}, n::Int) -> OpticalRay{T,3}\n\nGenerates optical rays from all generators in the array. One ray is generated from each element sequentially before looping back to the start of the array.\n\n\n\n\n\ngenerateray(a::BasicDisplayPanel{T}, n::Int) -> OpticalRay{T,3}\n\nGenerates optical rays from all pixels in the display. One ray is generated from each pixel sequentially before looping back to the start of the display.\n\n\n\n\n\ngenerateray(a::OpticalSourceGroup{T}, n::Int) -> OpticalRay{T,3}\n\nGenerate optical rays for each source in the group. All rays are generated for the first source, then all for the second source and so on as n increases.\n\n\n\n\n\n","category":"function"},{"location":"emitters/#Origin-Points","page":"Emitters","title":"Origin Points","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"OpticSim.RayOriginGenerator\nRandomRectOriginPoints\nGridRectOriginPoints\nRandomEllipseOriginPoints\nHexapolarOriginPoints\nOriginPoint\nOpticSim.genorigin","category":"page"},{"location":"emitters/#OpticSim.RayOriginGenerator","page":"Emitters","title":"OpticSim.RayOriginGenerator","text":"RayOriginGenerator{T<:Real}\n\nGenerates 3D points in world space which serve as origins for rays.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.RandomRectOriginPoints","page":"Emitters","title":"OpticSim.RandomRectOriginPoints","text":"RandomRectOriginPoints{T} <: RayOriginGenerator{T}\n\nGenerates ray origins randomly within a rectangle.\n\nRandomRectOriginPoints(numrays, halfsizeu, halfsizev; position = (0.0, 0.0, 0.0), direction = (0.0, 0.0, -1.0), rotationvec = (0.0, 1.0, 0.0))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.GridRectOriginPoints","page":"Emitters","title":"OpticSim.GridRectOriginPoints","text":"GridRectOriginPoints{T} <: RayOriginGenerator{T}\n\nGenerates ray origins on a rectangular grid.\n\nGridRectOriginPoints(numraysu, numraysv, halfsizeu, halfsizev; position = (0.0, 0.0, 0.0), direction = (0.0, 0.0, -1.0), rotationvec = (0.0, 1.0, 0.0))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.RandomEllipseOriginPoints","page":"Emitters","title":"OpticSim.RandomEllipseOriginPoints","text":"RandomEllipseOriginPoints{T} <: RayOriginGenerator{T}\n\nGenerates ray origins randomly across an ellipse.\n\nRandomEllipseOriginPoints(numrays, halfsizeu, halfsizev; position = (0.0, 0.0, 0.0), direction = (0.0, 0.0, -1.0), rotationvec = (0.0, 1.0, 0.0))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.HexapolarOriginPoints","page":"Emitters","title":"OpticSim.HexapolarOriginPoints","text":"HexapolarOriginPoints{T} <: RayOriginGenerator{T}\n\nGenerates ray origins in a hexapolar pattern.\n\nHexapolarOriginPoints(nrings::Int, halfsizeu::T, halfsizev::T; position = (0.0, 0.0, 0.0), direction = (0.0, 0.0, -1.0), rotationvec = (0.0, 1.0, 0.0))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.OriginPoint","page":"Emitters","title":"OpticSim.OriginPoint","text":"OriginPoint{T} <: RayOriginGenerator{T}\n\nSingle point origin for a source.\n\nOriginPoint{T}(numrays; position = (0.0, 0.0, 0.0), direction = (0.0, 0.0, -1.0), rotationvec = (0.0, 1.0, 0.0))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.genorigin","page":"Emitters","title":"OpticSim.genorigin","text":"genorigin(o::RayOriginGenerator{T}, n::Int) -> SVector{3,T}\n\nGenerate origin positions for rays based on the type of the generator, e.g., randomly within a rectangle or ellipse. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for HexapolarOriginPoints and GridRectOriginPoints.\n\n\n\n\n\n","category":"function"},{"location":"emitters/#Directions","page":"Emitters","title":"Directions","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"GeometricRayGenerator\nCollimatedSource\nGridSource\nRandomSource\nOpticSim.gendirection","category":"page"},{"location":"emitters/#OpticSim.GeometricRayGenerator","page":"Emitters","title":"OpticSim.GeometricRayGenerator","text":"GeometricRayGenerator{T,O<:RayOriginGenerator{T}} <: AbstractRayGenerator{T}\n\nGenerates geometric Rays according to the specific implementation of the subclass.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.CollimatedSource","page":"Emitters","title":"OpticSim.CollimatedSource","text":"CollimatedSource{T,O} <: GeometricRayGenerator{T,O}\n\nSource which generates collimated rays.\n\nCollimatedSource(generator::RayOriginGenerator)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.GridSource","page":"Emitters","title":"OpticSim.GridSource","text":"GridSource{T,O} <: GeometricRayGenerator{T,O}\n\nSource which generates rays in directions which fall on an even grid on a rectangle subtended by angles halfangleu, halfanglev.\n\nGridSource(generator::RayOriginGenerator, numraysu, numraysv, halfangleu, halfanglev)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.RandomSource","page":"Emitters","title":"OpticSim.RandomSource","text":"RandomSource{T,O} <: GeometricRayGenerator{T,O}\n\nSource which generates rays in directions sampled randomly from the solid angle ±θmax centred on the direction of the source.\n\nRandomSource(generator::RayOriginGenerator, numrays = 1, θmax = T(π / 2))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.gendirection","page":"Emitters","title":"OpticSim.gendirection","text":"gendirection(o::GeometricRayGenerator{T}, n::Int) -> SVector{3,T}\n\nGenerate directions for rays based on the type of the generator, e.g., randomly within a cone or collimated. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for GridSource.\n\n\n\n\n\n","category":"function"},{"location":"emitters/#Power","page":"Emitters","title":"Power","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"OpticalRayGenerator\nUniformOpticalSource\nCosineOpticalSource\nGaussianOpticalSource","category":"page"},{"location":"emitters/#OpticSim.OpticalRayGenerator","page":"Emitters","title":"OpticSim.OpticalRayGenerator","text":"OpticalRayGenerator{T} <: AbstractRayGenerator{T}\n\nGenerates OpticalRays according to the specific implementation of the subclass.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.UniformOpticalSource","page":"Emitters","title":"OpticSim.UniformOpticalSource","text":"UniformOpticalSource{T,O,P} <: OpticalRayGenerator{T}\n\nSource of OpticalRays with uniform power.\n\nUniformOpticalSource(generator::GeometricRayGenerator, centralwavelength, power = 1.0; sourcenum = 0)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.CosineOpticalSource","page":"Emitters","title":"OpticSim.CosineOpticalSource","text":"CosineOpticalSource{T,O,P} <: OpticalRayGenerator{T}\n\nSource of OpticalRays with power defined by: I(theta) approx I_0(costheta)^C Where theta is the angle of the ray to the central direction of the source, and C is the cosineexp parameter.\n\nCosineOpticalSource(generator::GeometricRayGenerator, cosineexp, centralwavelength, power = 1.0; sourcenum = 0)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.GaussianOpticalSource","page":"Emitters","title":"OpticSim.GaussianOpticalSource","text":"GaussianOpticalSource{T,O,P} <: OpticalRayGenerator{T}\n\nSource of OpticalRays with power defined by: I(theta) approx I_0e^-(G_ul^2 + G_vm^2) Where l and m are the direction cosines in the u and v directions to the central direction of the source, and G_u and G_v and the gaussianu and gaussianv parameters.\n\nGaussianOpticalSource(generator::GeometricRayGenerator, gaussianu, gaussianv, centralwavelength, power = 1.0; sourcenum = 0)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#Compound","page":"Emitters","title":"Compound","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"PixelSource\nOpticalSourceArray\nBasicDisplayPanel\nOpticalSourceGroup\nRayListSource","category":"page"},{"location":"emitters/#OpticSim.PixelSource","page":"Emitters","title":"OpticSim.PixelSource","text":"PixelSource{T,C} <: RayGenerator{T}\n\nRay generator which encapsulates a number of subpixels, rays are generated in each subpixel in an interleaved manner. The subpixels must be positioned correctly relative to each other when input to the constructor.\n\nAll subpixels must be coplanar, the orientation of the pixel and any display made using the pixel is taken from the first subpixel. All subpixels must have the same number of rays (if we make subpixels be handled sequentially we wouldn't need this). All subpixels must be of the same type.\n\nPixelSource(subpixels::Vector{OpticalRayGenerator}; colormap = nothing, position = (0, 0, 0))\nPixelSource(subpixels::Vararg{OpticalRayGenerator}; colormap = nothing, position = (0, 0, 0))\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.OpticalSourceArray","page":"Emitters","title":"OpticSim.OpticalSourceArray","text":"OpticalSourceArray{T} <: RayGenerator{T}\n\nGenerates rays from an array of the given source at the specified locations.\n\nOpticalSourceArray(generator::OpticalRayGenerator, positions::Vector{SVector{3,T}})\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.BasicDisplayPanel","page":"Emitters","title":"OpticSim.BasicDisplayPanel","text":"BasicDisplayPanel{T,C} <: RayGenerator{T}\n\nRay generator representing a simple panel display. The panel is flat and pixles are on a regular rectangular grid. Each pixel corresponds to one image pixel.\n\nBasicDisplayPanel(pixel::PixelSource, pitchx, pitchy, image, position = (0, 0, 0))\nBasicDisplayPanel(generator::OpticalSourceArray{T,PixelSource}, pixelvals::Vector{Union{T,Vector{T}}})\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.OpticalSourceGroup","page":"Emitters","title":"OpticSim.OpticalSourceGroup","text":"OpticalSourceGroup{T} <: RayGenerator{T}\n\nWrapper to group a number of separate optical sources into a single iterable object. If the sources of the same type then performance will be improved.\n\nOpticalSourceGroup(generators::Vector{<:OpticalRayGenerator})\nOpticalSourceGroup(generators::Vararg{OpticalRayGenerator})\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.RayListSource","page":"Emitters","title":"OpticSim.RayListSource","text":"RayListSource{T} <: OpticalRayGenerator{T}\n\nRay generator constructed manually from a list of rays which just outputs those rays in order.\n\nRayListSource(rays::Vararg{OpticalRay})\nRayListSource(rays::Vector{OpticalRay})\n\n\n\n\n\n","category":"type"},{"location":"emitters/#Fields","page":"Emitters","title":"Fields","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"HexapolarField\nGridField","category":"page"},{"location":"emitters/#OpticSim.HexapolarField","page":"Emitters","title":"OpticSim.HexapolarField","text":"HexapolarField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over the entrance pupil of the system in a hexapolar pattern.\n\n\n\n\n\nHexapolarField(semidiameter, pupilpos; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over a circular pupil with half-diameter defined by semidiameter, centred at pupilpos in a hexapolar pattern. samples is the number of rings in the hexapolar pattern, so the number of rays in total is samples * (samples + 1) / 2) * 6 + 1.\n\n\n\n\n\n","category":"function"},{"location":"emitters/#OpticSim.GridField","page":"Emitters","title":"OpticSim.GridField","text":"GridField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over the entrance pupil of the system in a rectangular grid pattern.\n\n\n\n\n\nGridField(semidiameter, pupilpos; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over a circular pupil with half-diameter defined by semidiameter, centred at pupilpos in a rectangular grid pattern. samples is the number of rays on each side of the grid, so there are samples×samples rays in total.\n\n\n\n\n\n","category":"function"},{"location":"csg/#CSG","page":"CSG","title":"CSG","text":"","category":"section"},{"location":"csg/#CSG-Operations","page":"CSG","title":"CSG Operations","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"There are three binary csg operations which can construct extremely complex objects from very simple primitives: union (cup), intersection (cap) and subtraction (i.e. difference).","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"This diagram shows the basic idea: (Image: CSG Tree visualization)","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"The code for this in our system would look this this:","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"using OpticSim # hide\ncyl = Cylinder(0.7)\ncyl_cross = csgunion(csgunion(leaf(cyl), leaf(cyl, rotationd(90, 0, 0))), leaf(cyl, rotationd(0, 90, 0)))\n\ncube = Cuboid(1.0, 1.0, 1.0)\nsph = Sphere(1.3)\nrounded_cube = csgintersection(cube, sph)\n\nresult = csgdifference(rounded_cube, cyl_cross)\nVis.draw(result, numdivisions=100)\n\nVis.save(\"assets/csg_ex.png\") # hide","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"(Image: CSG code example image)","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"leaf\ncsgunion\ncsgintersection\ncsgdifference","category":"page"},{"location":"csg/#OpticSim.leaf","page":"CSG","title":"OpticSim.leaf","text":"leaf(surf::ParametricSurface{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a leaf node from a parametric surface with a given transform.\n\n\n\n\n\nleaf(surf::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a (pseudo) leaf node from another CSGGenerator, this is useful if you want multiple copies of a premade CSG structure with different transforms, for example in an MLA.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.csgunion","page":"CSG","title":"OpticSim.csgunion","text":"csgunion(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a binary node in the CSG tree representing a union between a and b. A shortcut method for a and b as ParametricSurfaces is also available.\n\n(Image: Union Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.csgintersection","page":"CSG","title":"OpticSim.csgintersection","text":"csgintersection(a::CSGGenerator{T} b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a binary node in the CSG tree representing an intersection between a and b. A shortcut method for a and b as ParametricSurfaces is also available.\n\n(Image: Intersect Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.csgdifference","page":"CSG","title":"OpticSim.csgdifference","text":"csgdifference(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a binary node in the CSG tree representing the difference of a and b, essentially a - b. A shortcut method for a and b as ParametricSurfaces is also available.\n\n(Image: Difference Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Pre-made-CSG-Shapes","page":"CSG","title":"Pre-made CSG Shapes","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"There are also some shortcut methods available to create common CSG objects more easily:","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"BoundedCylinder\nCuboid\nHexagonalPrism\nRectangularPrism\nTriangularPrism\nSpider","category":"page"},{"location":"csg/#OpticSim.BoundedCylinder","page":"CSG","title":"OpticSim.BoundedCylinder","text":"BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cylinder with planar caps on both ends centred at (0, 0, 0) with axis (0, 0, 1).\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.Cuboid","page":"CSG","title":"OpticSim.Cuboid","text":"Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cuboid centred at (0, 0, 0).\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.HexagonalPrism","page":"CSG","title":"OpticSim.HexagonalPrism","text":"HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall hexagonal prism with axis (0, 0, 1), the longer hexagon diameter is along the x axis. For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.RectangularPrism","page":"CSG","title":"OpticSim.RectangularPrism","text":"RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall rectangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.TriangularPrism","page":"CSG","title":"OpticSim.TriangularPrism","text":"TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall triangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.Spider","page":"CSG","title":"OpticSim.Spider","text":"Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -> Vector{Rectangle{T}}\n\nCreates a 'spider' obscuration with narms rectangular arms evenly spaced around a circle defined by origin and normal. Each arm is a rectangle armwidth×radius.\n\ne.g. for 3 and 4 arms we get:\n\n   |         _|_\n  / \\         |\n\n\n\n\n\n","category":"function"},{"location":"csg/#Transforms","page":"CSG","title":"Transforms","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"Transforms are used to position does within the CSG tree.","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"RigidBodyTransform\nOpticSim.rotation\nOpticSim.rotationd\nOpticSim.translation\nOpticSim.rotmat\nOpticSim.rotmatd\nOpticSim.rotmatbetween","category":"page"},{"location":"csg/#OpticSim.RigidBodyTransform","page":"CSG","title":"OpticSim.RigidBodyTransform","text":"RigidBodyTransform{S<:Real}\n\nTransform encapsulating rotation and translation in 3D space. Translation happens after rotation.\n\nRigidBodyTransform{S}(θ::T, ϕ::T, ψ::T, x::T, y::T, z::T)\nRigidBodyTransform(rotation::SMatrix{3,3,S}, translation::SVector{3,S})\nRigidBodyTransform(rotation::AbstractArray{S,2}, translation::AbstractArray{S,1})\n\nθ, ϕ and ψ in first constructor are in radians.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.rotation","page":"CSG","title":"OpticSim.rotation","text":"rotation([S::Type], θ::T, ϕ::T, ψ::T) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.rotationd","page":"CSG","title":"OpticSim.rotationd","text":"rotationd([S::Type], θ::T, ϕ::T, ψ::T) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.translation","page":"CSG","title":"OpticSim.translation","text":"translation([S::Type], x::T, y::T, z::T) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the translation by x, y and z.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.rotmat","page":"CSG","title":"OpticSim.rotmat","text":"rotmat([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.rotmatd","page":"CSG","title":"OpticSim.rotmatd","text":"rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.rotmatbetween","page":"CSG","title":"OpticSim.rotmatbetween","text":"rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation between vetors a and b.\n\n\n\n\n\n","category":"function"},{"location":"csg/#CSG-Types","page":"CSG","title":"CSG Types","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"These are the types of the primary CSG elements, i.e. the nodes in the CSG tree.","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"OpticSim.CSGTree\nOpticSim.CSGGenerator\nOpticSim.ComplementNode\nOpticSim.UnionNode\nOpticSim.IntersectionNode\nOpticSim.LeafNode","category":"page"},{"location":"csg/#OpticSim.CSGTree","page":"CSG","title":"OpticSim.CSGTree","text":"Abstract type representing any evaluated CSG structure.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.CSGGenerator","page":"CSG","title":"OpticSim.CSGGenerator","text":"CSGGenerator{T<:Real}\n\nThis is the type you should use when making CSG objects. This type allows for the construction of CSGTree objects with different transforms. When the generator is evaluated, all transforms are propagated down to the LeafNodes and stored there.\n\nExample\n\na = Cylinder(1.0,1.0)\nb = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])\ngenerator = csgintersection(a,b)\n# now make a csg object that can be ray traced\ncsgobj = generator(RigidBodyTransform(1.0,1.0,2.0))\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.ComplementNode","page":"CSG","title":"OpticSim.ComplementNode","text":"ComplementNode{T,C<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated complement node within the CSG tree, must be the second child of a IntersectionNode forming a subtraction.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.UnionNode","page":"CSG","title":"OpticSim.UnionNode","text":"UnionNode{T,L<:CSGTree{T},R<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated union node within the CSG tree.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.IntersectionNode","page":"CSG","title":"OpticSim.IntersectionNode","text":"IntersectionNode{T,L<:CSGTree{T},R<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated intersection node within the CSG tree.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.LeafNode","page":"CSG","title":"OpticSim.LeafNode","text":"LeafNode{T,S<:ParametricSurface{T}} <: CSGTree{T}\n\nAn evaluated leaf node in the CSG tree, geometry attribute which contains a ParametricSurface of type S. The leaf node also has a transform associated which is the composition of all nodes above it in the tree. As such, transforming points from the geometry using this transform puts them in world space, and transforming rays by the inverse transform puts them in object space.\n\n\n\n\n\n","category":"type"},{"location":"csg/#Additional-Functions-and-Types","page":"CSG","title":"Additional Functions and Types","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"These are the internal types and functions used for geomertic/CSG operations.","category":"page"},{"location":"csg/#Functions","page":"CSG","title":"Functions","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"surfaceintersection(::CSGTree{T}, ::AbstractRay{T,N}) where {T<:Real,N}\ninside(a::CSGTree{T}, x::T, y::T, z::T) where {T<:Real}\nonsurface(a::CSGTree{T}, x::T, y::T, z::T) where {T<:Real}","category":"page"},{"location":"csg/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T},AbstractRay{T,N}}} where N where T<:Real","page":"CSG","title":"OpticSim.surfaceintersection","text":"surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})\n\nCalculates the intersection of r with CSG object, obj.\n\nReturns an EmptyInterval if there is no intersection, an Interval if there is one or two interesections and a DisjointUnion if there are more than two intersections.\n\nThe ray is intersected with the LeafNodes that make up the CSG object and the resulting Intervals and DisjointUnions are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in object space for that node before the intersection is carried out, typically this object space is centered at the origin, but may differ for each primitive.\n\nSome intersections are culled without actually evaluating them by first checking if the ray intersects the BoundingBox of each node in the CSGTree, this can substantially improve performance in some cases.\n\n\n\n\n\n","category":"method"},{"location":"csg/#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T},T,T,T}} where T<:Real","page":"CSG","title":"OpticSim.inside","text":"inside(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\ninside(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside obj.\n\n\n\n\n\n","category":"method"},{"location":"csg/#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T},T,T,T}} where T<:Real","page":"CSG","title":"OpticSim.onsurface","text":"onsurface(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\nonsurface(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on the surface (i.e. shell) of obj.\n\n\n\n\n\n","category":"method"},{"location":"csg/#Intervals","page":"CSG","title":"Intervals","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"Interval\nEmptyInterval\nDisjointUnion\nOpticSim.isemptyinterval\nOpticSim.ispositivehalfspace\nOpticSim.israyorigininterval\nOpticSim.halfspaceintersection\nOpticSim.closestintersection\nOpticSim.IntervalPool","category":"page"},{"location":"csg/#OpticSim.Interval","page":"CSG","title":"OpticSim.Interval","text":"Interval{T} <: AbstractRayInterval{T}\n\nDatatype representing an interval between two IntervalPoints on a ray.\n\nThe lower element can either be RayOrigin or an Intersection. The upper element can either be an Intersection or Infinity.\n\npositivehalfspace(int::Intersection) -> Interval with lower = int, upper = Infinity\nrayorigininterval(int::Intersection) -> Interval with lower = RayOrigin, upper = int\nInterval(low, high)\n\nHas the following accessor methods:\n\nlower(a::Interval{T}) -> Union{RayOrigin{T},Intersection{T,3}}\nupper(a::Interval{T}) -> Union{Intersection{T,3},Infinity{T}}\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.EmptyInterval","page":"CSG","title":"OpticSim.EmptyInterval","text":"EmptyInterval{T} <: AbstractRayInterval{T}\n\nAn interval with no Intersections which is also not infinite.\n\nEmptyInterval(T = Float64)\nEmptyInterval{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.DisjointUnion","page":"CSG","title":"OpticSim.DisjointUnion","text":"Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of Intervals can be input to the constructor and they will automatically be processed into a valid DisjointUnion (or a single Interval if appropriate).\n\nDisjointUnion(intervals::AbstractVector{Interval{R}})\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.isemptyinterval","page":"CSG","title":"OpticSim.isemptyinterval","text":"isemptyinterval(a) -> Bool\n\nReturns true if a is an EmptyInterval. In performance critical contexts use a isa EmptyInterval{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.ispositivehalfspace","page":"CSG","title":"OpticSim.ispositivehalfspace","text":"ispositivehalfspace(a) -> Bool\n\nReturns true if upper(a) is Infinity. In performance critical contexts check directly i.e. upper(a) isa Infinity{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.israyorigininterval","page":"CSG","title":"OpticSim.israyorigininterval","text":"israyorigininterval(a) -> Bool\n\nReturns true if lower(a) is RayOrigin. In performance critical contexts check directly i.e. lower(a) isa RayOrigin{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.halfspaceintersection","page":"CSG","title":"OpticSim.halfspaceintersection","text":"halfspaceintersection(a::Interval{T}) -> Intersection{T,3}\n\nReturns the Intersection from a half space Interval, throws an error if not a half space.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.closestintersection","page":"CSG","title":"OpticSim.closestintersection","text":"closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -> Union{Nothing,Intersection{T,3}}\n\nReturns the closest Intersection from an Interval or DisjointUnion. Ignores intersection with null interfaces if ignorenull is true. Will return nothing if there is no valid intersection.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.IntervalPool","page":"CSG","title":"OpticSim.IntervalPool","text":"To prevent allocations we have a manually managed pool of arrays of Intervals which are used to store values during execution. The memory is kept allocated and reused across runs of functions like trace.\n\nthreadedintervalpool is a global threadsafe pool which is accessed through the functions:\n\nnewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -> Vector{Interval{T}}\nindexednewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -> Tuple{Int,Vector{Interval{T}}}\nemptyintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid())\ngetfromintervalpool([::Type{T} = Float64], id::Int, tid::Int = Threads.threadid()) -> Vector{Interval{T}}\n\n\n\n\n\n","category":"type"},{"location":"csg/#Intersections","page":"CSG","title":"Intersections","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"OpticSim.IntervalPoint\nRayOrigin\nInfinity\nIntersection\nOpticSim.isinfinity\nOpticSim.israyorigin","category":"page"},{"location":"csg/#OpticSim.IntervalPoint","page":"CSG","title":"OpticSim.IntervalPoint","text":"Each Interval consists of two IntervalPoints, one of RayOrigin, Intersection or Infinity.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.RayOrigin","page":"CSG","title":"OpticSim.RayOrigin","text":"RayOrigin{T} <: IntervalPoint{T}\n\nPoint representing 0 within an Interval, i.e. the start of the ray.\n\nRayOrigin(T = Float64)\nRayOrigin{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.Infinity","page":"CSG","title":"OpticSim.Infinity","text":"Infinity{T} <: IntervalPoint{T}\n\nPoint representing ∞ within an Interval.\n\nInfinity(T = Float64)\nInfinity{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.Intersection","page":"CSG","title":"OpticSim.Intersection","text":"Intersection{T,N} <: IntervalPoint{T}\n\nRepresents the point at which an Ray hits a Surface. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the OpticalInterface hit.\n\nHas the following accessor methods:\n\npoint(a::Intersection{T,N}) -> SVector{N,T}\nnormal(a::Intersection{T,N}) -> SVector{N,T}\nuv(a::Intersection{T,N}) -> SVector{2,T}\nu(a::Intersection{T,N}) -> T\nv(a::Intersection{T,N}) -> T\nα(a::Intersection{T,N}) -> T\ninterface(a::Intersection{T,N}) -> OpticalInterface{T}\nflippednormal(a::Intersection{T,N}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.isinfinity","page":"CSG","title":"OpticSim.isinfinity","text":"isinfinity(a) -> Bool\n\nReturns true if a is Infinity. In performance critical contexts use a isa Infinity{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.israyorigin","page":"CSG","title":"OpticSim.israyorigin","text":"israyorigin(a) -> Bool\n\nReturns true if a is RayOrigin. In performance critical contexts use a isa RayOrigin{T}.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Cooke-Triplet","page":"Examples","title":"Cooke Triplet","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\n\nusing DataFrames\nsys = AxisymmetricOpticalSystem(\n    DataFrame(Surface = [:Object, 1, 2, 3, :Stop, 5, 6, :Image],\n              Radius = [Inf, 26.777, 66.604, -35.571, 35.571, 35.571, -26.777, Inf],\n              Thickness = [Inf, 4.0, 2.0, 4.0, 2.0, 4.0, 44.748, missing],\n              Material = [OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_SK16, OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_SF2, OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_SK16, OpticSim.GlassCat.Air, missing],\n              SemiDiameter = [Inf, 8.580, 7.513, 7.054, 6.033, 7.003, 7.506, 15.0]))\n@show sys\nf1 = HexapolarField(sys, collimated = true, samples = 4, sourcenum = 1)\nf2 = HexapolarField(sys, collimated = true, samples = 4, sourceangle = -10 / 180 * π, sourcenum = 2)\nVis.drawtracerays(sys, raygenerator = f1, test = true, trackallrays = true, colorbysourcenum = true, resolution = (1000, 700))\nVis.drawtracerays!(sys, raygenerator = f2, test = true, trackallrays = true, colorbysourcenum = true)\nVis.make2dy() # hide\nVis.save(\"assets/cooke.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Cooke triplet visualization)","category":"page"},{"location":"examples/#Zoom-Lens","page":"Examples","title":"Zoom Lens","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\n\nusing DataFrames\nfunction zoom_lens(pos = 1)\n    if pos == 0\n        stop = 2.89\n        zoom = 9.48\n        dist = 4.46970613\n    elseif pos == 1\n        stop = 3.99\n        zoom = 4.48\n        dist = 21.21\n    else\n        stop = 4.90\n        zoom = 2.00\n        dist = 43.81\n    end\n    return AxisymmetricOpticalSystem{Float64}(\n        DataFrame(Surface = [:Object, :Stop, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, :Image],\n                  Radius = [Inf64, Inf64, -1.6202203499676E+01, -4.8875855327468E+01, 1.5666614444619E+01, -4.2955326460481E+01, 1.0869565217391E+02, 2.3623907394283E+01, -1.6059097478722E+01, -4.2553191489362E+02, -3.5435861091425E+01, -1.4146272457208E+01, -2.5125628140704E+02, -2.2502250225023E+01, -1.0583130489999E+01, -4.4444444444444E+01, Inf64],\n                  Aspherics = [missing, missing, missing, missing, missing, [(4, 1.03860000000E-04), (6, 1.42090000000E-07), (8, -8.84950000000E-09), (10, 1.24770000000E-10), (12, -1.03670000000E-12), (14, 3.65560000000E-15)], missing, missing, [(4, 4.27210000000E-05), (6, 1.24840000000E-07), (8, 9.70790000000E-09), (10, -1.84440000000E-10), (12, 1.86440000000E-12), (14, -7.79750000000E-15)], [(4, 1.13390000000E-04), (6, 4.81650000000E-07), (8, 1.87780000000E-08), (10, -5.75710000000E-10), (12, 8.99940000000E-12), (14, -4.67680000000E-14)], missing, missing, missing, missing, missing, missing, missing],\n                  Thickness = [Inf64, 0.0, 5.18, 0.10, 4.40, 0.16, 1.0, 4.96, zoom, 4.04, 1.35, 1.0, 2.80, 3.0, 1.22, dist, missing],\n                  Material = [OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, OpticSim.GlassCat.OHARA.S_LAH66, OpticSim.GlassCat.Air, OpticSim.GlassCat.NIKON.LLF6, OpticSim.GlassCat.Air, OpticSim.GlassCat.OHARA.S_TIH6, OpticSim.GlassCat.OHARA.S_FSL5, OpticSim.GlassCat.Air, OpticSim.GlassCat.OHARA.S_FSL5, OpticSim.GlassCat.Air, OpticSim.GlassCat.OHARA.S_LAL8, OpticSim.GlassCat.OHARA.S_FSL5, OpticSim.GlassCat.Air, OpticSim.GlassCat.OHARA.S_LAH66, OpticSim.GlassCat.Air, missing],\n                  SemiDiameter = [Inf64, stop, 3.85433218451, 3.85433218451, 4.36304692871, 4.36304692871, 4.72505505439, 4.72505505439, 4.72505505439, 4.45240784026, 4.45240784026, 4.50974054117, 4.50974054117, 4.50974054117, 4.76271114409, 4.76271114409, 15.0]))\nend\n@show zoom_lens(0)\nVis.drawtracerays(zoom_lens(0), test = true, trackallrays = true, numdivisions = 50, resolution = (1200, 600))\nVis.make2dy() # hide\nVis.save(\"assets/zoom0.png\") # hide\nVis.drawtracerays(zoom_lens(1), test = true, trackallrays = true, numdivisions = 50, resolution = (1200, 600))\nVis.make2dy() # hide\nVis.save(\"assets/zoom1.png\") # hide\nVis.drawtracerays(zoom_lens(2), test = true, trackallrays = true, numdivisions = 50, resolution = (1200, 600))\nVis.make2dy() # hide\nVis.save(\"assets/zoom2.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Zoom position 1 visualization) (Image: Zoom position 2 visualization) (Image: Zoom position 3 visualization)","category":"page"},{"location":"examples/#Schmidt-Cassegrain-Telescope","page":"Examples","title":"Schmidt Cassegrain Telescope","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\nusing StaticArrays\n\n\n# glass entrance lens on telescope\ntopsurf = Plane(SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, 0.0), interface = FresnelInterface{Float64}(OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air), vishalfsizeu = 12.00075, vishalfsizev = 12.00075)\nbotsurf = AcceleratedParametricSurface(ZernikeSurface(12.00075, radius = -1.14659768e+4, aspherics = [(4, 3.68090959e-7), (6, 2.73643352e-11), (8, 3.20036892e-14)]), 17, interface = FresnelInterface{Float64}(OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air))\ncoverlens = csgintersection(leaf(Cylinder(12.00075, 1.4)), csgintersection(leaf(topsurf), leaf(botsurf, RigidBodyTransform(OpticSim.rotmatd(0, 180, 0), SVector(0.0, 0.0, -0.65)))))\n# big mirror with a hole in it\nbigmirror = ConicLens(OpticSim.GlassCat.SCHOTT.N_BK7, -72.65, -95.2773500000134, 0.077235, Inf, 0.0, 0.2, 12.18263, frontsurfacereflectance = 1.0)\nbigmirror = csgdifference(bigmirror, leaf(Cylinder(4.0, 0.3, interface = opaqueinterface()), translation(0.0, 0.0, -72.75)))\n# small mirror supported on a spider\nsmallmirror = SphericalLens(OpticSim.GlassCat.SCHOTT.N_BK7, -40.65, Inf, -49.6845, 1.13365, 4.3223859, backsurfacereflectance = 1.0)\nobscuration1 = Circle(4.5, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, -40.649), interface = opaqueinterface())\nobscurations2 = Spider(3, 0.5, 12.0, SVector(0.0, 0.0, -40.65))\n# put it together with the detector\nla = LensAssembly(coverlens(), bigmirror(), smallmirror(), obscuration1, obscurations2...)\ndet = Circle(3.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, -92.4542988), interface = opaqueinterface())\ntele = CSGOpticalSystem(la, det)\n\nVis.drawtracerays(tele, raygenerator = UniformOpticalSource(CollimatedSource(GridRectOriginPoints(5, 5, 10.0, 10.0, position = SVector(0.0, 0.0, 20.0))), 0.55), trackallrays = true, colorbynhits = true, test = true)\nVis.save(\"assets/tele.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Schmidt Cassegrain Telescope visualization)","category":"page"},{"location":"examples/#Lens-Construction","page":"Examples","title":"Lens Construction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\nusing StaticArrays\n\ntopsurface = leaf(AcceleratedParametricSurface(QTypeSurface(9.0, radius = -25.0, conic = 0.3, αcoeffs = [(1, 0, 0.3), (1, 1, 1.0)], βcoeffs = [(1, 0, -0.1), (2, 0, 0.4), (3, 0, -0.6)], normradius = 9.5), interface = FresnelInterface{Float64}(OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air)), translation(0.0, 0.0, 5.0))\nbotsurface = leaf(Plane(0.0, 0.0, -1.0, 0.0, 0.0, -5.0, vishalfsizeu = 9.5, vishalfsizev = 9.5, interface = FresnelInterface{Float64}(OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air)))\nbarrel = leaf(Cylinder(9.0, 20.0, interface = FresnelInterface{Float64}(OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air, reflectance = zero(Float64), transmission = zero(Float64))))\nlens = csgintersection(barrel, csgintersection(topsurface, botsurface))(RigidBodyTransform{Float64}(0.0, Float64(π), 0.0, 0.0, 0.0, -5.0))\nsys = CSGOpticalSystem(LensAssembly(lens), Rectangle(15.0, 15.0, [0.0, 0.0, 1.0], [0.0, 0.0, -67.8], interface = opaqueinterface()))\nVis.drawtracerays(sys, test = true, trackallrays = true)\nVis.save(\"assets/qtype.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: lens construction example)","category":"page"},{"location":"examples/#HOEs","page":"Examples","title":"HOEs","text":"","category":"section"},{"location":"examples/#Focusing","page":"Examples","title":"Focusing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\nusing StaticArrays\n\nrect = Rectangle(5.0, 5.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, 0.0))\nint = HologramInterface(SVector(0.0, -3.0, -20.0), ConvergingBeam, SVector(0.0, 0.0, -1.0), CollimatedBeam, 0.55, 9.0, OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, 0.05, false)\nobj = HologramSurface(rect, int)\nsys = CSGOpticalSystem(LensAssembly(obj), Rectangle(10.0, 10.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, -25.0), interface = opaqueinterface()))\nVis.drawtracerays(sys; raygenerator = UniformOpticalSource(CollimatedSource(GridRectOriginPoints(5, 5, 3.0, 3.0, position = SVector(0.0, 0.0, 10.0), direction = SVector(0.0, 0.0, -1.0))), 0.55), trackallrays = true, rayfilter = nothing, test = true)\nVis.save(\"assets/hoe_f.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Focusing HOE example)","category":"page"},{"location":"examples/#Collimating","page":"Examples","title":"Collimating","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\nusing StaticArrays\n\nrect = Rectangle(5.0, 5.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, 0.0))\nint = HologramInterface(SVector(0.1, -0.05, -1.0), CollimatedBeam, SVector(0.0, 0.0, 10), DivergingBeam, 0.55, 9.0, OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, 0.05, false)\nobj = HologramSurface(rect, int)\nsys = CSGOpticalSystem(LensAssembly(obj), Rectangle(10.0, 10.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, -25.0), interface = opaqueinterface()))\nVis.drawtracerays(sys; raygenerator = UniformOpticalSource(GridSource(OriginPoint{Float64}(1, position = SVector(0.0, 0.0, 10.0), direction = SVector(0.0, 0.0, -1.0)), 5, 5, π / 4, π / 4), 0.55), trackallrays = true, rayfilter = nothing, test = true)\nVis.save(\"assets/hoe_c.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Collimating HOE example)","category":"page"},{"location":"examples/#Multi","page":"Examples","title":"Multi","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim\nusing StaticArrays\n\nrect = Rectangle(5.0, 5.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, 0.0))\nint1 = HologramInterface(SVector(-5.0, 0.0, -20.0), ConvergingBeam, SVector(0.0, -1.0, -1.0), CollimatedBeam, 0.55, 100.0, OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, 0.05, false)\nint2 = HologramInterface(SVector(5.0, 0.0, -20.0), ConvergingBeam, SVector(0.0, 1.0, -1.0), CollimatedBeam, 0.55, 100.0, OpticSim.GlassCat.Air, OpticSim.GlassCat.SCHOTT.N_BK7, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, OpticSim.GlassCat.Air, 0.05, false)\nmint = MultiHologramInterface(int1, int2)\nobj = MultiHologramSurface(rect, mint)\nsys = CSGOpticalSystem(LensAssembly(obj), Rectangle(10.0, 10.0, SVector(0.0, 0.0, 1.0), SVector(0.0, 0.0, -20.0), interface = opaqueinterface()))\ns1 = UniformOpticalSource(CollimatedSource(RandomRectOriginPoints(500, 3.0, 3.0, position = SVector(0.0, 3.0, 3.0), direction = SVector(0.0, -1.0, -1.0))), 0.55, sourcenum = 1)\ns2 = UniformOpticalSource(CollimatedSource(RandomRectOriginPoints(500, 3.0, 3.0, position = SVector(0.0, -3.0, 3.0), direction = SVector(0.0, 1.0, -1.0))), 0.55, sourcenum = 2)\ns3 = UniformOpticalSource(CollimatedSource(RandomRectOriginPoints(500, 3.0, 3.0, position = SVector(0.0, 0.0, 3.0), direction = SVector(0.0, 0.0, -1.0))), 0.55, sourcenum = 3)\nVis.drawtracerays(sys; raygenerator = s1, trackallrays = true, colorbysourcenum = true, rayfilter = nothing)\nVis.drawtracerays!(sys; raygenerator = s2, trackallrays = true, colorbysourcenum = true, rayfilter = nothing, drawgen = true)\nVis.drawtracerays!(sys; raygenerator = s3, trackallrays = true, colorbysourcenum = true, rayfilter = nothing, drawgen = true)\nVis.save(\"assets/hoe_m.png\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Multi-HOE example)","category":"page"},{"location":"ref/#Complete-Reference","page":"Reference","title":"Complete Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"This page contains what should be a complete list of all docstrings in the OpticSim module, and its submodule.","category":"page"},{"location":"ref/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Pages   = [\"ref.md\"]","category":"page"},{"location":"ref/#OpticSim","page":"Reference","title":"OpticSim","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim]","category":"page"},{"location":"ref/#OpticSim.AbstractRayDirectionDistribution","page":"Reference","title":"OpticSim.AbstractRayDirectionDistribution","text":"Every ray direction distribution must implement the functions direction(a::Source)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.AbstractSpectrum","page":"Reference","title":"OpticSim.AbstractSpectrum","text":"Each AbstractSpectrum type defines a spectrumSample function which returns a uniformly sampled point from the spectrum of the light source and the power at that wavelength.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BSplineCurve","page":"Reference","title":"OpticSim.BSplineCurve","text":"BSplineCurve{P,S,N,M} <: Spline{P,S,N,M}\n\nN is the spatial dimension of the curve. M is the curve order, i.e., the highest power of the parameterizing variable, u. All curve segments are assumed to be of the same order.\n\nBSplineCurve{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{MVector{N,S},1})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BeamState","page":"Reference","title":"OpticSim.BeamState","text":"ConvergingBeam, DivergingBeam or CollimatedBeam, defines the behavior of a beam in a HologramInterface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BezierCurve","page":"Reference","title":"OpticSim.BezierCurve","text":"BezierCurve{P,S,N,M} <: Spline{P,S,N,M}\n\nN is the dimension of the curve, M is the curve order\n\nBezierCurve{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},1})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CircularStopShape","page":"Reference","title":"OpticSim.CircularStopShape","text":"CircularStopShape <: StopShape\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CurveType","page":"Reference","title":"OpticSim.CurveType","text":"Either Rational or Euclidean, used for Splines and SplineSurfaces.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.GridSagInterpolation","page":"Reference","title":"OpticSim.GridSagInterpolation","text":"Either GridSagLinear or GridSagBicubic - determines the interpolation between sample points in the grid for a GridSagSurface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.KnotVector","page":"Reference","title":"OpticSim.KnotVector","text":"KnotVector{T<:Number}\n\nVector to define knots used for BSplineCurve and BSplineSurface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.MeasuredSpectrum","page":"Reference","title":"OpticSim.MeasuredSpectrum","text":"Use measured spectrum to compute emitter power. Create spectrum by reading CSV files.\n\nEvaluate spectrum at arbitrary wavelength with spectrumpower\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Primitive","page":"Reference","title":"OpticSim.Primitive","text":"Primitive{T<:Real}\n\nT is the number type used to represent the primitive,  e.g., Float64. Primitives are the basic elements which can be stored in bounding volume hierarchies and include surfaces and CSG objects\n\nMust implement the following:\n\nboundingbox(a::Primitive{T})::BoundingBox{T}\ncentroid(a::Primitive{T})::SVector{3,T}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.RayState","page":"Reference","title":"OpticSim.RayState","text":"stores the state of ray generation. Keeps track of ray number so you can have a PointOrigin which emits multiple rays. This can be used in the future to do phase summations on the image plane, since only point sources are perfectly spatially coherent.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.RectangularStopShape","page":"Reference","title":"OpticSim.RectangularStopShape","text":"RectangularStopShape <: StopShape\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Source","page":"Reference","title":"OpticSim.Source","text":"Create an emitter by choosing a type for the spectral distribution, ray origin distribution, ray direction distribution, and angular light power distribution. For example, to create an emitter with uniform spectrum, rays originating on a regular grid, ray directions distributed around a vector v up to a maximum angle θmax, with Lambertian power distribution call the Source construction with these types and arguments:\n\na = Source{UniformSpectrum,GridOrigin, ConeDistribution, Lambertian}(UniformSpectrum(),GridOrigin(),ConeDistribution(θmax),Lambertian())\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Spline","page":"Reference","title":"OpticSim.Spline","text":"Spline{P<:CurveType,S<:Number,N,M}\n\nM is the curve order, i.e., the highest power of the parameterizing variable, u. P determines the CurveType.\n\nAll Spline types must implement:\n\npoint(curve,u)\n\nand have field controlpolygon\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.SplineSurface","page":"Reference","title":"OpticSim.SplineSurface","text":"SplineSurface{P,S,N,M} <: ParametricSurface{S,N}\n\nCurve order, M, is the same in the u and v direction and fixed over all spans. P determines the CurveType.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.StopSurface","page":"Reference","title":"OpticSim.StopSurface","text":"StopSurface{T} <: Surface{T}\n\nAbstract type to encapsulate any surfaces acting as a stop.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.UniformSpectrum","page":"Reference","title":"OpticSim.UniformSpectrum","text":"flat spectrum from 450nm to 680nm\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ZernikeIndexType","page":"Reference","title":"OpticSim.ZernikeIndexType","text":"Either ZernikeIndexingOSA or ZernikeIndexingNoll, see Zernike polynomials wikipedia entry for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Annulus-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.Annulus","text":"Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a circle i.e. FiniteStop{T,CircularStopShape,CircularStopShape}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.ArizonaEye","text":"ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)\n\nThe popular Arizona eye model taken from this definition. The accommodation of the eye can be varied in this model. Returns a DataFrame specifying the prescription of the eye model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S}} where S<:Real where T<:OpticSim.GlassCat.AbstractGlass where Q<:OpticSim.GlassCat.AbstractGlass where R<:OpticSim.GlassCat.AbstractGlass","page":"Reference","title":"OpticSim.AsphericLens","text":"AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))\n\nCosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T,T}} where T<:Real","page":"Reference","title":"OpticSim.BoundedCylinder","text":"BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cylinder with planar caps on both ends centred at (0, 0, 0) with axis (0, 0, 1).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Circle-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.Circle","text":"Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))\n\nShortcut method to create a circle. The minimal case returns a circle centred at the origin with normal = [0, 0, 1].\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a plane i.e. InfiniteStop{T,CircularStopShape}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a circular aperture in a rectangle i.e. FiniteStop{T,CircularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S,S,S}} where S<:Real where T<:OpticSim.GlassCat.AbstractGlass where Q<:OpticSim.GlassCat.AbstractGlass where R<:OpticSim.GlassCat.AbstractGlass","page":"Reference","title":"OpticSim.ConicLens","text":"ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))\n\nConstructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T,T,T}} where T<:Real","page":"Reference","title":"OpticSim.Cuboid","text":"Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cuboid centred at (0, 0, 0).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G,T,T,T,T,T}} where H<:OpticSim.GlassCat.AbstractGlass where G<:OpticSim.GlassCat.AbstractGlass where T<:Real","page":"Reference","title":"OpticSim.FresnelLens","text":"FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = OpticSim.GlassCat.Air)\n\nCreate a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on groovedepth. For negative radii the vertex on the central surface is at frontvertex, so the total thickness of the lens is thickness + groovedepth. Aspherics currently not supported.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C<:(CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number)}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.GridField","text":"GridField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over the entrance pupil of the system in a rectangular grid pattern.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.GridField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.GridField","text":"GridField(semidiameter, pupilpos; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over a circular pupil with half-diameter defined by semidiameter, centred at pupilpos in a rectangular grid pattern. samples is the number of rays on each side of the grid, so there are samples×samples rays in total.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T,T}} where T<:Real","page":"Reference","title":"OpticSim.HexagonalPrism","text":"HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall hexagonal prism with axis (0, 0, 1), the longer hexagon diameter is along the x axis. For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C<:(CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number)}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.HexapolarField","text":"HexapolarField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over the entrance pupil of the system in a hexapolar pattern.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.HexapolarField","text":"HexapolarField(semidiameter, pupilpos; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over a circular pupil with half-diameter defined by semidiameter, centred at pupilpos in a hexapolar pattern. samples is the number of rings in the hexapolar pattern, so the number of rays in total is samples * (samples + 1) / 2) * 6 + 1.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where D<:Real where T<:Real","page":"Reference","title":"OpticSim.ModelEye","text":"ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::RigidBodyTransform{T} = identitytransform(T))\n\nGeometrically accurate model of the human eye focussed at infinity with variable pupil_radius. The eye is added to the provided assembly to create a CSGOpticalSystem with the retina of the eye as the detector.\n\nThe eye can be positioned in the scene using the transform argument and the resolution of the detector specified with detpixels. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nnsamples determines the resolution at which accelerated surfaces within the eye are triangulated.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.RectangularAperture","text":"RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a plane i.e. InfiniteStop{T,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.RectangularAperture","text":"RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a rectangle i.e. FiniteStop{T,RectangularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,T}} where T<:Real","page":"Reference","title":"OpticSim.RectangularPrism","text":"RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall rectangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S}} where S<:Real where T<:OpticSim.GlassCat.AbstractGlass where Q<:OpticSim.GlassCat.AbstractGlass where R<:OpticSim.GlassCat.AbstractGlass","page":"Reference","title":"OpticSim.SphericalLens","text":"SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))\n\nConstructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64,T,T}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3}}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Real","page":"Reference","title":"OpticSim.Spider","text":"Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -> Vector{Rectangle{T}}\n\nCreates a 'spider' obscuration with narms rectangular arms evenly spaced around a circle defined by origin and normal. Each arm is a rectangle armwidth×radius.\n\ne.g. for 3 and 4 arms we get:\n\n   |         _|_\n  / \\         |\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T,T}} where T<:Real","page":"Reference","title":"OpticSim.TriangularPrism","text":"TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall triangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.assembly","text":"assembly(system::OpticalSystem{T}) -> LensAssembly{T}\n\nGet the LensAssembly of system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.closestintersection","page":"Reference","title":"OpticSim.closestintersection","text":"closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -> Union{Nothing,Intersection{T,3}}\n\nReturns the closest Intersection from an Interval or DisjointUnion. Ignores intersection with null interfaces if ignorenull is true. Will return nothing if there is no valid intersection.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T","page":"Reference","title":"OpticSim.closestpointonray","text":"closestpointonray(r::Ray{T,N}, point::SVector{N,T}) -> SVector{T,N\n\nReturns the point on the ray closest to point.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.csgdifference-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T<:Real","page":"Reference","title":"OpticSim.csgdifference","text":"csgdifference(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a binary node in the CSG tree representing the difference of a and b, essentially a - b. A shortcut method for a and b as ParametricSurfaces is also available.\n\n(Image: Difference Image)\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.csgintersection-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T<:Real","page":"Reference","title":"OpticSim.csgintersection","text":"csgintersection(a::CSGGenerator{T} b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a binary node in the CSG tree representing an intersection between a and b. A shortcut method for a and b as ParametricSurfaces is also available.\n\n(Image: Intersect Image)\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.csgunion-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T<:Real","page":"Reference","title":"OpticSim.csgunion","text":"csgunion(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a binary node in the CSG tree representing a union between a and b. A shortcut method for a and b as ParametricSurfaces is also available.\n\n(Image: Union Image)\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.curvedimension-Tuple{Array}","page":"Reference","title":"OpticSim.curvedimension","text":"spatial dimension of curve represented as an array of coefficients x[i] = ∑Bj(θ)*x[i,j] where Bj(θ) is the curve basis\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.curveorder-Tuple{Array}","page":"Reference","title":"OpticSim.curveorder","text":"highest polynomial power of the curve represented as an array of coefficients x[i] = ∑Bj(θ)*x[i,j] where Bj(θ) is the curve basis\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.detectorimage-Tuple{CSGOpticalSystem}","page":"Reference","title":"OpticSim.detectorimage","text":"detectorimage(system::OpticalSystem{T}) -> HierarchicalImage{D}\n\nGet the detector image of system. D is the datatype of the detector image and is not necessarily the same as the datatype of the system T.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.direction-Union{Tuple{T}, Tuple{P}, Tuple{O}, Tuple{S}, Tuple{Source{T,S,O,ConeDistribution{T},P},Int64}} where T<:Real where P where O where S","page":"Reference","title":"OpticSim.direction","text":"Generates a unit vector pointing somewhere within the cone with half angle θmax around direction which is the normal to the emitter surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T","page":"Reference","title":"OpticSim.distance","text":"distance(r::Ray{T,N}, point::SVector{N,T}) -> Union{T,Nothing}\n\nReturns distance to the position on the ray closest to point. If t < 0 returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T<:Real","page":"Reference","title":"OpticSim.doesintersect","text":"doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Bool\n\nTests whether r intersects an axis-aligned BoundingBox, bbox.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Array{T,2},Real}} where T<:Real","page":"Reference","title":"OpticSim.evaluatecurve","text":"Evaluates a curve defined in the power basis. Curves and moving lines accessed like this: [xi,ci] where xi is the dimension index, and ci is the coefficient index.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.extractmovinglines-NTuple{4,Any}","page":"Reference","title":"OpticSim.extractmovinglines","text":"returns 3D array indexed like this: x[line curve order,spatial dimension, line number]`\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.fresnel-Union{Tuple{T}, NTuple{4,T}} where T<:Real","page":"Reference","title":"OpticSim.fresnel","text":"fresnel(nᵢ::T, nₜ::T, sinθᵢ::T, sinθₜ::T) -> Tuple{T,T}\n\nReturns reflectance and tranmission power coefficients according to the Fresnel equations. For geometric ray tracing this coefficient can be used directly to compute intensity on the detector plane. For Huygens phase optics need to take the square root to compute the amplitude. The power of the transmitted and refracted rays may not sum to one because of the area correction applied to the transmitted component. The intensity per area can increase or decrease depending on the indices of refraction.\n\nnᵢ is the RI of the material which the incident ray travels in, nₜ is the RI of the material the transmitted ray travels in. sinθᵢ and sinθₜ are the sin of the angles of incidence and transmission respectively.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.gendirection-Tuple{RandomSource,Int64}","page":"Reference","title":"OpticSim.gendirection","text":"gendirection(o::GeometricRayGenerator{T}, n::Int) -> SVector{3,T}\n\nGenerate directions for rays based on the type of the generator, e.g., randomly within a cone or collimated. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for GridSource.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.generateray-Union{Tuple{C}, Tuple{P}, Tuple{T}, Tuple{PixelSource{T,P,C},Int64}} where C where P where T<:Real","page":"Reference","title":"OpticSim.generateray","text":"generateray(a::PixelSource{T}, n::Int) -> OpticalRay{T,3}\n\nGenerates optical rays from all subpixels in the pixel. One ray is generated from each subpixel sequentially before looping back to the start.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.generateray-Union{Tuple{O}, Tuple{T}, Tuple{GeometricRayGenerator{T,O},Int64}} where O where T<:Real","page":"Reference","title":"OpticSim.generateray","text":"generateray(o::GeometricRayGenerator{T}, n::Int) -> Ray{T,3}\n\nGenerate geometric rays distributed according to the type of the generator. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for GridSource, for example.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{BasicDisplayPanel{T,P},Int64}} where P where T<:Real","page":"Reference","title":"OpticSim.generateray","text":"generateray(a::BasicDisplayPanel{T}, n::Int) -> OpticalRay{T,3}\n\nGenerates optical rays from all pixels in the display. One ray is generated from each pixel sequentially before looping back to the start of the display.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{UniformOpticalSource{T,P,P1} where P1<:GeometricRayGenerator{T,P},Int64}} where P where T<:Real","page":"Reference","title":"OpticSim.generateray","text":"generateray(o::OpticalRayGenerator{T}, n::Int) -> OpticalRay{T,3}\n\nGenerate optical rays distributed according to the type of the generator. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for generators using GridSource or GridRectOriginPoints, for example.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.generateray-Union{Tuple{S}, Tuple{T}, Tuple{OpticalSourceArray{T,S},Int64}} where S where T<:Real","page":"Reference","title":"OpticSim.generateray","text":"generateray(a::OpticalSourceArray{T}, n::Int) -> OpticalRay{T,3}\n\nGenerates optical rays from all generators in the array. One ray is generated from each element sequentially before looping back to the start of the array.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.generateray-Union{Tuple{T}, Tuple{OpticalSourceGroup{T},Int64}} where T<:Real","page":"Reference","title":"OpticSim.generateray","text":"generateray(a::OpticalSourceGroup{T}, n::Int) -> OpticalRay{T,3}\n\nGenerate optical rays for each source in the group. All rays are generated for the first source, then all for the second source and so on as n increases.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.genorigin-Tuple{OriginPoint,Int64}","page":"Reference","title":"OpticSim.genorigin","text":"genorigin(o::RayOriginGenerator{T}, n::Int) -> SVector{3,T}\n\nGenerate origin positions for rays based on the type of the generator, e.g., randomly within a rectangle or ellipse. n is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for HexapolarOriginPoints and GridRectOriginPoints.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.halfspaceintersection","text":"halfspaceintersection(a::Interval{T}) -> Intersection{T,3}\n\nReturns the Intersection from a half space Interval, throws an error if not a half space.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.identitytransform","text":"identitytransform([S::Type]) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T,N,S} where S<:ParametricSurface{T,N} where N}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.interface","text":"interface(surf::Surface{T}) -> OpticalInterface{T}\n\nReturn the OpticalInterface associated with surf.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,2}}} where N where T<:Real","page":"Reference","title":"OpticSim.intersections","text":"returns an array of intersection points. Each element in the array is ([x,y,...],alpha,theta) where [x,y,...] is the n-dimensional intersection point, alpha is the line parameter value at the intersection point, and theta is the curve parameter value at the intersection point\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.isemptyinterval-Tuple{EmptyInterval}","page":"Reference","title":"OpticSim.isemptyinterval","text":"isemptyinterval(a) -> Bool\n\nReturns true if a is an EmptyInterval. In performance critical contexts use a isa EmptyInterval{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.isinfinity-Tuple{Infinity}","page":"Reference","title":"OpticSim.isinfinity","text":"isinfinity(a) -> Bool\n\nReturns true if a is Infinity. In performance critical contexts use a isa Infinity{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.ispositivehalfspace","text":"ispositivehalfspace(a) -> Bool\n\nReturns true if upper(a) is Infinity. In performance critical contexts check directly i.e. upper(a) isa Infinity{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.israyorigin-Tuple{Any}","page":"Reference","title":"OpticSim.israyorigin","text":"israyorigin(a) -> Bool\n\nReturns true if a is RayOrigin. In performance critical contexts use a isa RayOrigin{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.israyorigininterval","text":"israyorigininterval(a) -> Bool\n\nReturns true if lower(a) is RayOrigin. In performance critical contexts check directly i.e. lower(a) isa RayOrigin{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},T,T,StaticArrays.SArray{Tuple{M},T,1,M},StaticArrays.SArray{Tuple{M},T,1,M}}} where M where N where T<:Real","page":"Reference","title":"OpticSim.jacobian","text":"jacobian(surf::ParametricSurface{T,N}, u::T, v::T, P1::SVector{M,T}, P2::SVector{M,T})\n\nComputes Jacobian of f(t,u,v) = ( dot(P1,[surf(u,v),1],P2,[surf(u,v),1]) ). P1, P2 are orthogonal planes that pass through the ray. J = [ ∂f1/∂u ∂f1/∂v ; ∂f2/∂u ∂f2/∂v]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.leaf-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T},RigidBodyTransform{T}}} where T<:Real","page":"Reference","title":"OpticSim.leaf","text":"leaf(surf::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a (pseudo) leaf node from another CSGGenerator, this is useful if you want multiple copies of a premade CSG structure with different transforms, for example in an MLA.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.leaf-Union{Tuple{S}, Tuple{T}, Tuple{S,RigidBodyTransform{T}}} where S<:(ParametricSurface{T,N} where N) where T<:Real","page":"Reference","title":"OpticSim.leaf","text":"leaf(surf::ParametricSurface{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a leaf node from a parametric surface with a given transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.linedimension-Tuple{Array}","page":"Reference","title":"OpticSim.linedimension","text":"spatial dimension of the moving line represented as an array of coefficients g[i] = ∑Bl(θ)*gl[i,j] where Bl(θ) is the polynomial basis\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.makemesh-Union{Tuple{ParametricSurface{S,N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S,N},Int64}} where N where S","page":"Reference","title":"OpticSim.makemesh","text":"makemesh(object, subdivisions::Int = 30) -> TriangleMesh\n\nCreates a TriangleMesh from an object, either a ParametricSurface, CSGTree or certain surfaces (e.g. Circle, Rectangle). This is used for visualization purposes only.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,3}}} where N where T","page":"Reference","title":"OpticSim.matricesforeigen","text":"movinglines[:,i] is the ith moving line. For li = movinglines[:,i] (dimension+1,lineorder) = size(li). rline[:,1] = pt1 and rline[:,2] = pt2. The line equation is pt1 + alpha*pt2.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},AbstractRay{T,N},StaticArrays.SArray{Tuple{2},T,1,2}}} where N where T","page":"Reference","title":"OpticSim.newton","text":"newton(surf::ParametricSurface{T,N}, r::AbstractRay{T,N}, startingpoint::SVector{2,T})\n\nNewton iteration to find the precise intersection of a parametric surface with a ray given a starting point (in uv space) on the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T<:Real","page":"Reference","title":"OpticSim.normal","text":"normal(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\nnormal(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the normal to surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.numberoflines-Tuple{Array}","page":"Reference","title":"OpticSim.numberoflines","text":"number of lines in moving line array\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Array{T,2},Any}} where T","page":"Reference","title":"OpticSim.orthogonalitymatrix","text":"returns a matrix expressing the relationship [x(θ) 1]⋅g(θ) = 0. The vectors in the right nullspace of this matrix contain the coefficients of the moving lines gᵢ(θ).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T,N},T}} where T<:Real where N","page":"Reference","title":"OpticSim.point","text":"point(ray::AbstractRay{T,N}, alpha::T) -> SVector{T, N}\n\nReturns a point on the ray at origin + alpha * direction. Alpha must be >= 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.pressure","text":"pressure(system::OpticalSystem{T}) -> T\n\nGet the pressure of system in Atm.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool,Bool}} where N where T<:Real","page":"Reference","title":"OpticSim.processintersection","text":"processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nProcesses an intersection of an OpticalRay with an OpticalInterface, distinct behaviors must be implemented for each subclass of OpticalInterface.\n\npoint is the 3D intersection point in global space, normal is the surface normal at the intersection point.\n\nIf test is true then the behavior of the ray should be deterministic. firstray indicates that this ray is the first segment of the trace and therefore the origin is not offset.\n\nThe values returned are the normalized direction of the ray after the intersection, the instantaneous power of the ray after the intersection and the optical path length of the ray up to the intersection.\n\nnothing is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration nothing should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.randinsolidangle-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},T}} where T<:Real","page":"Reference","title":"OpticSim.randinsolidangle","text":"randinsolidangle(direction::SVector{3,T}, uvec::SVector{3,T}, vvec::SVector{3,T}, θmax::T)\n\nGenerates a unit vector pointing somewhere within the cone with half angle θmax around direction. uvec and vvec should be orthogonal to each other and direction.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.raysample-Union{Tuple{P}, Tuple{D}, Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Source{T,S,O,D,P},OpticSim.RayState}} where P where D where O where S where T","page":"Reference","title":"OpticSim.raysample","text":"raysample is the function that can couple origin and direction generation if necessary. The default function couples them in a simple way but more complex coupling should be possible. For each origin numsamples(a.raydirection) direction samples are taken with identical origin. Then the origin number is incremented. This repeats till all rays have been generated. The origin and direction functions receive an integer indicating the origin or direction number so regular patterns such as rectangular and hexapolar grids can be generated properly.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T","page":"Reference","title":"OpticSim.reset!","text":"reset!(a::HierarchicalImage{T})\n\nResets the pixels in the image to zero(T). Do this rather than image .= zero(T) because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.resetdetector!","text":"resetdetector!(system::OpticalSystem{T})\n\nReset the deterctor image of system to zero.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.reversenormal-Union{Tuple{Intersection{T,N}}, Tuple{N}, Tuple{T}} where N where T<:Real","page":"Reference","title":"OpticSim.reversenormal","text":"reversenormal(a::Intersection{T,N})\n\nUsed by the CSG complement operator (i.e. csgdifference) to reverse the inside outside sense of the object.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.rotation-Union{Tuple{T}, Tuple{T,T,T}} where T<:Number","page":"Reference","title":"OpticSim.rotation","text":"rotation([S::Type], θ::T, ϕ::T, ψ::T) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.rotationd-Union{Tuple{T}, Tuple{T,T,T}} where T<:Number","page":"Reference","title":"OpticSim.rotationd","text":"rotationd([S::Type], θ::T, ϕ::T, ψ::T) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.rotmat-Union{Tuple{T}, Tuple{T,T,T}} where T<:Number","page":"Reference","title":"OpticSim.rotmat","text":"rotmat([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T<:Number","page":"Reference","title":"OpticSim.rotmatbetween","text":"rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation between vetors a and b.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.rotmatd-Union{Tuple{T}, Tuple{T,T,T}} where T<:Number","page":"Reference","title":"OpticSim.rotmatd","text":"rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Function}, Tuple{ParametricSurface{T,N},Function,Int64}} where N where T<:Real","page":"Reference","title":"OpticSim.samplesurface","text":"samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)\n\nSample a parametric surface on an even numsamples×numsamples grid in UV space with provided function\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}","page":"Reference","title":"OpticSim.semidiameter","text":"semidiameter(system::AxisymmetricOpticalSystem{T}) -> T\n\nGet the semidiameter of system, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S,S,T,T}} where S<:(AbstractArray{T,N} where N) where T<:Real","page":"Reference","title":"OpticSim.snell","text":"snell(surfacenormal::AbstractVector{T}, raydirection::AbstractVector{T}, nᵢ::T, nₜ::T) -> Tuple{T,T}\n\nnᵢ is the index of refraction on the incidence side of the interface. nₜ is the index of refraction on the transmission side.\n\nReturns sinθᵢ and sinθₜ according to Snell's law.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.spectrumpower-Union{Tuple{T}, Tuple{MeasuredSpectrum{T},T}} where T<:Real","page":"Reference","title":"OpticSim.spectrumpower","text":"expects wavelength in nm not um\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.spectrumsample-Union{Tuple{Source{T,UniformSpectrum{T},O,D,P}}, Tuple{T}, Tuple{P}, Tuple{D}, Tuple{O}} where T where P where D where O","page":"Reference","title":"OpticSim.spectrumsample","text":"returns a tuple (power,wavelength) \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T},HierarchicalImage{T}}} where T","page":"Reference","title":"OpticSim.sum!","text":"sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})\n\nAdd the contents of b to a in an efficient way.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S} where S<:ParametricSurface{T,N},AbstractRay{T,N}}} where N where T","page":"Reference","title":"OpticSim.surfaceintersection","text":"surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}\n\nCalculates the intersection of r with a surface of any type, surf. Note that some surfaces cannot be intersected analytically so must be wrapped in an AcceleratedParametricSurface in order to be intersected.\n\nReturns an EmptyInterval if there is no Intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.temperature","text":"temperature(system::OpticalSystem{T}) -> T\n\nGet the temperature of system in °C.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T},OpticalRay{T,N}}} where D<:Number where N where T<:Real","page":"Reference","title":"OpticSim.trace","text":"trace(system::OpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)\n\nTraces system with ray, if test is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a LensTrace if the ray hits the detector or nothing otherwise.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T},OpticalRay{T,N}}, Tuple{LensAssembly{T},OpticalRay{T,N},T}, Tuple{LensAssembly{T},OpticalRay{T,N},T,T}} where N where T<:Real","page":"Reference","title":"OpticSim.trace","text":"trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)\n\nReturns the ray as it exits the assembly in the form of a LensTrace object if it hits any element in the assembly, otherwise nothing. Recursive rays are offset by a small amount (RAY_OFFSET) to prevent it from immediately reintersecting the same lens element.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the assembly.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number,OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.trace","text":"trace(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the detector image of the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T,S,S1,L} where L<:LensAssembly{T} where S1<:Surface{T},OpticalRayGenerator{T}}} where S<:Number where T<:Real","page":"Reference","title":"OpticSim.traceMT","text":"traceMT(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the accumulated detector image from all threads.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number,OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.tracehits","text":"tracehits(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L<:LensAssembly{T} where S<:Surface{T} where D<:Number,OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.tracehitsMT","text":"tracehitsMT(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector, accumulated from all threads.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.translation-Union{Tuple{T}, Tuple{T,T,T}} where T<:Number","page":"Reference","title":"OpticSim.translation","text":"translation([S::Type], x::T, y::T, z::T) -> RigidBodyTransform{S}\n\nReturns the RigidBodyTransform of type S (default Float64) representing the translation by x, y and z.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Int64}, Tuple{ParametricSurface{T,N},Int64,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool,Bool}} where N where T","page":"Reference","title":"OpticSim.triangulate","text":"triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)\n\nCreate an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S},AbstractRay{T,N}}} where S where N where T<:Real","page":"Reference","title":"OpticSim.triangulatedintersection","text":"triangulatedintersection(surf::AcceleratedParametricSurface{T,N,S}, r::AbstractRay{T,N})\n\nIntersection of a ray, r, with a triangulated surface, surf, no concept of inside so never returns a RayOrigin Interval.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T<:Real","page":"Reference","title":"OpticSim.uv","text":"uv(surf::ParametricSurface{T}, p::SVector{3,T}) -> SVector{2,T}\nuv(surf::ParametricSurface{T}, x::T, y::T, z::T) -> SVector{2,T}\n\nReturns the uv coordinate on surf of a point, p, in 3D space. If onsurface(surf, p) is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uvrange-Tuple{S} where S<:ParametricSurface","page":"Reference","title":"OpticSim.uvrange","text":"uvrange(s::ParametricSurface)\nuvrange(::Type{S}) where {S<:ParametricSurface}\n\nReturns a tuple of the form: ((umin, umax), (vmin, vmax)) specifying the limits of the parameterisation for this surface type. Also implemented for some Surfaces which are not ParametricSurfaces (e.g. Rectangle).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T},StaticArrays.SArray{Tuple{2},T,1,2},Tuple{Int64,Int64}}} where T<:Real","page":"Reference","title":"OpticSim.uvtopix","text":"uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\n\nConverts a uvcoordinate on surf to an integer index to a pixel in an image of size imsize. Not implemented on all Surface objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an OpticalSystem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T<:Real","page":"Reference","title":"OpticSim.α","text":"α(ray::AbstractRay{T,N}, point::SVector{N,T}) -> T\n\nComputes the alpha corresponding to the closest position on the ray to point\n\n\n\n\n\n","category":"method"},{"location":"ref/#Zernike","page":"Reference","title":"Zernike","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Zernike]","category":"page"},{"location":"ref/#OpticSim.Zernike","page":"Reference","title":"OpticSim.Zernike","text":"Module to enclose Zernike polynomial specific functionality.\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.Zernike.NolltoNM-Tuple{Int64}","page":"Reference","title":"OpticSim.Zernike.NolltoNM","text":"NolltoNM(j::Int) -> Tuple{Int, Int}\n\nConvert Noll zernike index j to (N,M) form.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.OSAtoNM-Tuple{Int64}","page":"Reference","title":"OpticSim.Zernike.OSAtoNM","text":"OSAtoNM(j::Int) -> Tuple{Int, Int}\n\nConvert OSA zernike index j to (N,M) form according to formula J = N * (N + 2) + M.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64,Int64,T}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.R","text":"R(N::Int, M::Int, ρ::T) -> T\n\nEvaluate radial polynomial R_n^m(rho).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T},Int64,Int64}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.normalisation","text":"normalisation(::Type{T}, N::Int, M::Int) -> T\n\nNormalisation coefficient for Zernike polynomial term Z_n^m.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.δζ","text":"δζ(N::Int, M::Int, ρ::T, ϕ::T) -> Tuple{T,T}\n\nEvaluate partial derivatives of Zernike polynomial term Z_n^m(rho phi).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.ζ","text":"ζ(N::Int, M::Int, ρ::T, ϕ::T) -> Tuple{T,T}\n\nEvaluate Zernike polynomial term Z_n^m(rho phi).\n\n\n\n\n\n","category":"method"},{"location":"ref/#QType","page":"Reference","title":"QType","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.QType]","category":"page"},{"location":"ref/#OpticSim.QType","page":"Reference","title":"OpticSim.QType","text":"Module to enclose QType polynomial specific functionality. For reference see:\n\nRobust, efficient computational methods for axially symmetric optical aspheres - G. W. Forbes, 2010\nCharacterizing the shape of freeform optics - G. W. Forbes, 2012\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T<:Real","page":"Reference","title":"OpticSim.QType.S","text":"S(coeffs::SVector{NP1,T}, m::Int x::T) -> T\n\nEvaluates sum_n=0^Nc_n^mQ_n^m(x) where c_n^m is either an alpha or beta QType coefficient and m gt 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T<:Real","page":"Reference","title":"OpticSim.QType.S0","text":"S0(coeffs::SVector{NP1,T}, x::T) -> T\n\nEvaluates sum_n=0^Nalpha_n^0Q_n^0(x).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T<:Real","page":"Reference","title":"OpticSim.QType.dS0dx","text":"dS0dx(coeffs::SVector{NP1,T}, x::T) -> T\n\nEvaluates fracpartialpartial xsum_n=0^Nalpha_n^0Q_n^0(x).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T<:Real","page":"Reference","title":"OpticSim.QType.dSdx","text":"dSdx(coeffs::SVector{NP1,T}, x::T) -> T\n\nEvaluates fracpartialpartial xsum_n=0^Nc_n^mQ_n^m(x) where c_n^m is either an alpha or beta QType coefficient and m gt 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Chebyshev","page":"Reference","title":"Chebyshev","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Chebyshev]","category":"page"},{"location":"ref/#OpticSim.Chebyshev","page":"Reference","title":"OpticSim.Chebyshev","text":"Module to enclose Chebyshev polynomial specific functionality.\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R<:Real","page":"Reference","title":"OpticSim.Chebyshev.T","text":"T(n::Int, q::R, fast::Bool = true) -> R\n\nEvaluate Chebyshev polynomial of the first kind T_n(q).\n\nfast will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R<:Real","page":"Reference","title":"OpticSim.Chebyshev.U","text":"U(n::Int, q::R, fast::Bool = true) -> R\n\nEvaluate Chebyshev polynomial of the second kind U_n(q).\n\nfast will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R<:Real","page":"Reference","title":"OpticSim.Chebyshev.dTdq","text":"dTdq(n::Int, q::R, fast::Bool = true) -> R\n\nEvaluate derivative of Chebyshev polynomial of the first kind fracdT_ndq(q).\n\nfast will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Examples","page":"Reference","title":"Examples","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Examples]","category":"page"},{"location":"ref/#OpticSim.Examples","page":"Reference","title":"OpticSim.Examples","text":"Contains example usage of the features in the OpticSim.jl package.\n\n\n\n\n\n","category":"module"},{"location":"#OpticSim.jl","page":"Home","title":"OpticSim.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticSim.jl is a Julia package for geometric optics (ray tracing) simulation and optimization of complex optical systems developed by the Microsoft Research Interactive Media Group and the Microsoft Hardware Architecture Incubation Team (HART).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is designed to allow optical engineers to create optical systems procedurally and then to simulate and optimize them. Unlike Zemax, Code V, or other interactive optical design systems OpticSim.jl has limited support for interactivity, primarily in the tools for visualizing optical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A large variety of surface types are supported, and these can be composed into complex 3D objects through the use of constructive solid geometry (CSG). A complete catalog of optical materials is provided through the complementary GlassCat submodule.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This software provides extensive control over the modelling, simulation, visualization and optimization of optical systems. It is especially suited for designs that have a procedural architecture.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the Julia programming language from the official download page. OpticSim.jl is optimized for use with Julia 1.5.2-1.6.0; using other versions may result in reduced performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The system will automatically download glass catalog (.agf) files from some manufacturers when the package is built for the first time. These files are in an industry standard format and can be downloaded from many optical glass manufacturers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here are links to several publicly available glass files:","category":"page"},{"location":"","page":"Home","title":"Home","text":"NIKON (automatically downloaded)\nNHG (you have to manually download)\nOHARA (automatically downloaded)\nHOYA (automatically downloaded)\nSumita (automatically downloaded)\nSCHOTT (automatically downloaded)","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpticSim.jl will generate a glass database from the available files in deps/downloads/glasscat/ and store it in the file AGFClassCat.jl. See GlassCat for a detailed description, including instructions on how to add more catalogs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run this example to check that everything installed properly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OpticSim\nVis.draw(SphericalLens(OpticSim.GlassCat.SCHOTT.N_BK7, 0.0, 10.0, 10.0, 5.0, 5.0))\nVis.save(\"assets/test_install.png\") # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: install test image)","category":"page"},{"location":"#System-Image","page":"Home","title":"System Image","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are using Julia 1.5, we recommend compiling a custom Julia system image for the OpticSim.jl package to reduce startup time and improve first-time performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With VSCode, you can create a sysimage by opening the commant palette (CTRL-shift-P) and selecting Tasks: Run Build Task, julia: Build custom sysimage for current environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, we provide a Julia script that will build the sysimage using a representative workload. To do this, activate a Julia environment which has OpticSim installed and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"deps/sysimage.jl\")\ncompile()","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the sysimage is located in the current working directory. On Linux, it will be called JuliaSysimage.so; on Windows, the extension will be .dll. A custom path can be used instead which is passed as an argument to compile().","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the generated system image, run Julia with the --sysimage flag:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=[your_project] --sysimage=[path_to_sysimage]","category":"page"},{"location":"","page":"Home","title":"Home","text":"If OpticSim.jl is installed in the base project, then there is no need for the --project flag in the above command. If your current working directory is OpticSim.jl, then you can use the --project flag without needing to specify an argument.","category":"page"}]
}
