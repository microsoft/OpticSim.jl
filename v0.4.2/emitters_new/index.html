<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Emitters (NEW) · OpticSim.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">OpticSim.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../basic_types/">Basic Types</a></li><li><a class="tocitem" href="../primitives/">Primitives</a></li><li><a class="tocitem" href="../csg/">CSG</a></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li class="is-active"><a class="tocitem" href>Emitters (NEW)</a><ul class="internal"><li><a class="tocitem" href="#basic_emitters"><span>Examples of Basic Emitters</span></a></li><li><a class="tocitem" href="#spectrum"><span>Spectrum</span></a></li><li><a class="tocitem" href="#angular_power_distribution"><span>Angular Power Distribution</span></a></li><li><a class="tocitem" href="#rays_origins_distribution"><span>Rays Origins Distribution</span></a></li><li><a class="tocitem" href="#rays_directions_distribution"><span>Rays Directions Distribution</span></a></li><li><a class="tocitem" href="#sources"><span>Sources</span></a></li></ul></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li><a class="tocitem" href="../vis/">Visualization</a></li><li><a class="tocitem" href="../glasscat/">Glass Functions</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../cloud/">Cloud Execution</a></li><li><a class="tocitem" href="../notebooksutils/">Notebook utilities</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optical</a></li><li class="is-active"><a href>Emitters (NEW)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Emitters (NEW)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/microsoft/OpticSim.jl/blob/master/docs/src/emitters_new.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Emitters-(NEW)"><a class="docs-heading-anchor" href="#Emitters-(NEW)">Emitters (NEW)</a><a id="Emitters-(NEW)-1"></a><a class="docs-heading-anchor-permalink" href="#Emitters-(NEW)" title="Permalink"></a></h1><p>Emitters create rays in a certain pattern, usually controlled by some parameters. Emitters are defined by Pixels and Spatial Layouts, and have a spectrum and an optical power distribution over the hemisphere. These are intrinsic physical properties of the emitter.</p><p>The <strong>basic emitter</strong> (<a href="#sources"><code>Source</code></a>) is constructed as a combination of 4 basic elements and a 3D <a href="@ref"><code>Transform</code></a>. The basic elements include:</p><ul><li><a href="#spectrum"><code>Spectrum</code></a></li><li><a href="#angular_power_distribution"><code>Angular Power Distribution</code></a></li><li><a href="#rays_origins_distribution"><code>Rays Origins Distribution</code></a></li><li><a href="#rays_directions_distribution"><code>Rays Directions Distribution</code></a></li></ul><p>The <a href="index.html"><code>OpticSim</code></a> package comes with various implementations of each of these basic elements:</p><ul><li>Spectrum - the <strong>generate</strong> interface returns a tuple (power, wavelength)<ul><li><a href="#OpticSim.Emitters.Spectrum.Uniform"><code>Emitters.Spectrum.Uniform</code></a> - A flat spectrum bounded (default: from 450nm to 680nm). the range is sampled uniformly.</li><li><a href="#OpticSim.Emitters.Spectrum.DeltaFunction"><code>Emitters.Spectrum.DeltaFunction</code></a> - Constant wave length.</li><li><a href="#OpticSim.Emitters.Spectrum.Measured"><code>Emitters.Spectrum.Measured</code></a> - measured spectrum to compute emitter power and wavelength (created by reading CSV files – more details will follow).</li></ul></li><li>Angular Power Distribution - the interface <strong>apply</strong> returns an OpticalRay with modified power<ul><li><a href="#OpticSim.Emitters.AngularPower.Lambertian"><code>Emitters.AngularPower.Lambertian</code></a></li><li><a href="#OpticSim.Emitters.AngularPower.Cosine"><code>Emitters.AngularPower.Cosine</code></a></li><li><a href="#OpticSim.Emitters.AngularPower.Gaussian"><code>Emitters.AngularPower.Gaussian</code></a></li></ul></li><li>Rays Origins Distribution - the interface <strong>length</strong> returns the number of samples, and <strong>generate</strong> returns the n&#39;th sample.<ul><li><a href="#OpticSim.Emitters.Origins.Point"><code>Emitters.Origins.Point</code></a> - a single point</li><li><a href="#OpticSim.Emitters.Origins.RectUniform"><code>Emitters.Origins.RectUniform</code></a> - a uniformly sampled rectangle with user defined number of samples</li><li><a href="#OpticSim.Emitters.Origins.RectGrid"><code>Emitters.Origins.RectGrid</code></a> - a rectangle sampled in a grid fashion</li><li><a href="#OpticSim.Emitters.Origins.Hexapolar"><code>Emitters.Origins.Hexapolar</code></a> - a circle (or an ellipse) sampled in an hexapolar fashion (rings)</li></ul></li><li>Rays Directions Distribution - the interface <strong>length</strong> returns the number of samples, and <strong>generate</strong> returns the n&#39;th sample.<ul><li><a href="#OpticSim.Emitters.Directions.Constant"><code>Emitters.Directions.Constant</code></a></li><li><a href="#OpticSim.Emitters.Directions.RectGrid"><code>Emitters.Directions.RectGrid</code></a></li><li><a href="#OpticSim.Emitters.Directions.UniformCone"><code>Emitters.Directions.UniformCone</code></a></li><li><a href="#OpticSim.Emitters.Directions.HexapolarCone"><code>Emitters.Directions.HexapolarCone</code></a></li></ul></li></ul><h2 id="basic_emitters"><a class="docs-heading-anchor" href="#basic_emitters">Examples of Basic Emitters</a><a id="basic_emitters-1"></a><a class="docs-heading-anchor-permalink" href="#basic_emitters" title="Permalink"></a></h2><p><strong>Note</strong>: All of the examples on this page assume that the following statement was executed:</p><pre><code class="language-julia">using OpticSim, OpticSim.Geometry, OpticSim.Emitters</code></pre><h3 id="Point-origin-with-various-Direction-distributions"><a class="docs-heading-anchor" href="#Point-origin-with-various-Direction-distributions">Point origin with various Direction distributions</a><a id="Point-origin-with-various-Direction-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Point-origin-with-various-Direction-distributions" title="Permalink"></a></h3><pre><code class="language-julia">src = Sources.Source(origins=Origins.Point(), directions=Directions.RectGrid(π/4, π/4, 15, 15))
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_rect_grid.png">
    <img width="250" src="assets/emitters_example_rect_grid.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>RectGrid</b> Direction Distribution
</td>
</tr></table><pre><code class="language-julia">src = Sources.Source(origins=Origins.Point(), directions=Directions.UniformCone(π/6, 1000))
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_uniform_cone.png">
    <img width="250" src="assets/emitters_example_uniform_cone.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>UniformCone</b> Direction Distribution with 1000 sampled directions
</td>
</tr></table><pre><code class="language-julia">src = Sources.Source(origins=Origins.Point(), directions=Directions.HexapolarCone(π/6, 10))
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_hexapolar_cone.png">
    <img width="250" src="assets/emitters_example_hexapolar_cone.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>HexapolarCone</b> Direction Distribution
</td>
</tr></table><h3 id="Various-origins-distributions"><a class="docs-heading-anchor" href="#Various-origins-distributions">Various origins distributions</a><a id="Various-origins-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Various-origins-distributions" title="Permalink"></a></h3><pre><code class="language-julia">src = Sources.Source(origins=Origins.RectGrid(1.0, 1.0, 10, 10), directions=Directions.Constant())
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_origin_rectgrid.png">
    <img width="250" src="assets/emitters_example_origin_rectgrid.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>RectGrid</b> origin distribution
</td>
</tr></table><pre><code class="language-julia">src = Sources.Source(origins=Origins.Hexapolar(5, 1.0, 2.0), directions=Directions.Constant())
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_origin_hexapolar.png">
    <img width="250" src="assets/emitters_example_origin_hexapolar.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>Hexapolar</b> origin distribution
</td>
</tr></table><h3 id="Examples-of-Angular-Power-Distribution"><a class="docs-heading-anchor" href="#Examples-of-Angular-Power-Distribution">Examples of Angular Power Distribution</a><a id="Examples-of-Angular-Power-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-of-Angular-Power-Distribution" title="Permalink"></a></h3><p>In these example, the arrow width is proportional to the ray power.</p><pre><code class="language-julia">src = Sources.Source(
    origins=Origins.Hexapolar(1, 8.0, 8.0),             # Hexapolar Origins
	directions=Directions.RectGrid(π/6, π/6, 15, 15),   # RectGrid Directions
	power=AngularPower.Cosine(10.0)                     # Cosine Angular Power
)
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_angular1.png">
    <img width="250" src="assets/emitters_example_angular1.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>Cosine</b> angular power distribution
</td>
</tr></table><pre><code class="language-julia">src = Sources.Source(
	origins=Origins.RectGrid(1.0, 1.0, 3, 3),           # RectGrid Origins
	directions=Directions.HexapolarCone(π/6, 10),       # HexapolarCone Directions
	power=AngularPower.Gaussian(2.0, 2.0)               # Gaussian Angular Power
)
Vis.draw(src, debug=true)</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_angular2.png">
    <img width="250" src="assets/emitters_example_angular2.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
An example of <b>Gaussian</b> angular power distribution
</td>
</tr></table><h3 id="Composite-Sources-Display-Example"><a class="docs-heading-anchor" href="#Composite-Sources-Display-Example">Composite Sources - Display Example</a><a id="Composite-Sources-Display-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Sources-Display-Example" title="Permalink"></a></h3><pre><code class="language-julia"># construct the emitter&#39;s basic components
S = Spectrum.Uniform()
P = AngularPower.Lambertian()
O = Origins.RectGrid(1.0, 1.0, 3, 3)
D = Directions.HexapolarCone(deg2rad(5.0), 3)

# construct the source. in this example a &quot;pixel&quot; source will contain only one source as we are simulating a &quot;b/w&quot; display.
# for RGB displays we can combine 3 sources to simulate &quot;a pixel&quot;.
Tr = Transform(Vec3(0.5, 0.5, 0.0))
source1 = Sources.Source(Tr, S, O, D, P)

# create a list of pixels - each one is a composite source
pixels = Vector{Sources.CompositeSource{Float64}}(undef, 0)
for y in 1:5 # image_height
    for x in 1:10 # image_width
        # pixel position relative to the display&#39;s origin
        local pixel_position = Vec3((x-1) * 1.1, (y-1) * 1.5, 0.0)
        local Tr = Transform(pixel_position)

        # constructing the &quot;pixel&quot;
        pixel = Sources.CompositeSource(Tr, [source1])

        push!(pixels, pixel)
    end
end

Tr = Transform(Vec3(0.0, 0.0, 0.0))
my_display = Sources.CompositeSource(Tr, pixels)

Vis.draw(my_display)                                                # render the display - nothing but the origins primitives
rays = AbstractArray{OpticalRay{Float64, 3}}(collect(my_display))   # collect the rays generated by the display
Vis.draw!(rays)                                                     # render the rays</code></pre><table><tr>
<td>
<a target="_blank" href="assets/emitters_example_composite_display.png">
    <img width="500" src="assets/emitters_example_composite_display.png" style="max-width:100%;">
</a>
</td>
<td valign="middle">
A display example using composite sources.
</td>
</tr></table><h2 id="spectrum"><a class="docs-heading-anchor" href="#spectrum">Spectrum</a><a id="spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#spectrum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.Uniform" href="#OpticSim.Emitters.Spectrum.Uniform"><code>OpticSim.Emitters.Spectrum.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Uniform{T} &lt;: AbstractSpectrum{T}</code></pre><p>Encapsulates a flat spectrum range which is sampled uniformly. Unless stated diferrently, the range used will be 450nm to 680nm.</p><pre><code class="language-julia">Uniform(low::T, high::T) where {T&lt;:Real}
Uniform(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Spectrum.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.DeltaFunction" href="#OpticSim.Emitters.Spectrum.DeltaFunction"><code>OpticSim.Emitters.Spectrum.DeltaFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaFunction{T} &lt;: AbstractSpectrum{T}</code></pre><p>Encapsulates a constant spectrum.</p><pre><code class="language-julia">DeltaFunction{T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Spectrum.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.Measured" href="#OpticSim.Emitters.Spectrum.Measured"><code>OpticSim.Emitters.Spectrum.Measured</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Measured{T} &lt;: AbstractSpectrum{T}</code></pre><p>Encapsulates a measured spectrum to compute emitter power. Create spectrum by reading CSV files. Evaluate spectrum at arbitrary wavelength with <a href="#OpticSim.Emitters.Spectrum.spectrumpower"><code>spectrumpower</code></a> (<strong>more technical details coming soon</strong>)</p><pre><code class="language-julia">Measured(samples::DataFrame)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Spectrum.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.spectrumpower" href="#OpticSim.Emitters.Spectrum.spectrumpower"><code>OpticSim.Emitters.Spectrum.spectrumpower</code></a> — <span class="docstring-category">Function</span></header><section><div><p>expects wavelength in nm not um</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Spectrum.jl#L107">source</a></section></article><h2 id="angular_power_distribution"><a class="docs-heading-anchor" href="#angular_power_distribution">Angular Power Distribution</a><a id="angular_power_distribution-1"></a><a class="docs-heading-anchor-permalink" href="#angular_power_distribution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.AngularPower.Lambertian" href="#OpticSim.Emitters.AngularPower.Lambertian"><code>OpticSim.Emitters.AngularPower.Lambertian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lambertian{T} &lt;: AbstractAngularPowerDistribution{T}</code></pre><p>Ray power is unaffected by angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/AngularPower.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.AngularPower.Cosine" href="#OpticSim.Emitters.AngularPower.Cosine"><code>OpticSim.Emitters.AngularPower.Cosine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cosine{T} &lt;: AbstractAngularPowerDistribution{T}</code></pre><p>Cosine power distribution. Ray power is calculated by:</p><p><code>power = power * (cosine_angle ^ cosine_exp)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/AngularPower.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.AngularPower.Gaussian" href="#OpticSim.Emitters.AngularPower.Gaussian"><code>OpticSim.Emitters.AngularPower.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Gaussian{T} &lt;: AbstractAngularPowerDistribution{T}</code></pre><p>GGaussian power distribution. Ray power is calculated by:</p><p><code>power = power * exp(-(gaussianu * l^2 + gaussianv * m^2))</code> where l and m are the cos_angles between the two axes respectivly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/AngularPower.jl#L42-L49">source</a></section></article><h2 id="rays_origins_distribution"><a class="docs-heading-anchor" href="#rays_origins_distribution">Rays Origins Distribution</a><a id="rays_origins_distribution-1"></a><a class="docs-heading-anchor-permalink" href="#rays_origins_distribution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Origins.Point" href="#OpticSim.Emitters.Origins.Point"><code>OpticSim.Emitters.Origins.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Point{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a single point origin.</p><pre><code class="language-julia">Point(position::Vec3{T}) where {T&lt;:Real}
Point(x::T, y::T, z::T) where {T&lt;:Real}
Point(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Origins.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Origins.RectUniform" href="#OpticSim.Emitters.Origins.RectUniform"><code>OpticSim.Emitters.Origins.RectUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectUniform{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a uniformly sampled rectangle with user defined number of samples.</p><pre><code class="language-julia">RectUniform(width::T, height::T, count::Integer) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Origins.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Origins.RectGrid" href="#OpticSim.Emitters.Origins.RectGrid"><code>OpticSim.Emitters.Origins.RectGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectGrid{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a rectangle sampled in a grid fashion.</p><pre><code class="language-julia">RectGrid(width::T, height::T, usamples::Integer, vsamples::Integer) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Origins.jl#L79-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Origins.Hexapolar" href="#OpticSim.Emitters.Origins.Hexapolar"><code>OpticSim.Emitters.Origins.Hexapolar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hexapolar{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates an ellipse (or a circle where halfsizeu=halfsizev) sampled in an hexapolar fashion (rings).</p><pre><code class="language-julia">Hexapolar(nrings::Integer, halfsizeu::T, halfsizev::T) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Origins.jl#L112-L120">source</a></section></article><h2 id="rays_directions_distribution"><a class="docs-heading-anchor" href="#rays_directions_distribution">Rays Directions Distribution</a><a id="rays_directions_distribution-1"></a><a class="docs-heading-anchor-permalink" href="#rays_directions_distribution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Directions.Constant" href="#OpticSim.Emitters.Directions.Constant"><code>OpticSim.Emitters.Directions.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Constant{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Encapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].</p><pre><code class="language-julia">Constant(direction::Vec3{T}) where {T&lt;:Real}
Constant(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Directions.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Directions.RectGrid" href="#OpticSim.Emitters.Directions.RectGrid"><code>OpticSim.Emitters.Directions.RectGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectGrid{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Encapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].</p><pre><code class="language-julia">Constant(direction::Vec3{T}) where {T&lt;:Real}
Constant(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Directions.jl#L43-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Directions.UniformCone" href="#OpticSim.Emitters.Directions.UniformCone"><code>OpticSim.Emitters.Directions.UniformCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniformCone{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Encapsulates <code>numsamples</code> rays sampled uniformly from a cone with max angle θmax.</p><pre><code class="language-julia">UniformCone(direction::Vec3{T}, θmax::T, numsamples::Integer) where {T&lt;:Real}
UniformCone(θmax::T, numsamples::Integer) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Directions.jl#L89-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Directions.HexapolarCone" href="#OpticSim.Emitters.Directions.HexapolarCone"><code>OpticSim.Emitters.Directions.HexapolarCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HexapolarCone{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Rays are generated by sampling a cone with θmax angle in an hexapolar fashion. The number of rays depends on the requested rings and is computed using the following formula: <code>1 + round(Integer, (nrings * (nrings + 1) / 2) * 6)</code></p><pre><code class="language-julia">HexapolarCone(direction::Vec3{T}, θmax::T, nrings::Integer) where {T&lt;:Real}
HexapolarCone(θmax::T, nrings::Integer = 3) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Directions.jl#L129-L139">source</a></section></article><h2 id="sources"><a class="docs-heading-anchor" href="#sources">Sources</a><a id="sources-1"></a><a class="docs-heading-anchor-permalink" href="#sources" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Sources.Source" href="#OpticSim.Emitters.Sources.Source"><code>OpticSim.Emitters.Sources.Source</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Source{T&lt;:Real, Tr&lt;:Transform{T}, S&lt;:Spectrum.AbstractSpectrum{T}, O&lt;:Origins.AbstractOriginDistribution{T}, D&lt;:Directions.AbstractDirectionDistribution{T}, P&lt;:AngularPower.AbstractAngularPowerDistribution{T}} &lt;: AbstractSource{T}</code></pre><p>This data-type represents the basic emitter (Source), which is a combination of a Spectrum, Angular Power Distribution, Origins and Directions distibution and a 3D Transform.</p><pre><code class="language-julia">Source(::Type{T} = Float64;
       transform::Tr = Transform(),
       spectrum::S = Spectrum.Uniform(),
       origins::O = Origins.Point(),
       directions::D = Directions.Constant(),
       power::P = AngularPower.Lambertian(),
       sourcenum::Integer = 0) where {
            Tr&lt;:Transform,
            S&lt;:Spectrum.AbstractSpectrum,
            O&lt;:Origins.AbstractOriginDistribution,
            D&lt;:Directions.AbstractDirectionDistribution,
            P&lt;:AngularPower.AbstractAngularPowerDistribution,
            T&lt;:Real}

Source(transform::Tr, spectrum::S, origins::O, directions::D, power::P, ::Type{T} = Float64; sourcenum::Integer = 0) where {   
            Tr&lt;:Transform,
            S&lt;:Spectrum.AbstractSpectrum,
            O&lt;:Origins.AbstractOriginDistribution,
            D&lt;:Directions.AbstractDirectionDistribution,
            P&lt;:AngularPower.AbstractAngularPowerDistribution,
            T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Sources.jl#L21-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Emitters.Sources.CompositeSource" href="#OpticSim.Emitters.Sources.CompositeSource"><code>OpticSim.Emitters.Sources.CompositeSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CompositeSource{T} &lt;: AbstractSource{T}</code></pre><p>This data-type represents the composite emitter (Source) which is constructed with a list of basic or composite emitters and a 3D Transform.</p><pre><code class="language-julia">CompositeSource(transform::Transform{T}, sources::Array) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/999b8a64564b4441fe76643a0b98b9dfb4ed8a7d/src/Optical/Emitters/Sources.jl#L147-L155">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../emitters/">« Emitters</a><a class="docs-footer-nextpage" href="../interfaces/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 08:52">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
