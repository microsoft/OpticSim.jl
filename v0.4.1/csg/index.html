<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CSG · OpticSim.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">OpticSim.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../basic_types/">Basic Types</a></li><li><a class="tocitem" href="../primitives/">Primitives</a></li><li class="is-active"><a class="tocitem" href>CSG</a><ul class="internal"><li><a class="tocitem" href="#CSG-Operations"><span>CSG Operations</span></a></li><li><a class="tocitem" href="#Pre-made-CSG-Shapes"><span>Pre-made CSG Shapes</span></a></li><li><a class="tocitem" href="#CSG-Types"><span>CSG Types</span></a></li><li><a class="tocitem" href="#Additional-Functions-and-Types"><span>Additional Functions and Types</span></a></li></ul></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../emitters_new/">Emitters (NEW)</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li><a class="tocitem" href="../vis/">Visualization</a></li><li><a class="tocitem" href="../glasscat/">Glass Functions</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../cloud/">Cloud Execution</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry</a></li><li class="is-active"><a href>CSG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CSG</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/microsoft/OpticSim.jl/blob/master/docs/src/csg.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CSG"><a class="docs-heading-anchor" href="#CSG">CSG</a><a id="CSG-1"></a><a class="docs-heading-anchor-permalink" href="#CSG" title="Permalink"></a></h1><h2 id="CSG-Operations"><a class="docs-heading-anchor" href="#CSG-Operations">CSG Operations</a><a id="CSG-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#CSG-Operations" title="Permalink"></a></h2><p>There are three binary csg operations which can construct extremely complex objects from very simple primitives: union (<span>$\cup$</span>), intersection (<span>$\cap$</span>) and subtraction (i.e. difference).</p><p>This diagram shows the basic idea: <img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Csg_tree.png" alt="CSG Tree visualization"/></p><p>The code for this in our system would look this this:</p><pre><code class="language-">using OpticSim # hide
cyl = Cylinder(0.7)
cyl_cross = csgunion(csgunion(leaf(cyl), leaf(cyl, rotationd(90, 0, 0))), leaf(cyl, rotationd(0, 90, 0)))

cube = Cuboid(1.0, 1.0, 1.0)
sph = Sphere(1.3)
rounded_cube = csgintersection(cube, sph)

result = csgdifference(rounded_cube, cyl_cross)
Vis.draw(result, numdivisions=100)

Vis.save(&quot;assets/csg_ex.png&quot;) # hide</code></pre><p><img src="assets/csg_ex.png" alt="CSG code example image"/></p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.leaf" href="#OpticSim.leaf"><code>OpticSim.leaf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a leaf node from a parametric surface with a given transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L131-L135">source</a></section><section><div><pre><code class="language-julia">leaf(surf::CSGGenerator{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a (pseudo) leaf node from another CSGGenerator, this is useful if you want multiple copies of a premade CSG structure with different transforms, for example in an MLA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.csgunion" href="#OpticSim.csgunion"><code>OpticSim.csgunion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">csgunion(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a binary node in the CSG tree representing a union between a and b. A shortcut method for <code>a</code> and <code>b</code> as <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s is also available.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4a/Boolean_union.PNG" alt="Union Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.csgintersection" href="#OpticSim.csgintersection"><code>OpticSim.csgintersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">csgintersection(a::CSGGenerator{T} b::CSGGenerator{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a binary node in the CSG tree representing an intersection between a and b. A shortcut method for <code>a</code> and <code>b</code> as <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s is also available.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Boolean_intersect.PNG" alt="Intersect Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.csgdifference" href="#OpticSim.csgdifference"><code>OpticSim.csgdifference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">csgdifference(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a binary node in the CSG tree representing the difference of a and b, essentially a - b. A shortcut method for <code>a</code> and <code>b</code> as <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s is also available.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/86/Boolean_difference.PNG" alt="Difference Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L183-L190">source</a></section></article><h2 id="Pre-made-CSG-Shapes"><a class="docs-heading-anchor" href="#Pre-made-CSG-Shapes">Pre-made CSG Shapes</a><a id="Pre-made-CSG-Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-made-CSG-Shapes" title="Permalink"></a></h2><p>There are also some shortcut methods available to create common CSG objects more easily:</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BoundedCylinder" href="#OpticSim.BoundedCylinder"><code>OpticSim.BoundedCylinder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cylinder with planar caps on both ends centred at <code>(0, 0, 0)</code> with axis <code>(0, 0, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/Geometry.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Cuboid" href="#OpticSim.Cuboid"><code>OpticSim.Cuboid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cuboid centred at <code>(0, 0, 0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/Geometry.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexagonalPrism" href="#OpticSim.HexagonalPrism"><code>OpticSim.HexagonalPrism</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall hexagonal prism with axis <code>(0, 0, 1)</code>, the longer hexagon diameter is along the x axis. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/Geometry.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularPrism" href="#OpticSim.RectangularPrism"><code>OpticSim.RectangularPrism</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall rectangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/Geometry.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.TriangularPrism" href="#OpticSim.TriangularPrism"><code>OpticSim.TriangularPrism</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall triangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/Geometry.jl#L149-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Spider" href="#OpticSim.Spider"><code>OpticSim.Spider</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -&gt; Vector{Rectangle{T}}</code></pre><p>Creates a &#39;spider&#39; obscuration with <code>narms</code> rectangular arms evenly spaced around a circle defined by <code>origin</code> and <code>normal</code>. Each arm is a rectangle <code>armwidth</code>×<code>radius</code>.</p><p>e.g. for 3 and 4 arms we get:</p><pre><code class="language-none">   |         _|_
  / \         |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/Geometry.jl#L164-L175">source</a></section></article><h2 id="CSG-Types"><a class="docs-heading-anchor" href="#CSG-Types">CSG Types</a><a id="CSG-Types-1"></a><a class="docs-heading-anchor-permalink" href="#CSG-Types" title="Permalink"></a></h2><p>These are the types of the primary CSG elements, i.e. the nodes in the CSG tree.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CSGTree" href="#OpticSim.CSGTree"><code>OpticSim.CSGTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing any evaluated CSG structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CSGGenerator" href="#OpticSim.CSGGenerator"><code>OpticSim.CSGGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CSGGenerator{T&lt;:Real}</code></pre><p>This is the type you should use when making CSG objects. This type allows for the construction of <a href="#OpticSim.CSGTree"><code>CSGTree</code></a> objects with different transforms. When the generator is evaluated, all transforms are propagated down to the <a href="#OpticSim.LeafNode"><code>LeafNode</code></a>s and stored there.</p><p><strong>Example</strong></p><pre><code class="language-julia">a = Cylinder(1.0,1.0)
b = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])
generator = csgintersection(a,b)
# now make a csg object that can be ray traced
csgobj = generator(Transform(1.0,1.0,2.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L103-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ComplementNode" href="#OpticSim.ComplementNode"><code>OpticSim.ComplementNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ComplementNode{T,C&lt;:CSGTree{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated complement node within the CSG tree, must be the second child of a <a href="#OpticSim.IntersectionNode"><code>IntersectionNode</code></a> forming a subtraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.UnionNode" href="#OpticSim.UnionNode"><code>OpticSim.UnionNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnionNode{T,L&lt;:CSGTree{T},R&lt;:CSGTree{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated union node within the CSG tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.IntersectionNode" href="#OpticSim.IntersectionNode"><code>OpticSim.IntersectionNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IntersectionNode{T,L&lt;:CSGTree{T},R&lt;:CSGTree{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated intersection node within the CSG tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.LeafNode" href="#OpticSim.LeafNode"><code>OpticSim.LeafNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LeafNode{T,S&lt;:ParametricSurface{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated leaf node in the CSG tree, <code>geometry</code> attribute which contains a <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a> of type <code>S</code>. The leaf node also has a transform associated which is the composition of all nodes above it in the tree. As such, transforming points from the geometry using this transform puts them in world space, and transforming rays by the inverse transform puts them in object space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L81-L87">source</a></section></article><h2 id="Additional-Functions-and-Types"><a class="docs-heading-anchor" href="#Additional-Functions-and-Types">Additional Functions and Types</a><a id="Additional-Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Functions-and-Types" title="Permalink"></a></h2><p>These are the internal types and functions used for geomertic/CSG operations.</p><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}"><code>OpticSim.surfaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})</code></pre><p>Calculates the intersection of <code>r</code> with CSG object, <code>obj</code>.</p><p>Returns an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no intersection, an <a href="#OpticSim.Interval"><code>Interval</code></a> if there is one or two interesections and a <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p><p>The ray is intersected with the <a href="#OpticSim.LeafNode"><code>LeafNode</code></a>s that make up the CSG object and the resulting <code>Interval</code>s and <code>DisjointUnion</code>s are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in <em>object space</em> for that node before the intersection is carried out, typically this <em>object space</em> is centered at the origin, but may differ for each primitive.</p><p>Some intersections are culled without actually evaluating them by first checking if the ray intersects the <a href="../primitives/#OpticSim.BoundingBox"><code>BoundingBox</code></a> of each node in the <a href="#OpticSim.CSGTree"><code>CSGTree</code></a>, this can substantially improve performance in some cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L269-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real" href="#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real"><code>OpticSim.inside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inside(obj::CSGTree{T}, point::SVector{3,T}) -&gt; Bool
inside(obj::CSGTree{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>inside</em> <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real" href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real"><code>OpticSim.onsurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onsurface(obj::CSGTree{T}, point::SVector{3,T}) -&gt; Bool
onsurface(obj::CSGTree{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>on</em> the surface (i.e. shell) of <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/CSG.jl#L290-L295">source</a></section></article><h3 id="Intervals"><a class="docs-heading-anchor" href="#Intervals">Intervals</a><a id="Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Intervals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Interval" href="#OpticSim.Interval"><code>OpticSim.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Interval{T} &lt;: AbstractRayInterval{T}</code></pre><p>Datatype representing an interval between two <a href="#OpticSim.IntervalPoint"><code>IntervalPoint</code></a>s on a ray.</p><p>The lower element can either be <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a> or an <a href="#OpticSim.Intersection"><code>Intersection</code></a>. The upper element can either be an <a href="#OpticSim.Intersection"><code>Intersection</code></a> or <a href="#OpticSim.Infinity"><code>Infinity</code></a>.</p><pre><code class="language-julia">positivehalfspace(int::Intersection) -&gt; Interval with lower = int, upper = Infinity
rayorigininterval(int::Intersection) -&gt; Interval with lower = RayOrigin, upper = int
Interval(low, high)</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia">lower(a::Interval{T}) -&gt; Union{RayOrigin{T},Intersection{T,3}}
upper(a::Interval{T}) -&gt; Union{Intersection{T,3},Infinity{T}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L41-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.EmptyInterval" href="#OpticSim.EmptyInterval"><code>OpticSim.EmptyInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EmptyInterval{T} &lt;: AbstractRayInterval{T}</code></pre><p>An interval with no <a href="#OpticSim.Intersection"><code>Intersection</code></a>s which is also not infinite.</p><pre><code class="language-none">EmptyInterval(T = Float64)
EmptyInterval{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.DisjointUnion" href="#OpticSim.DisjointUnion"><code>OpticSim.DisjointUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of <code>Interval</code>s can be input to the constructor and they will automatically be processed into a valid <code>DisjointUnion</code> (or a single <a href="#OpticSim.Interval"><code>Interval</code></a> if appropriate).</p><pre><code class="language-julia">DisjointUnion(intervals::AbstractVector{Interval{R}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.isemptyinterval" href="#OpticSim.isemptyinterval"><code>OpticSim.isemptyinterval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isemptyinterval(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a>. In performance critical contexts use <code>a isa EmptyInterval{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ispositivehalfspace" href="#OpticSim.ispositivehalfspace"><code>OpticSim.ispositivehalfspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ispositivehalfspace(a) -&gt; Bool</code></pre><p>Returns true if <code>upper(a)</code> is <a href="#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts check directly i.e. <code>upper(a) isa Infinity{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.israyorigininterval" href="#OpticSim.israyorigininterval"><code>OpticSim.israyorigininterval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">israyorigininterval(a) -&gt; Bool</code></pre><p>Returns true if <code>lower(a)</code> is <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts check directly i.e. <code>lower(a) isa RayOrigin{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.halfspaceintersection" href="#OpticSim.halfspaceintersection"><code>OpticSim.halfspaceintersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">halfspaceintersection(a::Interval{T}) -&gt; Intersection{T,3}</code></pre><p>Returns the <a href="#OpticSim.Intersection"><code>Intersection</code></a> from a half space <a href="#OpticSim.Interval"><code>Interval</code></a>, throws an error if not a half space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.closestintersection" href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -&gt; Union{Nothing,Intersection{T,3}}</code></pre><p>Returns the closest <a href="#OpticSim.Intersection"><code>Intersection</code></a> from an <a href="#OpticSim.Interval"><code>Interval</code></a> or <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a>. Ignores intersection with null interfaces if <code>ignorenull</code> is true. Will return <code>nothing</code> if there is no valid intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L290-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.IntervalPool" href="#OpticSim.IntervalPool"><code>OpticSim.IntervalPool</code></a> — <span class="docstring-category">Type</span></header><section><div><p>To prevent allocations we have a manually managed pool of arrays of <a href="#OpticSim.Interval"><code>Interval</code></a>s which are used to store values during execution. The memory is kept allocated and reused across runs of functions like <a href="../systems/#OpticSim.trace"><code>trace</code></a>.</p><p><code>threadedintervalpool</code> is a global threadsafe pool which is accessed through the functions:</p><pre><code class="language-julia">newinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -&gt; Vector{Interval{T}}
indexednewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -&gt; Tuple{Int,Vector{Interval{T}}}
emptyintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid())
getfromintervalpool([::Type{T} = Float64], id::Int, tid::Int = Threads.threadid()) -&gt; Vector{Interval{T}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Interval.jl#L85-L96">source</a></section></article><h3 id="Intersections"><a class="docs-heading-anchor" href="#Intersections">Intersections</a><a id="Intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Intersections" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OpticSim.IntervalPoint" href="#OpticSim.IntervalPoint"><code>OpticSim.IntervalPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Each <a href="#OpticSim.Interval"><code>Interval</code></a> consists of two <code>IntervalPoint</code>s, one of <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>, <a href="#OpticSim.Intersection"><code>Intersection</code></a> or <a href="#OpticSim.Infinity"><code>Infinity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Intersection.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RayOrigin" href="#OpticSim.RayOrigin"><code>OpticSim.RayOrigin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RayOrigin{T} &lt;: IntervalPoint{T}</code></pre><p>Point representing 0 within an <a href="#OpticSim.Interval"><code>Interval</code></a>, i.e. the start of the ray.</p><pre><code class="language-julia">RayOrigin(T = Float64)
RayOrigin{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Intersection.jl#L114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Infinity" href="#OpticSim.Infinity"><code>OpticSim.Infinity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Infinity{T} &lt;: IntervalPoint{T}</code></pre><p>Point representing ∞ within an <a href="#OpticSim.Interval"><code>Interval</code></a>.</p><pre><code class="language-julia">Infinity(T = Float64)
Infinity{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Intersection.jl#L100-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Intersection" href="#OpticSim.Intersection"><code>OpticSim.Intersection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Intersection{T,N} &lt;: IntervalPoint{T}</code></pre><p>Represents the point at which an <a href="../emitters/#OpticSim.Ray"><code>Ray</code></a> hits a <a href="../primitives/#OpticSim.Surface"><code>Surface</code></a>. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the <a href="../interfaces/#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> hit.</p><p>Has the following accessor methods:</p><pre><code class="language-julia">point(a::Intersection{T,N}) -&gt; SVector{N,T}
normal(a::Intersection{T,N}) -&gt; SVector{N,T}
uv(a::Intersection{T,N}) -&gt; SVector{2,T}
u(a::Intersection{T,N}) -&gt; T
v(a::Intersection{T,N}) -&gt; T
α(a::Intersection{T,N}) -&gt; T
interface(a::Intersection{T,N}) -&gt; OpticalInterface{T}
flippednormal(a::Intersection{T,N}) -&gt; Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Intersection.jl#L32-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.isinfinity" href="#OpticSim.isinfinity"><code>OpticSim.isinfinity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isinfinity(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts use <code>a isa Infinity{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Intersection.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.israyorigin" href="#OpticSim.israyorigin"><code>OpticSim.israyorigin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">israyorigin(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts use <code>a isa RayOrigin{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/35abc65c5625695a64c44fd7a550574d7bd8504c/src/Geometry/CSG/Intersection.jl#L175-L180">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../primitives/">« Primitives</a><a class="docs-footer-nextpage" href="../systems/">Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 8 April 2021 13:19">Thursday 8 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
