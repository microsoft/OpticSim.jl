<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Visualization · OpticSim.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">OpticSim.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../basic_types/">Basic Types</a></li><li><a class="tocitem" href="../primitives/">Primitives</a></li><li><a class="tocitem" href="../csg/">CSG</a></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li class="is-active"><a class="tocitem" href>Visualization</a><ul class="internal"><li><a class="tocitem" href="#Basic-Drawing"><span>Basic Drawing</span></a></li><li><a class="tocitem" href="#Helper-Methods"><span>Helper Methods</span></a></li><li><a class="tocitem" href="#Complete-Drawing-Functions"><span>Complete Drawing Functions</span></a></li><li><a class="tocitem" href="#Known-Issues"><span>Known Issues</span></a></li></ul></li><li><a class="tocitem" href="../glasscat/">Glass Functions</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../cloud/">Cloud Execution</a></li><li><a class="tocitem" href="../notebooksutils/">Notebook utilities</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Visualization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Visualization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/microsoft/OpticSim.jl/blob/master/docs/src/vis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h1><p>There are a number of powerful visualization tools available, we primarily rely on 3D visualization of systems using <a href="http://makie.juliaplots.org/stable/">Makie</a>.</p><p>There are a number of helper methods, as well as the ability to draw objects, surfaces, points, rays and more individually. For example, looking at rays passing through a system in 3D and 2D:</p><pre><code class="language-julia">Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100)</code></pre><pre><code class="language-julia">Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100)
Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100, drawsys=true, resolution = (1000, 700))
Vis.make2dy()</code></pre><pre class="documenter-example-output">[ Info: Makie/AbstractPlotting is caching fonts, this may take a while. Needed only on first run!</pre><p><img src="../assets/vis_ex_3d.png" alt="3D visualization example"/> <img src="../assets/vis_ex_2d.png" alt="2D visualization example"/></p><p>And the image on the detector for a trace of a system:</p><pre><code class="language-julia">Vis.drawtraceimage(Examples.cooketriplet(), test=true)</code></pre><pre><code class="language-julia">im = Vis.drawtraceimage(Examples.cooketriplet(Float64, 400), test=true)</code></pre><p><img src="../assets/vis_ex_im.png" alt="detector image example"/></p><h2 id="Basic-Drawing"><a class="docs-heading-anchor" href="#Basic-Drawing">Basic Drawing</a><a id="Basic-Drawing-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Drawing" title="Permalink"></a></h2><p>These methods are all you need to build up a visualization piece by piece. For example:</p><pre><code class="language-julia">obj = csgintersection(Sphere(0.5), Plane(0.0, 1.0, 0.0, 0.0, 0.1, 0.0))()
ray1 = Ray([0.0, -0.1, 1.0], [0.0, 0.0, -1.0])
ray2 = Ray([0.8, 0.0, 0.0], [-1.0, 0.0, 0.0])
Vis.draw(obj)
Vis.draw!(ray1, rayscale=0.2)
Vis.draw!(ray2, rayscale=0.2, color=:blue)
Vis.draw!(surfaceintersection(obj, ray1), color=:red)
Vis.draw!(surfaceintersection(obj, ray2), color=:green)</code></pre><p><img src="../assets/vis_ex_3d_parts.png" alt="basic drawing example"/></p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.scene" href="#OpticSim.Vis.scene"><code>OpticSim.Vis.scene</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scene(resolution = (1000, 1000))</code></pre><p>Create a new Makie scene with the given resolution including control buttons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.draw" href="#OpticSim.Vis.draw"><code>OpticSim.Vis.draw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">draw(ob; resolution = (1000, 1000), kwargs...)</code></pre><p>Draw an object in a new scene. <code>kwargs</code> depends on the object type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.draw!-Tuple{Any}" href="#OpticSim.Vis.draw!-Tuple{Any}"><code>OpticSim.Vis.draw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw!([scene = currentscene], ob; kwargs...)</code></pre><p>Draw an object in an existing scene. <code>kwargs</code> depends on the object type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.save" href="#OpticSim.Vis.save"><code>OpticSim.Vis.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save(path::String)</code></pre><p>Save the current Makie scene to an image file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L226-L230">source</a></section></article><h2 id="Helper-Methods"><a class="docs-heading-anchor" href="#Helper-Methods">Helper Methods</a><a id="Helper-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Methods" title="Permalink"></a></h2><p>These are the helper methods to provide common visualizations more easily, as used above. Another example:</p><pre><code class="language-julia">Vis.surfacesag(AcceleratedParametricSurface(TestData.zernikesurface2()), (256, 256), (1.55, 1.55))</code></pre><pre><code class="language-julia">p = Vis.surfacesag(AcceleratedParametricSurface(TestData.zernikesurface2()), (256, 256), (1.55, 1.55))</code></pre><pre class="documenter-example-output">QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-runner&#39;</pre><p><img src="../assets/surface_sag.svg" alt="surface sag example"/></p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.drawtracerays" href="#OpticSim.Vis.drawtracerays"><code>OpticSim.Vis.drawtracerays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawtracerays(system::Q; raygenerator::S = Source(transform = Transform.translation(0.0,0.0,10.0), origins = Origins.RectGrid(10.0,10.0,25,25),directions = Constant(0.0,0.0,-1.0)), test::Bool = false, trackallrays::Bool = false, colorbysourcenum::Bool = false, colorbynhits::Bool = false, rayfilter::Union{Nothing,Function} = onlydetectorrays, kwargs...)</code></pre><p>Displays a model of the optical system. <code>raygenerator</code> is an iterator that generates rays. If <code>trackallrays</code> is true then ray paths from the emitter will be displayed otherwise just the final rays that intersect the image detector will be shown, not the entire ray path. <code>colorbysourcenum</code> and <code>colorbynhits</code> will color rays accordingly, otherwise rays will be colored according to their wavelength.</p><p>By default only ray paths that eventually intersect the detector surface are displayed. If you want to display all ray paths set <code>rayfilter = nothing</code>.</p><p>Also <code>drawtracerays!</code> to add to an existing scene, with <code>drawsys</code> and <code>drawgen</code> to specify whether <code>system</code> and <code>raygenerator</code> should be drawn respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L437-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.drawtraceimage" href="#OpticSim.Vis.drawtraceimage"><code>OpticSim.Vis.drawtraceimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawtraceimage(system::Q; raygenerator::S = Source(transform = translation(0.0,0.0,10.0), origins = Origins.RectGrid(10.0,10.0,25,25),directions = Constant(0.0,0.0,-1.0)), test::Bool = false)</code></pre><p>Traces rays from <code>raygenerator</code> through <code>system</code> and shows and returns the detector image. <code>verbose</code> will print progress updates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L497-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.spotdiag" href="#OpticSim.Vis.spotdiag"><code>OpticSim.Vis.spotdiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spotdiag(sys::CSGOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; size = (500, 500), kwargs...)</code></pre><p>Plot a spot diagram for an arbitrary <a href="../systems/#OpticSim.CSGOpticalSystem"><code>CSGOpticalSystem</code></a> and <a href="../ref/#OpticSim.OpticalRayGenerator"><code>OpticalRayGenerator</code></a>. All rays from <code>raygenerator</code> will be traced through <code>sys</code> and their intersection location on the detector plotted.</p><p>Also <code>spotdiag!</code> of the same arguments to add to an existing plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L746-L753">source</a></section><section><div><pre><code class="language-none">spotdiag(sys::AxisymmetricOpticalSystem{T}; size = (500, 500), hexapolar::Bool = true, collimated::Bool = true, samples::Int = 5, wavelength::T = 0.55, sourceangle::T = zero(T), sourcepos::SVector{3,T} = SVector{3,T}(0.0, 0.0, 10.0), kwargs...)</code></pre><p>Plot a spot diagram for an <a href="../systems/#OpticSim.AxisymmetricOpticalSystem"><code>AxisymmetricOpticalSystem</code></a>, rays are distributed across the entrance pupil of the system either in a hexapolar of rectangular grid pattern depending on <code>hexapolar</code>.</p><p>The input rays can be <code>collimated</code>, in which case the <code>sourceangle</code> parameter determines their direction. Otherwise rays are treated as coming from a point source at <code>sourcepos</code>.</p><p>Also <code>spotdiag!</code> of the same arguments to add to an existing plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L759-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.surfacesag" href="#OpticSim.Vis.surfacesag"><code>OpticSim.Vis.surfacesag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">surfacesag(object::Union{CSGTree{T},Surface{T}}, resolution::Tuple{Int,Int}, halfsizes::Tuple{T,T}; offset::T = T(10), position::SVector{3,T} = SVector{3,T}(0.0, 0.0, 10.0), direction::SVector{3,T} = SVector{3,T}(0.0, 0.0, -1.0), rotationvec::SVector{3,T} = SVector{3,T}(0.0, 1.0, 0.0))</code></pre><p>Calculates and displays the surface sag of an arbitrary <a href="../primitives/#OpticSim.Surface"><code>Surface</code></a> or <a href="../csg/#OpticSim.CSGTree"><code>CSGTree</code></a>.</p><p>Rays are shot in a grid of size defined by <code>resolution</code> across a arectangular area defined by <code>halfsizes</code>. This rectangle is centred at <code>postion</code> with normal along <code>direction</code> and rotation defined by <code>rotationvec</code>. <code>offset</code> is subtracted from the sag measurements to provide values relative to the appropriate zero level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L835-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.eyebox_eval_eye" href="#OpticSim.Vis.eyebox_eval_eye"><code>OpticSim.Vis.eyebox_eval_eye</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eyebox_eval_eye(assembly::LensAssembly{T}, raygen::OpticalRayGenerator{T}, eye_rotation_x::T, eye_rotation_y::T, sample_points_x::Int, sample_points_y::Int; pupil_radius::T = T(2.0), resolution::Int = 512, eye_transform::Transform{T} = identitytransform(T))</code></pre><p>Visualise the images formed when tracing <code>assembly</code> with a human eye for an evenly sampled <code>sample_points_x × sample_points_y</code> grid in the angular range of eyeball rotations <code>-eye_rotation_x:eye_rotation_x</code> and <code>-eye_rotation_y:eye_rotation_y</code> in each dimension respectively. <code>resolution</code> is the size of the detector image (necessarily square).</p><p>The eye must be positioned appropriately relative to the system using <code>eye_transform</code>, this should transform the eye to the correct position and orientation when at 0 rotation in both dimensions. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.</p><p>The result is displayed as a 4D image - the image seen by the eye is shown in 2D as normal with sliders to vary eye rotation in x and y. The idea being that the whole image should be visible for all rotations in the range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L873-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.eyebox_eval_planar" href="#OpticSim.Vis.eyebox_eval_planar"><code>OpticSim.Vis.eyebox_eval_planar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eyebox_eval_planar(assembly::LensAssembly{T}, raygen::OpticalRayGenerator{T}, eyebox::Rectangle{T}, sample_points_x::Int, sample_points_y::Int, vsize::T; pupil_radius::T = T(2.0), resolution::Int = 512)</code></pre><p>Visualise the images formed when tracing <code>assembly</code> for multiple pupil positions within a planar <code>eyebox</code>. Any angles which are present in a circle radius <code>pupil_radius</code> around each sampling point on an even <code>sample_points_x × sample_points_y</code> grid on the <code>eyebox</code> are added to the sub-image at that grid point.</p><p>A paraxial lens focal length 1mm is placed at the eyebox and a detector of size <code>vsize × vsize</code>mm placed 1mm behind it. The normal of the detector rectangle should point towards the system (and away from the fake detector). Any rays which miss the detector are ignored.</p><p>The pupil is always fully contained in the eyebox, i.e., the extreme sample position in u would be <code>eyebox.halfsizeu - pupil_radius</code>, for example.</p><p>The result is displayed as a 4D image - each sub-image is shown as normal with sliders to vary eye rotation in x and y. The idea being that the whole FoV should be visible for all rotations in the range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L908-L922">source</a></section></article><h2 id="Complete-Drawing-Functions"><a class="docs-heading-anchor" href="#Complete-Drawing-Functions">Complete Drawing Functions</a><a id="Complete-Drawing-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Drawing-Functions" title="Permalink"></a></h2><p>As mentioned above, <code>Vis.draw!</code> can be used to draw a large variety of objects, each with their own additional arguments. Here is a full list of the available drawing function and their associated options.</p><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Vis.draw!" href="#OpticSim.Vis.draw!"><code>OpticSim.Vis.draw!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">draw!([scene = currentscene], ob; kwargs...)</code></pre><p>Draw an object in an existing scene. <code>kwargs</code> depends on the object type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L209-L214">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, surf::Surface{T}; numdivisions = 20, normals = false, normalcolor = :blue, kwargs...)</code></pre><p>Transforms <code>surf</code> into a mesh using <a href="../primitives/#OpticSim.makemesh"><code>makemesh</code></a> and draws the result. <code>normals</code> of the surface can be drawn at evenly sampled points with provided <code>normalcolor</code>. <code>numdivisions</code> determines the resolution with which the mesh is triangulated. <code>kwargs</code> is passed on to the <a href="../primitives/#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> drawing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L312-L319">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, tmesh::TriangleMesh{T}; linewidth = 3, shaded = true, wireframe = false, color = :orange, normals = false, normalcolor = :blue, transparency = false, kwargs...)</code></pre><p>Draw a <a href="../primitives/#OpticSim.TriangleMesh"><code>TriangleMesh</code></a>, optionially with a visible <code>wireframe</code>. <code>kwargs</code> are passed on to <a href="http://makie.juliaplots.org/stable/plotting_functions.html#mesh"><code>Makie.mesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L333-L337">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, meshes::Vararg{S}; colors::Bool = false, kwargs...) where {T&lt;:Real,S&lt;:Union{TriangleMesh{T},Surface{T}}}</code></pre><p>Draw a series of <a href="../primitives/#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> or <a href="../primitives/#OpticSim.Surface"><code>Surface</code></a> objects, if <code>colors</code> is true then each mesh will be colored automatically with a diverse series of colors. <code>kwargs</code> are is passed on to the drawing function for each element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L361-L366">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, csg::Union{CSGTree,CSGGenerator}; numdivisions::Int = 20, kwargs...)</code></pre><p>Convert a CSG object (<a href="../csg/#OpticSim.CSGTree"><code>CSGTree</code></a> or <a href="../csg/#OpticSim.CSGGenerator"><code>CSGGenerator</code></a>) to a mesh using <a href="../primitives/#OpticSim.makemesh"><code>makemesh</code></a> with resolution set by <code>numdivisions</code> and draw the resulting <a href="../primitives/#OpticSim.TriangleMesh"><code>TriangleMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L384-L388">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, bbox::BoundingBox{T}; kwargs...)</code></pre><p>Draw a <a href="../primitives/#OpticSim.BoundingBox"><code>BoundingBox</code></a> as a wireframe, ie series of lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L392-L396">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, ass::LensAssembly; kwargs...)</code></pre><p>Draw each element in a <a href="../systems/#OpticSim.LensAssembly"><code>LensAssembly</code></a>, with each element automatically colored differently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L411-L415">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, sys::AbstractOpticalSystem; kwargs...)</code></pre><p>Draw each element in the lens assembly of an <a href="../systems/#OpticSim.AbstractOpticalSystem"><code>AbstractOpticalSystem</code></a>, with each element automatically colored differently, as well as the detector of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L422-L426">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, rays::AbstractVector{&lt;:AbstractRay{T,N}}; kwargs...)</code></pre><p>Draw a vector of <a href="../ref/#OpticSim.Ray"><code>Ray</code></a> or <a href="../ref/#OpticSim.OpticalRay"><code>OpticalRay</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L522-L526">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, traces::AbstractVector{LensTrace{T,N}}; kwargs...)</code></pre><p>Draw a vector of <a href="../systems/#OpticSim.LensTrace"><code>LensTrace</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L533-L537">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, trace::LensTrace{T,N}; colorbysourcenum::Bool = false, colorbynhits::Bool = false, kwargs...)</code></pre><p>Draw a <a href="../systems/#OpticSim.LensTrace"><code>LensTrace</code></a> as a line which can be colored automatically by its <code>sourcenum</code> or <code>nhits</code> attributes. The alpha is determined by the <code>power</code> attribute of <code>trace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L544-L549">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, ray::OpticalRay{T,N}; colorbysourcenum::Bool = false, colorbynhits::Bool = false, kwargs...)</code></pre><p>Draw an <a href="../ref/#OpticSim.OpticalRay"><code>OpticalRay</code></a> which can be colored automatically by its <code>sourcenum</code> or <code>nhits</code> attributes. The alpha of the ray is determined by the <code>power</code> attribute of <code>ray</code>. <code>kwargs</code> are passed to <code>draw!(scene, ray::Ray)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L561-L567">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, ray::Ray{T,N}; color = :yellow, rayscale = 1.0, kwargs...)</code></pre><p>Draw a <a href="../ref/#OpticSim.Ray"><code>Ray</code></a> in a given <code>color</code> optionally scaling the size using <code>rayscale</code>. <code>kwargs</code> are passed to <a href="http://makie.juliaplots.org/stable/plotting_functions.html#arrows"><code>Makie.arrows</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L579-L584">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, du::DisjointUnion{T}; kwargs...)</code></pre><p>Draw each <a href="../csg/#OpticSim.Interval"><code>Interval</code></a> in a <a href="../csg/#OpticSim.DisjointUnion"><code>DisjointUnion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L589-L593">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, intervals::AbstractVector{Interval{T}}; kwargs...)</code></pre><p>Draw a vector of <a href="../csg/#OpticSim.Interval"><code>Interval</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L598-L602">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, interval::Interval{T}; kwargs...)</code></pre><p>Draw an <a href="../csg/#OpticSim.Interval"><code>Interval</code></a> as a line with circles at each <a href="../csg/#OpticSim.Intersection"><code>Intersection</code></a> point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L609-L613">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, intersection::Intersection; normal::Bool = false, kwargs...)</code></pre><p>Draw an <a href="../csg/#OpticSim.Intersection"><code>Intersection</code></a> as a circle, optionally showing the surface normal at the point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L634-L638">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, lines::AbstractVector{Tuple{AbstractVector{T},AbstractVector{T}}}; kwargs...)</code></pre><p>Draw a vector of lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L646-L650">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, line::Tuple{AbstractVector{T},AbstractVector{T}}; color = :yellow, kwargs...)</code></pre><p>Draw a line between two points, <code>kwargs</code> are passed to <a href="http://makie.juliaplots.org/stable/plotting_functions.html#linesegments"><code>Makie.linesegments</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L657-L661">source</a></section><section><div><pre><code class="language-none">draw!(s::MakieLayout.LScene, point::AbstractVector{T}; kwargs...)</code></pre><p>Draw a single point, <code>kwargs</code> are passed to <code>draw!(scene, points::AbstractVector{AbstractVector{T}})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L666-L670">source</a></section><section><div><pre><code class="language-none">draw!(scene::MakieLayout.LScene, points::AbstractVector{AbstractVector{T}}; markersize = 20, color = :black, kwargs...)</code></pre><p>Draw a vector of points. <code>kwargs</code> are passed to <a href="http://makie.juliaplots.org/stable/plotting_functions.html#scatter"><code>Makie.scatter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/7d8b4b8d0e4d1612f50db4baf8755301693b9219/src/Vis/Visualization.jl#L675-L680">source</a></section></article><h2 id="Known-Issues"><a class="docs-heading-anchor" href="#Known-Issues">Known Issues</a><a id="Known-Issues-1"></a><a class="docs-heading-anchor-permalink" href="#Known-Issues" title="Permalink"></a></h2><p>If the Makie plot is printing to the console rather than showing properly in a separate window then call <code>Vis.AbstractPlotting.__init__()</code>. This will only occur when using a system image including the OpticSim package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lenses/">« Lenses</a><a class="docs-footer-nextpage" href="../glasscat/">Glass Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 19 May 2021 20:38">Wednesday 19 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
