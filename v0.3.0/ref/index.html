<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · OpticSim.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">OpticSim.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../primitives/">Primitives</a></li><li><a class="tocitem" href="../csg/">CSG</a></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li><a class="tocitem" href="../vis/">Visualization</a></li><li><a class="tocitem" href="../glasscat/">Glass Functions</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#OpticSim"><span>OpticSim</span></a></li><li><a class="tocitem" href="#Zernike"><span>Zernike</span></a></li><li><a class="tocitem" href="#QType"><span>QType</span></a></li><li><a class="tocitem" href="#Chebyshev"><span>Chebyshev</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/microsoft/OpticSim.jl/blob/master/docs/src/ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Complete-Reference"><a class="docs-heading-anchor" href="#Complete-Reference">Complete Reference</a><a id="Complete-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Reference" title="Permalink"></a></h1><p>This page contains what should be a complete list of all docstrings in the OpticSim module, and its submodule.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#OpticSim.Chebyshev"><code>OpticSim.Chebyshev</code></a></li><li><a href="#OpticSim.Examples"><code>OpticSim.Examples</code></a></li><li><a href="#OpticSim.QType"><code>OpticSim.QType</code></a></li><li><a href="#OpticSim.Zernike"><code>OpticSim.Zernike</code></a></li><li><a href="#OpticSim.AbstractRayDirectionDistribution"><code>OpticSim.AbstractRayDirectionDistribution</code></a></li><li><a href="#OpticSim.AbstractSpectrum"><code>OpticSim.AbstractSpectrum</code></a></li><li><a href="#OpticSim.BSplineCurve"><code>OpticSim.BSplineCurve</code></a></li><li><a href="#OpticSim.BeamState"><code>OpticSim.BeamState</code></a></li><li><a href="#OpticSim.BezierCurve"><code>OpticSim.BezierCurve</code></a></li><li><a href="#OpticSim.CircularStopShape"><code>OpticSim.CircularStopShape</code></a></li><li><a href="#OpticSim.CurveType"><code>OpticSim.CurveType</code></a></li><li><a href="#OpticSim.GridSagInterpolation"><code>OpticSim.GridSagInterpolation</code></a></li><li><a href="#OpticSim.KnotVector"><code>OpticSim.KnotVector</code></a></li><li><a href="#OpticSim.MeasuredSpectrum"><code>OpticSim.MeasuredSpectrum</code></a></li><li><a href="#OpticSim.Primitive"><code>OpticSim.Primitive</code></a></li><li><a href="#OpticSim.RayState"><code>OpticSim.RayState</code></a></li><li><a href="#OpticSim.RectangularStopShape"><code>OpticSim.RectangularStopShape</code></a></li><li><a href="#OpticSim.Source"><code>OpticSim.Source</code></a></li><li><a href="#OpticSim.Spline"><code>OpticSim.Spline</code></a></li><li><a href="#OpticSim.SplineSurface"><code>OpticSim.SplineSurface</code></a></li><li><a href="#OpticSim.StopSurface"><code>OpticSim.StopSurface</code></a></li><li><a href="#OpticSim.UniformSpectrum"><code>OpticSim.UniformSpectrum</code></a></li><li><a href="#OpticSim.ZernikeIndexType"><code>OpticSim.ZernikeIndexType</code></a></li><li><a href="#OpticSim.Annulus-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.Annulus</code></a></li><li><a href="#OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ArizonaEye</code></a></li><li><a href="#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass"><code>OpticSim.AsphericLens</code></a></li><li><a href="#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real"><code>OpticSim.BoundedCylinder</code></a></li><li><a href="#OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.T</code></a></li><li><a href="#OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.U</code></a></li><li><a href="#OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.dTdq</code></a></li><li><a href="#OpticSim.Circle-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.Circle</code></a></li><li><a href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a></li><li><a href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a></li><li><a href="#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S,S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass"><code>OpticSim.ConicLens</code></a></li><li><a href="#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Real"><code>OpticSim.Cuboid</code></a></li><li><a href="#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G,T,T,T,T,T}} where H&lt;:OpticSim.GlassCat.AbstractGlass where G&lt;:OpticSim.GlassCat.AbstractGlass where T&lt;:Real"><code>OpticSim.FresnelLens</code></a></li><li><a href="#OpticSim.GivensRotation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Real"><code>OpticSim.GivensRotation</code></a></li><li><a href="#OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C&lt;:(CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number)}, Tuple{T}} where T&lt;:Real"><code>OpticSim.GridField</code></a></li><li><a href="#OpticSim.GridField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.GridField</code></a></li><li><a href="#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real"><code>OpticSim.HexagonalPrism</code></a></li><li><a href="#OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C&lt;:(CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number)}, Tuple{T}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a></li><li><a href="#OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a></li><li><a href="#OpticSim.JacobiSVD-Union{Tuple{T}, Tuple{Bool,AbstractArray{T,2}}} where T&lt;:Real"><code>OpticSim.JacobiSVD</code></a></li><li><a href="#OpticSim.JacobiSVD!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.JacobiSVD!</code></a></li><li><a href="#OpticSim.JacobiSVD!-Union{Tuple{T}, Tuple{Bool,AbstractArray{T,2}}} where T&lt;:Real"><code>OpticSim.JacobiSVD!</code></a></li><li><a href="#OpticSim.JacobiSolve-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,1}}} where T&lt;:Real"><code>OpticSim.JacobiSolve</code></a></li><li><a href="#OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where D&lt;:Real where T&lt;:Real"><code>OpticSim.ModelEye</code></a></li><li><a href="#OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.S</code></a></li><li><a href="#OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.S0</code></a></li><li><a href="#OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.dS0dx</code></a></li><li><a href="#OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.dSdx</code></a></li><li><a href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a></li><li><a href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a></li><li><a href="#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,T}} where T&lt;:Real"><code>OpticSim.RectangularPrism</code></a></li><li><a href="#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass"><code>OpticSim.SphericalLens</code></a></li><li><a href="#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64,T,T}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3}}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.Spider</code></a></li><li><a href="#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real"><code>OpticSim.TriangularPrism</code></a></li><li><a href="#OpticSim.Zernike.NolltoNM-Tuple{Int64}"><code>OpticSim.Zernike.NolltoNM</code></a></li><li><a href="#OpticSim.Zernike.OSAtoNM-Tuple{Int64}"><code>OpticSim.Zernike.OSAtoNM</code></a></li><li><a href="#OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64,Int64,T}} where T&lt;:Real"><code>OpticSim.Zernike.R</code></a></li><li><a href="#OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T},Int64,Int64}} where T&lt;:Real"><code>OpticSim.Zernike.normalisation</code></a></li><li><a href="#OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real"><code>OpticSim.Zernike.δζ</code></a></li><li><a href="#OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real"><code>OpticSim.Zernike.ζ</code></a></li><li><a href="#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.assembly</code></a></li><li><a href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a></li><li><a href="#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T"><code>OpticSim.closestpointonray</code></a></li><li><a href="#OpticSim.csgdifference-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.csgdifference</code></a></li><li><a href="#OpticSim.csgintersection-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.csgintersection</code></a></li><li><a href="#OpticSim.csgunion-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.csgunion</code></a></li><li><a href="#OpticSim.curvedimension-Tuple{Array}"><code>OpticSim.curvedimension</code></a></li><li><a href="#OpticSim.curveorder-Tuple{Array}"><code>OpticSim.curveorder</code></a></li><li><a href="#OpticSim.detectorimage-Tuple{CSGOpticalSystem}"><code>OpticSim.detectorimage</code></a></li><li><a href="#OpticSim.direction-Union{Tuple{T}, Tuple{P}, Tuple{O}, Tuple{S}, Tuple{Source{T,S,O,ConeDistribution{T},P},Int64}} where T&lt;:Real where P where O where S"><code>OpticSim.direction</code></a></li><li><a href="#OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T"><code>OpticSim.distance</code></a></li><li><a href="#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T&lt;:Real"><code>OpticSim.doesintersect</code></a></li><li><a href="#OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Array{T,2},Real}} where T&lt;:Real"><code>OpticSim.evaluatecurve</code></a></li><li><a href="#OpticSim.extractmovinglines-NTuple{4,Any}"><code>OpticSim.extractmovinglines</code></a></li><li><a href="#OpticSim.fresnel-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Real"><code>OpticSim.fresnel</code></a></li><li><a href="#OpticSim.gendirection-Tuple{RandomSource,Int64}"><code>OpticSim.gendirection</code></a></li><li><a href="#OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{BasicDisplayPanel{T,P},Int64}} where P where T&lt;:Real"><code>OpticSim.generateray</code></a></li><li><a href="#OpticSim.generateray-Union{Tuple{T}, Tuple{OpticalSourceGroup{T},Int64}} where T&lt;:Real"><code>OpticSim.generateray</code></a></li><li><a href="#OpticSim.generateray-Union{Tuple{C}, Tuple{P}, Tuple{T}, Tuple{PixelSource{T,P,C},Int64}} where C where P where T&lt;:Real"><code>OpticSim.generateray</code></a></li><li><a href="#OpticSim.generateray-Union{Tuple{S}, Tuple{T}, Tuple{OpticalSourceArray{T,S},Int64}} where S where T&lt;:Real"><code>OpticSim.generateray</code></a></li><li><a href="#OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{UniformOpticalSource{T,P,P1} where P1&lt;:GeometricRayGenerator{T,P},Int64}} where P where T&lt;:Real"><code>OpticSim.generateray</code></a></li><li><a href="#OpticSim.generateray-Union{Tuple{O}, Tuple{T}, Tuple{GeometricRayGenerator{T,O},Int64}} where O where T&lt;:Real"><code>OpticSim.generateray</code></a></li><li><a href="#OpticSim.genorigin-Tuple{OriginPoint,Int64}"><code>OpticSim.genorigin</code></a></li><li><a href="#OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.halfspaceintersection</code></a></li><li><a href="#OpticSim.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.identitytransform</code></a></li><li><a href="#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T,N,S} where S&lt;:ParametricSurface{T,N} where N}, Tuple{T}} where T&lt;:Real"><code>OpticSim.interface</code></a></li><li><a href="#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,2}}} where N where T&lt;:Real"><code>OpticSim.intersections</code></a></li><li><a href="#OpticSim.isemptyinterval-Tuple{EmptyInterval}"><code>OpticSim.isemptyinterval</code></a></li><li><a href="#OpticSim.isinfinity-Tuple{Infinity}"><code>OpticSim.isinfinity</code></a></li><li><a href="#OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ispositivehalfspace</code></a></li><li><a href="#OpticSim.israyorigin-Tuple{Any}"><code>OpticSim.israyorigin</code></a></li><li><a href="#OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.israyorigininterval</code></a></li><li><a href="#OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},T,T,StaticArrays.SArray{Tuple{M},T,1,M},StaticArrays.SArray{Tuple{M},T,1,M}}} where M where N where T&lt;:Real"><code>OpticSim.jacobian</code></a></li><li><a href="#OpticSim.leaf-Union{Tuple{S}, Tuple{T}, Tuple{S,RigidBodyTransform{T}}} where S&lt;:(ParametricSurface{T,N} where N) where T&lt;:Real"><code>OpticSim.leaf</code></a></li><li><a href="#OpticSim.leaf-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.leaf</code></a></li><li><a href="#OpticSim.linedimension-Tuple{Array}"><code>OpticSim.linedimension</code></a></li><li><a href="#OpticSim.makemesh-Union{Tuple{ParametricSurface{S,N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S,N},Int64}} where N where S"><code>OpticSim.makemesh</code></a></li><li><a href="#OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,3}}} where N where T"><code>OpticSim.matricesforeigen</code></a></li><li><a href="#OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},AbstractRay{T,N},StaticArrays.SArray{Tuple{2},T,1,2}}} where N where T"><code>OpticSim.newton</code></a></li><li><a href="#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real"><code>OpticSim.normal</code></a></li><li><a href="#OpticSim.numberoflines-Tuple{Array}"><code>OpticSim.numberoflines</code></a></li><li><a href="#OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Array{T,2},Any}} where T"><code>OpticSim.orthogonalitymatrix</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T,N},T}} where T&lt;:Real where N"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.pressure</code></a></li><li><a href="#OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool,Bool}} where N where T&lt;:Real"><code>OpticSim.processintersection</code></a></li><li><a href="#OpticSim.randinsolidangle-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},T}} where T&lt;:Real"><code>OpticSim.randinsolidangle</code></a></li><li><a href="#OpticSim.raysample-Union{Tuple{P}, Tuple{D}, Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Source{T,S,O,D,P},OpticSim.RayState}} where P where D where O where S where T"><code>OpticSim.raysample</code></a></li><li><a href="#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T"><code>OpticSim.reset!</code></a></li><li><a href="#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.resetdetector!</code></a></li><li><a href="#OpticSim.reversenormal-Union{Tuple{Intersection{T,N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Real"><code>OpticSim.reversenormal</code></a></li><li><a href="#OpticSim.rotation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotation</code></a></li><li><a href="#OpticSim.rotationd-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotationd</code></a></li><li><a href="#OpticSim.rotmat-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotmat</code></a></li><li><a href="#OpticSim.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Number"><code>OpticSim.rotmatbetween</code></a></li><li><a href="#OpticSim.rotmatd-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotmatd</code></a></li><li><a href="#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Function}, Tuple{ParametricSurface{T,N},Function,Int64}} where N where T&lt;:Real"><code>OpticSim.samplesurface</code></a></li><li><a href="#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}"><code>OpticSim.semidiameter</code></a></li><li><a href="#OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S,S,T,T}} where S&lt;:(AbstractArray{T,N} where N) where T&lt;:Real"><code>OpticSim.snell</code></a></li><li><a href="#OpticSim.spectrumpower-Union{Tuple{T}, Tuple{MeasuredSpectrum{T},T}} where T&lt;:Real"><code>OpticSim.spectrumpower</code></a></li><li><a href="#OpticSim.spectrumsample-Union{Tuple{Source{T,UniformSpectrum{T},O,D,P}}, Tuple{T}, Tuple{P}, Tuple{D}, Tuple{O}} where T where P where D where O"><code>OpticSim.spectrumsample</code></a></li><li><a href="#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T},HierarchicalImage{T}}} where T"><code>OpticSim.sum!</code></a></li><li><a href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S} where S&lt;:ParametricSurface{T,N},AbstractRay{T,N}}} where N where T"><code>OpticSim.surfaceintersection</code></a></li><li><a href="#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.temperature</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T},OpticalRay{T,N}}} where D&lt;:Number where N where T&lt;:Real"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T},OpticalRay{T,N}}, Tuple{LensAssembly{T},OpticalRay{T,N},T}, Tuple{LensAssembly{T},OpticalRay{T,N},T,T}} where N where T&lt;:Real"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T,S,S1,L} where L&lt;:LensAssembly{T} where S1&lt;:Surface{T},OpticalRayGenerator{T}}} where S&lt;:Number where T&lt;:Real"><code>OpticSim.traceMT</code></a></li><li><a href="#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehits</code></a></li><li><a href="#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehitsMT</code></a></li><li><a href="#OpticSim.translation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.translation</code></a></li><li><a href="#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Int64}, Tuple{ParametricSurface{T,N},Int64,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool,Bool}} where N where T"><code>OpticSim.triangulate</code></a></li><li><a href="#OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S},AbstractRay{T,N}}} where S where N where T&lt;:Real"><code>OpticSim.triangulatedintersection</code></a></li><li><a href="#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real"><code>OpticSim.uv</code></a></li><li><a href="#OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface"><code>OpticSim.uvrange</code></a></li><li><a href="#OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T},StaticArrays.SArray{Tuple{2},T,1,2},Tuple{Int64,Int64}}} where T&lt;:Real"><code>OpticSim.uvtopix</code></a></li><li><a href="#OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T&lt;:Real"><code>OpticSim.α</code></a></li></ul><h2 id="OpticSim"><a class="docs-heading-anchor" href="#OpticSim">OpticSim</a><a id="OpticSim-1"></a><a class="docs-heading-anchor-permalink" href="#OpticSim" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.AbstractRayDirectionDistribution" href="#OpticSim.AbstractRayDirectionDistribution"><code>OpticSim.AbstractRayDirectionDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Every ray direction distribution must implement the functions direction(a::Source)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.AbstractSpectrum" href="#OpticSim.AbstractSpectrum"><code>OpticSim.AbstractSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Each AbstractSpectrum type defines a spectrumSample function which returns a uniformly sampled point from the spectrum of the light source and the power at that wavelength.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BSplineCurve" href="#OpticSim.BSplineCurve"><code>OpticSim.BSplineCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSplineCurve{P,S,N,M} &lt;: Spline{P,S,N,M}</code></pre><p><code>N</code> is the spatial dimension of the curve. <code>M</code> is the curve order, i.e., the highest power of the parameterizing variable, <code>u</code>. All curve segments are assumed to be of the same order.</p><pre><code class="language-julia">BSplineCurve{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{MVector{N,S},1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Curves/BSpline.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BeamState" href="#OpticSim.BeamState"><code>OpticSim.BeamState</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ConvergingBeam</code>, <code>DivergingBeam</code> or <code>CollimatedBeam</code>, defines the behavior of a beam in a <a href="../interfaces/#OpticSim.HologramInterface"><code>HologramInterface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BezierCurve" href="#OpticSim.BezierCurve"><code>OpticSim.BezierCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BezierCurve{P,S,N,M} &lt;: Spline{P,S,N,M}</code></pre><p><code>N</code> is the dimension of the curve, <code>M</code> is the curve order</p><pre><code class="language-julia">BezierCurve{P,S,N,M}(controlpoints::AbstractArray{&lt;:AbstractArray{S,1},1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Curves/Bezier.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularStopShape" href="#OpticSim.CircularStopShape"><code>OpticSim.CircularStopShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CircularStopShape &lt;: StopShape</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CurveType" href="#OpticSim.CurveType"><code>OpticSim.CurveType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Either <code>Rational</code> or <code>Euclidean</code>, used for <a href="#OpticSim.Spline"><code>Spline</code></a>s and <a href="#OpticSim.SplineSurface"><code>SplineSurface</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Curves/Spline.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridSagInterpolation" href="#OpticSim.GridSagInterpolation"><code>OpticSim.GridSagInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Either <code>GridSagLinear</code> or <code>GridSagBicubic</code> - determines the interpolation between sample points in the grid for a <a href="../primitives/#OpticSim.GridSagSurface"><code>GridSagSurface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.KnotVector" href="#OpticSim.KnotVector"><code>OpticSim.KnotVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KnotVector{T&lt;:Number}</code></pre><p>Vector to define knots used for <a href="#OpticSim.BSplineCurve"><code>BSplineCurve</code></a> and <a href="../primitives/#OpticSim.BSplineSurface"><code>BSplineSurface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Curves/Knots.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.MeasuredSpectrum" href="#OpticSim.MeasuredSpectrum"><code>OpticSim.MeasuredSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Use measured spectrum to compute emitter power. Create spectrum by reading CSV files.</p><p>Evaluate spectrum at arbitrary wavelength with <a href="#OpticSim.spectrumpower-Union{Tuple{T}, Tuple{MeasuredSpectrum{T},T}} where T&lt;:Real"><code>spectrumpower</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Primitive" href="#OpticSim.Primitive"><code>OpticSim.Primitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Primitive{T&lt;:Real}</code></pre><p><code>T</code> is the number type used to represent the primitive,  e.g., <code>Float64</code>. Primitives are the basic elements which can be stored in bounding volume hierarchies and include surfaces and CSG objects</p><p><strong>Must</strong> implement the following:</p><pre><code class="language-julia">boundingbox(a::Primitive{T})::BoundingBox{T}
centroid(a::Primitive{T})::SVector{3,T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RayState" href="#OpticSim.RayState"><code>OpticSim.RayState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>stores the state of ray generation. Keeps track of ray number so you can have a PointOrigin which emits multiple rays. This can be used in the future to do phase summations on the image plane, since only point sources are perfectly spatially coherent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularStopShape" href="#OpticSim.RectangularStopShape"><code>OpticSim.RectangularStopShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectangularStopShape &lt;: StopShape</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Source" href="#OpticSim.Source"><code>OpticSim.Source</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Create an emitter by choosing a type for the spectral distribution, ray origin distribution, ray direction distribution, and angular light power distribution. For example, to create an emitter with uniform spectrum, rays originating on a regular grid, ray directions distributed around a vector v up to a maximum angle θmax, with Lambertian power distribution call the Source construction with these types and arguments:</p><p>a = Source{UniformSpectrum,GridOrigin, ConeDistribution, Lambertian}(UniformSpectrum(),GridOrigin(),ConeDistribution(θmax),Lambertian())</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Spline" href="#OpticSim.Spline"><code>OpticSim.Spline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Spline{P&lt;:CurveType,S&lt;:Number,N,M}</code></pre><p><code>M</code> is the curve order, i.e., the highest power of the parameterizing variable, u. <code>P</code> determines the <a href="#OpticSim.CurveType"><code>CurveType</code></a>.</p><p>All Spline types must implement:</p><pre><code class="language-julia">point(curve,u)</code></pre><p>and have field <code>controlpolygon</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Curves/Spline.jl#L31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.SplineSurface" href="#OpticSim.SplineSurface"><code>OpticSim.SplineSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SplineSurface{P,S,N,M} &lt;: ParametricSurface{S,N}</code></pre><p>Curve order, <code>M</code>, is the same in the u and v direction and fixed over all spans. <code>P</code> determines the <a href="#OpticSim.CurveType"><code>CurveType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Curves/Spline.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.StopSurface" href="#OpticSim.StopSurface"><code>OpticSim.StopSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StopSurface{T} &lt;: Surface{T}</code></pre><p>Abstract type to encapsulate any surfaces acting as a stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.UniformSpectrum" href="#OpticSim.UniformSpectrum"><code>OpticSim.UniformSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>flat spectrum from 450nm to 680nm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ZernikeIndexType" href="#OpticSim.ZernikeIndexType"><code>OpticSim.ZernikeIndexType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Either <code>ZernikeIndexingOSA</code> or <code>ZernikeIndexingNoll</code>, see <a href="https://en.wikipedia.org/wiki/Zernike_polynomials">Zernike polynomials wikipedia entry</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Annulus-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.Annulus-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.Annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a circle i.e. <code>FiniteStop{T,CircularStopShape,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ArizonaEye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)</code></pre><p>The popular Arizona eye model taken from <a href="https://photonengr.com/wp-content/uploads/kbasefiles/ArizonaEyeModel.pdf">this definition</a>. The <code>accommodation</code> of the eye can be varied in this model. Returns a <code>DataFrame</code> specifying the prescription of the eye model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Eye.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass" href="#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S,Union{Nothing, Array{Tuple{Int64,S},1}},S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass"><code>OpticSim.AsphericLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))</code></pre><p>Cosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Lenses.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real" href="#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real"><code>OpticSim.BoundedCylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cylinder with planar caps on both ends centred at <code>(0, 0, 0)</code> with axis <code>(0, 0, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Geometry.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Circle-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.Circle-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.Circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))</code></pre><p>Shortcut method to create a circle. The minimal case returns a circle centred at the origin with <code>normal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Ellipse.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a plane i.e. <code>InfiniteStop{T,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a circular aperture in a rectangle i.e. <code>FiniteStop{T,CircularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L242-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S,S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass" href="#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S,S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass"><code>OpticSim.ConicLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))</code></pre><p>Constructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Lenses.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Cuboid-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Real" href="#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Real"><code>OpticSim.Cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cuboid centred at <code>(0, 0, 0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Geometry.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G,T,T,T,T,T}} where H&lt;:OpticSim.GlassCat.AbstractGlass where G&lt;:OpticSim.GlassCat.AbstractGlass where T&lt;:Real" href="#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G,T,T,T,T,T}} where H&lt;:OpticSim.GlassCat.AbstractGlass where G&lt;:OpticSim.GlassCat.AbstractGlass where T&lt;:Real"><code>OpticSim.FresnelLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = OpticSim.GlassCat.Air)</code></pre><p>Create a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on <code>groovedepth</code>. For negative radii the vertex on the central surface is at <code>frontvertex</code>, so the total thickness of the lens is <code>thickness</code> + <code>groovedepth</code>. <strong>Aspherics currently not supported</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Lenses.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GivensRotation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Real" href="#OpticSim.GivensRotation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Real"><code>OpticSim.GivensRotation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>this version will always perform iterations to high relative accuracy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Matrix.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C&lt;:(CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number)}, Tuple{T}} where T&lt;:Real" href="#OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C&lt;:(CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number)}, Tuple{T}} where T&lt;:Real"><code>OpticSim.GridField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over the entrance pupil of the system in a rectangular grid pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fields.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.GridField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.GridField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridField(semidiameter, pupilpos; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over a circular pupil with half-diameter defined by <code>semidiameter</code>, centred at <code>pupilpos</code> in a rectangular grid pattern. <code>samples</code> is the number of rays on each side of the grid, so there are <code>samples×samples</code> rays in total.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fields.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real" href="#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real"><code>OpticSim.HexagonalPrism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall hexagonal prism with axis <code>(0, 0, 1)</code>, the longer hexagon diameter is along the x axis. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Geometry.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C&lt;:(CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number)}, Tuple{T}} where T&lt;:Real" href="#OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T,C} where C&lt;:(CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number)}, Tuple{T}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HexapolarField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over the entrance pupil of the system in a hexapolar pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fields.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T,StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HexapolarField(semidiameter, pupilpos; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over a circular pupil with half-diameter defined by <code>semidiameter</code>, centred at <code>pupilpos</code> in a hexapolar pattern. <code>samples</code> is the number of rings in the hexapolar pattern, so the number of rays in total is <code>samples * (samples + 1) / 2) * 6 + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fields.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.JacobiSVD!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.JacobiSVD!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.JacobiSVD!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sets flag to compute singular values to high relative accuracy. DESTRUCTIVE: matrix A is overwritten</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Matrix.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.JacobiSVD!-Union{Tuple{T}, Tuple{Bool,AbstractArray{T,2}}} where T&lt;:Real" href="#OpticSim.JacobiSVD!-Union{Tuple{T}, Tuple{Bool,AbstractArray{T,2}}} where T&lt;:Real"><code>OpticSim.JacobiSVD!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>DESTRUCTIVE: matrix A is overwritten. Returns U,sigma,V (not V&#39;), iterationsexceeded   where iterationsexceeded will be either :exceededMax or :didNotExceedMax. If max iterations was exceeded it is possible the result is not accurate. But the results might also be fine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Matrix.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.JacobiSVD-Union{Tuple{T}, Tuple{Bool,AbstractArray{T,2}}} where T&lt;:Real" href="#OpticSim.JacobiSVD-Union{Tuple{T}, Tuple{Bool,AbstractArray{T,2}}} where T&lt;:Real"><code>OpticSim.JacobiSVD</code></a> — <span class="docstring-category">Method</span></header><section><div><p>DESTRUCTIVE: matrix A is overwritten. Returns U,sigma,V (not V&#39;), iterationsexceeded   where iterationsexceeded will be either :exceededMax or :didNotExceedMax. If max iterations was exceeded it is possible the result is not accurate. But the results might also be fine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Matrix.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.JacobiSolve-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,1}}} where T&lt;:Real" href="#OpticSim.JacobiSolve-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,1}}} where T&lt;:Real"><code>OpticSim.JacobiSolve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>use this version if you want to handle exceeding maximum number of iterations. DESTRUCTIVE: matrix A is overwritten. powerPercentage must be be between 0 and 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Matrix.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where D&lt;:Real where T&lt;:Real" href="#OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where D&lt;:Real where T&lt;:Real"><code>OpticSim.ModelEye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::RigidBodyTransform{T} = identitytransform(T))</code></pre><p>Geometrically accurate model of the human eye focussed at infinity with variable <code>pupil_radius</code>. The eye is added to the provided <code>assembly</code> to create a <a href="../systems/#OpticSim.CSGOpticalSystem"><code>CSGOpticalSystem</code></a> with the retina of the eye as the detector.</p><p>The eye can be positioned in the scene using the <code>transform</code> argument and the resolution of the detector specified with <code>detpixels</code>. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.</p><p><code>nsamples</code> determines the resolution at which accelerated surfaces within the eye are triangulated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Eye.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a plane i.e. <code>InfiniteStop{T,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T,T,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a rectangle i.e. <code>FiniteStop{T,RectangularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Stop.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,T}} where T&lt;:Real" href="#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,T}} where T&lt;:Real"><code>OpticSim.RectangularPrism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall rectangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Geometry.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass" href="#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T,S,S,S,S,S}} where S&lt;:Real where T&lt;:OpticSim.GlassCat.AbstractGlass where Q&lt;:OpticSim.GlassCat.AbstractGlass where R&lt;:OpticSim.GlassCat.AbstractGlass"><code>OpticSim.SphericalLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0))</code></pre><p>Constructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Lenses.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Spider-Union{Tuple{T}, Tuple{Int64,T,T}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3}}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real" href="#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64,T,T}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3}}, Tuple{Int64,T,T,StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Real"><code>OpticSim.Spider</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -&gt; Vector{Rectangle{T}}</code></pre><p>Creates a &#39;spider&#39; obscuration with <code>narms</code> rectangular arms evenly spaced around a circle defined by <code>origin</code> and <code>normal</code>. Each arm is a rectangle <code>armwidth</code>×<code>radius</code>.</p><p>e.g. for 3 and 4 arms we get:</p><pre><code class="language-none">   |         _|_
  / \         |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Geometry.jl#L158-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real" href="#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Real"><code>OpticSim.TriangularPrism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall triangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Geometry.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real" href="#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.assembly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assembly(system::OpticalSystem{T}) -&gt; LensAssembly{T}</code></pre><p>Get the <a href="#OpticSim.LensAssembly"><code>LensAssembly</code></a> of <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.closestintersection" href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -&gt; Union{Nothing,Intersection{T,3}}</code></pre><p>Returns the closest <a href="#OpticSim.Intersection"><code>Intersection</code></a> from an <a href="#OpticSim.Interval"><code>Interval</code></a> or <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a>. Ignores intersection with null interfaces if <code>ignorenull</code> is true. Will return <code>nothing</code> if there is no valid intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Interval.jl#L288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T" href="#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T"><code>OpticSim.closestpointonray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">closestpointonray(r::Ray{T,N}, point::SVector{N,T}) -&gt; SVector{T,N</code></pre><p>Returns the point on the ray closest to point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Ray.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.csgdifference-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real" href="#OpticSim.csgdifference-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.csgdifference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">csgdifference(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a binary node in the CSG tree representing the difference of a and b, essentially a - b. A shortcut method for <code>a</code> and <code>b</code> as <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s is also available.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/86/Boolean_difference.PNG" alt="Difference Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/CSG.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.csgintersection-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real" href="#OpticSim.csgintersection-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.csgintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">csgintersection(a::CSGGenerator{T} b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a binary node in the CSG tree representing an intersection between a and b. A shortcut method for <code>a</code> and <code>b</code> as <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s is also available.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Boolean_intersect.PNG" alt="Intersect Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/CSG.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.csgunion-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real" href="#OpticSim.csgunion-Union{Tuple{T}, Tuple{CSGGenerator{T},CSGGenerator{T}}, Tuple{CSGGenerator{T},CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.csgunion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">csgunion(a::CSGGenerator{T}, b::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a binary node in the CSG tree representing a union between a and b. A shortcut method for <code>a</code> and <code>b</code> as <a href="../primitives/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s is also available.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4a/Boolean_union.PNG" alt="Union Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/CSG.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.curvedimension-Tuple{Array}" href="#OpticSim.curvedimension-Tuple{Array}"><code>OpticSim.curvedimension</code></a> — <span class="docstring-category">Method</span></header><section><div><p>spatial dimension of curve represented as an array of coefficients <code>x[i] = ∑Bj(θ)*x[i,j]</code> where <code>Bj(θ)</code> is the curve basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.curveorder-Tuple{Array}" href="#OpticSim.curveorder-Tuple{Array}"><code>OpticSim.curveorder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>highest polynomial power of the curve represented as an array of coefficients <code>x[i] = ∑Bj(θ)*x[i,j]</code> where <code>Bj(θ)</code> is the curve basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.detectorimage-Tuple{CSGOpticalSystem}" href="#OpticSim.detectorimage-Tuple{CSGOpticalSystem}"><code>OpticSim.detectorimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">detectorimage(system::OpticalSystem{T}) -&gt; HierarchicalImage{D}</code></pre><p>Get the detector image of <code>system</code>. <code>D</code> is the datatype of the detector image and is not necessarily the same as the datatype of the system <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.direction-Union{Tuple{T}, Tuple{P}, Tuple{O}, Tuple{S}, Tuple{Source{T,S,O,ConeDistribution{T},P},Int64}} where T&lt;:Real where P where O where S" href="#OpticSim.direction-Union{Tuple{T}, Tuple{P}, Tuple{O}, Tuple{S}, Tuple{Source{T,S,O,ConeDistribution{T},P},Int64}} where T&lt;:Real where P where O where S"><code>OpticSim.direction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generates a unit vector pointing somewhere within the cone with half angle <code>θmax</code> around <code>direction</code> which is the normal to the emitter surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L228-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T" href="#OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T"><code>OpticSim.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(r::Ray{T,N}, point::SVector{N,T}) -&gt; Union{T,Nothing}</code></pre><p>Returns distance to the position on the ray closest to point. If t &lt; 0 returns nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Ray.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T&lt;:Real" href="#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T},AbstractRay{T,3}}} where T&lt;:Real"><code>OpticSim.doesintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -&gt; Bool</code></pre><p>Tests whether <code>r</code> intersects an axis-aligned <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a>, <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/BoundingBox.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Array{T,2},Real}} where T&lt;:Real" href="#OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Array{T,2},Real}} where T&lt;:Real"><code>OpticSim.evaluatecurve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluates a curve defined in the power basis. Curves and moving lines accessed like this: <code>[xi,ci]</code> where <code>xi</code> is the dimension index, and <code>ci</code> is the coefficient index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.extractmovinglines-NTuple{4,Any}" href="#OpticSim.extractmovinglines-NTuple{4,Any}"><code>OpticSim.extractmovinglines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns 3D array indexed like this: <code>x[line curve order,spatial dimension, line number]</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.fresnel-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Real" href="#OpticSim.fresnel-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Real"><code>OpticSim.fresnel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fresnel(nᵢ::T, nₜ::T, sinθᵢ::T, sinθₜ::T) -&gt; Tuple{T,T}</code></pre><p>Returns reflectance and tranmission power coefficients according to the <a href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel equations</a>. For geometric ray tracing this coefficient can be used directly to compute intensity on the detector plane. For Huygens phase optics need to take the square root to compute the amplitude. The power of the transmitted and refracted rays may not sum to one because of the area correction applied to the transmitted component. The intensity per area can increase or decrease depending on the indices of refraction.</p><p><code>nᵢ</code> is the RI of the material which the incident ray travels in, <code>nₜ</code> is the RI of the material the transmitted ray travels in. <code>sinθᵢ</code> and <code>sinθₜ</code> are the sin of the angles of incidence and transmission respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fresnel.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.gendirection-Tuple{RandomSource,Int64}" href="#OpticSim.gendirection-Tuple{RandomSource,Int64}"><code>OpticSim.gendirection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gendirection(o::GeometricRayGenerator{T}, n::Int) -&gt; SVector{3,T}</code></pre><p>Generate directions for rays based on the type of the generator, e.g., randomly within a cone or collimated. <code>n</code> is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for <code>GridSource</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L318-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.generateray-Union{Tuple{C}, Tuple{P}, Tuple{T}, Tuple{PixelSource{T,P,C},Int64}} where C where P where T&lt;:Real" href="#OpticSim.generateray-Union{Tuple{C}, Tuple{P}, Tuple{T}, Tuple{PixelSource{T,P,C},Int64}} where C where P where T&lt;:Real"><code>OpticSim.generateray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateray(a::PixelSource{T}, n::Int) -&gt; OpticalRay{T,3}</code></pre><p>Generates optical rays from all subpixels in the pixel. One ray is generated from each subpixel sequentially before looping back to the start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L511-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.generateray-Union{Tuple{O}, Tuple{T}, Tuple{GeometricRayGenerator{T,O},Int64}} where O where T&lt;:Real" href="#OpticSim.generateray-Union{Tuple{O}, Tuple{T}, Tuple{GeometricRayGenerator{T,O},Int64}} where O where T&lt;:Real"><code>OpticSim.generateray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateray(o::GeometricRayGenerator{T}, n::Int) -&gt; Ray{T,3}</code></pre><p>Generate geometric rays distributed according to the type of the generator. <code>n</code> is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for <code>GridSource</code>, for example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L337-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{BasicDisplayPanel{T,P},Int64}} where P where T&lt;:Real" href="#OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{BasicDisplayPanel{T,P},Int64}} where P where T&lt;:Real"><code>OpticSim.generateray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateray(a::BasicDisplayPanel{T}, n::Int) -&gt; OpticalRay{T,3}</code></pre><p>Generates optical rays from all pixels in the display. One ray is generated from each pixel sequentially before looping back to the start of the display.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L612-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{UniformOpticalSource{T,P,P1} where P1&lt;:GeometricRayGenerator{T,P},Int64}} where P where T&lt;:Real" href="#OpticSim.generateray-Union{Tuple{P}, Tuple{T}, Tuple{UniformOpticalSource{T,P,P1} where P1&lt;:GeometricRayGenerator{T,P},Int64}} where P where T&lt;:Real"><code>OpticSim.generateray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateray(o::OpticalRayGenerator{T}, n::Int) -&gt; OpticalRay{T,3}</code></pre><p>Generate optical rays distributed according to the type of the generator. <code>n</code> is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for generators using <code>GridSource</code> or <code>GridRectOriginPoints</code>, for example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L452-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.generateray-Union{Tuple{S}, Tuple{T}, Tuple{OpticalSourceArray{T,S},Int64}} where S where T&lt;:Real" href="#OpticSim.generateray-Union{Tuple{S}, Tuple{T}, Tuple{OpticalSourceArray{T,S},Int64}} where S where T&lt;:Real"><code>OpticSim.generateray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateray(a::OpticalSourceArray{T}, n::Int) -&gt; OpticalRay{T,3}</code></pre><p>Generates optical rays from all generators in the array. One ray is generated from each element sequentially before looping back to the start of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L552-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.generateray-Union{Tuple{T}, Tuple{OpticalSourceGroup{T},Int64}} where T&lt;:Real" href="#OpticSim.generateray-Union{Tuple{T}, Tuple{OpticalSourceGroup{T},Int64}} where T&lt;:Real"><code>OpticSim.generateray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateray(a::OpticalSourceGroup{T}, n::Int) -&gt; OpticalRay{T,3}</code></pre><p>Generate optical rays for each source in the group. All rays are generated for the first source, then all for the second source and so on as <code>n</code> increases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L678-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.genorigin-Tuple{OriginPoint,Int64}" href="#OpticSim.genorigin-Tuple{OriginPoint,Int64}"><code>OpticSim.genorigin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">genorigin(o::RayOriginGenerator{T}, n::Int) -&gt; SVector{3,T}</code></pre><p>Generate origin positions for rays based on the type of the generator, e.g., randomly within a rectangle or ellipse. <code>n</code> is the index of the point being generated, starting from 0. This has little meaning for random generators, but is important for <code>HexapolarOriginPoints</code> and <code>GridRectOriginPoints</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.halfspaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">halfspaceintersection(a::Interval{T}) -&gt; Intersection{T,3}</code></pre><p>Returns the <a href="#OpticSim.Intersection"><code>Intersection</code></a> from a half space <a href="#OpticSim.Interval"><code>Interval</code></a>, throws an error if not a half space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Interval.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.identitytransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">identitytransform([S::Type]) -&gt; RigidBodyTransform{S}</code></pre><p>Returns the <a href="../csg/#OpticSim.RigidBodyTransform"><code>RigidBodyTransform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the identity transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T,N,S} where S&lt;:ParametricSurface{T,N} where N}, Tuple{T}} where T&lt;:Real" href="#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T,N,S} where S&lt;:ParametricSurface{T,N} where N}, Tuple{T}} where T&lt;:Real"><code>OpticSim.interface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interface(surf::Surface{T}) -&gt; OpticalInterface{T}</code></pre><p>Return the <a href="../interfaces/#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> associated with <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AccelSurface.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,2}}} where N where T&lt;:Real" href="#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,2}}} where N where T&lt;:Real"><code>OpticSim.intersections</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns an array of intersection points. Each element in the array is (<code>[x,y,...],alpha,theta)</code> where <code>[x,y,...]</code> is the n-dimensional intersection point, alpha is the line parameter value at the intersection point, and theta is the curve parameter value at the intersection point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.isemptyinterval-Tuple{EmptyInterval}" href="#OpticSim.isemptyinterval-Tuple{EmptyInterval}"><code>OpticSim.isemptyinterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isemptyinterval(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a>. In performance critical contexts use <code>a isa EmptyInterval{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Interval.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.isinfinity-Tuple{Infinity}" href="#OpticSim.isinfinity-Tuple{Infinity}"><code>OpticSim.isinfinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinfinity(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts use <code>a isa Infinity{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Intersection.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ispositivehalfspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispositivehalfspace(a) -&gt; Bool</code></pre><p>Returns true if <code>upper(a)</code> is <a href="#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts check directly i.e. <code>upper(a) isa Infinity{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Interval.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.israyorigin-Tuple{Any}" href="#OpticSim.israyorigin-Tuple{Any}"><code>OpticSim.israyorigin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">israyorigin(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts use <code>a isa RayOrigin{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Intersection.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.israyorigininterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">israyorigininterval(a) -&gt; Bool</code></pre><p>Returns true if <code>lower(a)</code> is <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts check directly i.e. <code>lower(a) isa RayOrigin{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Interval.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},T,T,StaticArrays.SArray{Tuple{M},T,1,M},StaticArrays.SArray{Tuple{M},T,1,M}}} where M where N where T&lt;:Real" href="#OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},T,T,StaticArrays.SArray{Tuple{M},T,1,M},StaticArrays.SArray{Tuple{M},T,1,M}}} where M where N where T&lt;:Real"><code>OpticSim.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian(surf::ParametricSurface{T,N}, u::T, v::T, P1::SVector{M,T}, P2::SVector{M,T})</code></pre><p>Computes Jacobian of <code>f(t,u,v) = ( dot(P1,[surf(u,v),1],P2,[surf(u,v),1]) )</code>. <code>P1</code>, <code>P2</code> are orthogonal planes that pass through the ray. <code>J = [ ∂f1/∂u ∂f1/∂v ; ∂f2/∂u ∂f2/∂v]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AccelSurface.jl#L238-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.leaf-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real" href="#OpticSim.leaf-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T},RigidBodyTransform{T}}} where T&lt;:Real"><code>OpticSim.leaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">leaf(surf::CSGGenerator{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a (pseudo) leaf node from another CSGGenerator, this is useful if you want multiple copies of a premade CSG structure with different transforms, for example in an MLA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/CSG.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.leaf-Union{Tuple{S}, Tuple{T}, Tuple{S,RigidBodyTransform{T}}} where S&lt;:(ParametricSurface{T,N} where N) where T&lt;:Real" href="#OpticSim.leaf-Union{Tuple{S}, Tuple{T}, Tuple{S,RigidBodyTransform{T}}} where S&lt;:(ParametricSurface{T,N} where N) where T&lt;:Real"><code>OpticSim.leaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">leaf(surf::ParametricSurface{T}, transform::RigidBodyTransform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a leaf node from a parametric surface with a given transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/CSG.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.linedimension-Tuple{Array}" href="#OpticSim.linedimension-Tuple{Array}"><code>OpticSim.linedimension</code></a> — <span class="docstring-category">Method</span></header><section><div><p>spatial dimension of the moving line represented as an array of coefficients <code>g[i] = ∑Bl(θ)*gl[i,j]</code> where <code>Bl(θ)</code> is the polynomial basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.makemesh-Union{Tuple{ParametricSurface{S,N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S,N},Int64}} where N where S" href="#OpticSim.makemesh-Union{Tuple{ParametricSurface{S,N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S,N},Int64}} where N where S"><code>OpticSim.makemesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makemesh(object, subdivisions::Int = 30) -&gt; TriangleMesh</code></pre><p>Creates a <a href="#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> from an object, either a <a href="#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>, <a href="../csg/#OpticSim.CSGTree"><code>CSGTree</code></a> or certain surfaces (e.g. <code>Circle</code>, <code>Rectangle</code>). This is used for visualization purposes only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L251-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,3}}} where N where T" href="#OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},Array{T,3}}} where N where T"><code>OpticSim.matricesforeigen</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>movinglines[:,i]</code> is the ith moving line. For <code>li = movinglines[:,i] (dimension+1,lineorder) = size(li)</code>. <code>rline[:,1] = pt1</code> and <code>rline[:,2] = pt2</code>. The line equation is <code>pt1 + alpha*pt2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},AbstractRay{T,N},StaticArrays.SArray{Tuple{2},T,1,2}}} where N where T" href="#OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},AbstractRay{T,N},StaticArrays.SArray{Tuple{2},T,1,2}}} where N where T"><code>OpticSim.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newton(surf::ParametricSurface{T,N}, r::AbstractRay{T,N}, startingpoint::SVector{2,T})</code></pre><p>Newton iteration to find the precise intersection of a parametric surface with a ray given a starting point (in uv space) on the surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AccelSurface.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real" href="#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T,N} where N,T,T}} where T&lt;:Real"><code>OpticSim.normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal(surf::ParametricSurface{T}, u::T, v::T) -&gt; SVector{3,T}
normal(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; SVector{3,T}</code></pre><p>Returns the normal to <code>surf</code> at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.numberoflines-Tuple{Array}" href="#OpticSim.numberoflines-Tuple{Array}"><code>OpticSim.numberoflines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>number of lines in moving line array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Array{T,2},Any}} where T" href="#OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Array{T,2},Any}} where T"><code>OpticSim.orthogonalitymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns a matrix expressing the relationship <code>[x(θ) 1]⋅g(θ) = 0</code>. The vectors in the right nullspace of this matrix contain the coefficients of the moving lines <code>gᵢ(θ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AnalyticIntersection.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T,N},T}} where T&lt;:Real where N" href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T,N},T}} where T&lt;:Real where N"><code>OpticSim.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point(ray::AbstractRay{T,N}, alpha::T) -&gt; SVector{T, N}</code></pre><p>Returns a point on the ray at origin + alpha * direction. Alpha must be &gt;= 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Ray.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real" href="#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pressure(system::OpticalSystem{T}) -&gt; T</code></pre><p>Get the pressure of <code>system</code> in Atm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool,Bool}} where N where T&lt;:Real" href="#OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool}, Tuple{FresnelInterface{T},StaticArrays.SArray{Tuple{N},T,1,N},StaticArrays.SArray{Tuple{N},T,1,N},OpticalRay{T,N},T,T,Bool,Bool}} where N where T&lt;:Real"><code>OpticSim.processintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -&gt; Tuple{SVector{N,T}, T, T}</code></pre><p>Processes an intersection of an <a href="../emitters/#OpticSim.OpticalRay"><code>OpticalRay</code></a> with an <a href="#OpticSim.OpticalInterface"><code>OpticalInterface</code></a>, distinct behaviors must be implemented for each subclass of <code>OpticalInterface</code>.</p><p><code>point</code> is the 3D intersection point in global space, <code>normal</code> is the surface normal at the intersection point.</p><p>If <code>test</code> is true then the behavior of the ray should be deterministic. <code>firstray</code> indicates that this ray is the first segment of the trace and therefore the origin is not offset.</p><p>The values returned are the normalized direction of the ray after the intersection, the <em>instantaneous</em> power of the ray after the intersection and the optical path length of the ray up to the intersection.</p><p><code>nothing</code> is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration <code>nothing</code> should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fresnel.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.randinsolidangle-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},T}} where T&lt;:Real" href="#OpticSim.randinsolidangle-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3},T}} where T&lt;:Real"><code>OpticSim.randinsolidangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randinsolidangle(direction::SVector{3,T}, uvec::SVector{3,T}, vvec::SVector{3,T}, θmax::T)</code></pre><p>Generates a unit vector pointing somewhere within the cone with half angle <code>θmax</code> around <code>direction</code>. <code>uvec</code> and <code>vvec</code> should be orthogonal to each other and <code>direction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.raysample-Union{Tuple{P}, Tuple{D}, Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Source{T,S,O,D,P},OpticSim.RayState}} where P where D where O where S where T" href="#OpticSim.raysample-Union{Tuple{P}, Tuple{D}, Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Source{T,S,O,D,P},OpticSim.RayState}} where P where D where O where S where T"><code>OpticSim.raysample</code></a> — <span class="docstring-category">Method</span></header><section><div><p>raysample is the function that can couple origin and direction generation if necessary. The default function couples them in a simple way but more complex coupling should be possible. For each origin numsamples(a.raydirection) direction samples are taken with identical origin. Then the origin number is incremented. This repeats till all rays have been generated. The origin and direction functions receive an integer indicating the origin or direction number so regular patterns such as rectangular and hexapolar grids can be generated properly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T" href="#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T"><code>OpticSim.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset!(a::HierarchicalImage{T})</code></pre><p>Resets the pixels in the image to <code>zero(T)</code>. Do this rather than <code>image .= zero(T)</code> because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/HierarchicalImage.jl#L112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real" href="#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.resetdetector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resetdetector!(system::OpticalSystem{T})</code></pre><p>Reset the deterctor image of <code>system</code> to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.reversenormal-Union{Tuple{Intersection{T,N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Real" href="#OpticSim.reversenormal-Union{Tuple{Intersection{T,N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Real"><code>OpticSim.reversenormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reversenormal(a::Intersection{T,N})</code></pre><p>Used by the CSG complement operator (i.e. <a href="../csg/#OpticSim.csgdifference"><code>csgdifference</code></a>) to reverse the inside outside sense of the object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/Intersection.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.rotation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number" href="#OpticSim.rotation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotation([S::Type], θ::T, ϕ::T, ψ::T) -&gt; RigidBodyTransform{S}</code></pre><p>Returns the <a href="#OpticSim.RigidBodyTransform"><code>RigidBodyTransform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.rotationd-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number" href="#OpticSim.rotationd-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotationd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotationd([S::Type], θ::T, ϕ::T, ψ::T) -&gt; RigidBodyTransform{S}</code></pre><p>Returns the <a href="#OpticSim.RigidBodyTransform"><code>RigidBodyTransform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in degrees</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.rotmat-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number" href="#OpticSim.rotmat-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmat([S::Type], θ::T, ϕ::T, ψ::T) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Number" href="#OpticSim.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SArray{Tuple{3},T,1,3},StaticArrays.SArray{Tuple{3},T,1,3}}} where T&lt;:Number"><code>OpticSim.rotmatbetween</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation between vetors <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.rotmatd-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number" href="#OpticSim.rotmatd-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.rotmatd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in degrees</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Function}, Tuple{ParametricSurface{T,N},Function,Int64}} where N where T&lt;:Real" href="#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Function}, Tuple{ParametricSurface{T,N},Function,Int64}} where N where T&lt;:Real"><code>OpticSim.samplesurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)</code></pre><p>Sample a parametric surface on an even <code>numsamples</code>×<code>numsamples</code> grid in UV space with provided function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}" href="#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}"><code>OpticSim.semidiameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">semidiameter(system::AxisymmetricOpticalSystem{T}) -&gt; T</code></pre><p>Get the semidiameter of <code>system</code>, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S,S,T,T}} where S&lt;:(AbstractArray{T,N} where N) where T&lt;:Real" href="#OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S,S,T,T}} where S&lt;:(AbstractArray{T,N} where N) where T&lt;:Real"><code>OpticSim.snell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">snell(surfacenormal::AbstractVector{T}, raydirection::AbstractVector{T}, nᵢ::T, nₜ::T) -&gt; Tuple{T,T}</code></pre><p><code>nᵢ</code> is the index of refraction on the incidence side of the interface. <code>nₜ</code> is the index of refraction on the transmission side.</p><p>Returns <code>sinθᵢ</code> and <code>sinθₜ</code> according to <a href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell&#39;s law</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Fresnel.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.spectrumpower-Union{Tuple{T}, Tuple{MeasuredSpectrum{T},T}} where T&lt;:Real" href="#OpticSim.spectrumpower-Union{Tuple{T}, Tuple{MeasuredSpectrum{T},T}} where T&lt;:Real"><code>OpticSim.spectrumpower</code></a> — <span class="docstring-category">Method</span></header><section><div><p>expects wavelength in nm not um</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.spectrumsample-Union{Tuple{Source{T,UniformSpectrum{T},O,D,P}}, Tuple{T}, Tuple{P}, Tuple{D}, Tuple{O}} where T where P where D where O" href="#OpticSim.spectrumsample-Union{Tuple{Source{T,UniformSpectrum{T},O,D,P}}, Tuple{T}, Tuple{P}, Tuple{D}, Tuple{O}} where T where P where D where O"><code>OpticSim.spectrumsample</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns a tuple (power,wavelength) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/Emitter2.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T},HierarchicalImage{T}}} where T" href="#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T},HierarchicalImage{T}}} where T"><code>OpticSim.sum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})</code></pre><p>Add the contents of <code>b</code> to <code>a</code> in an efficient way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/HierarchicalImage.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S} where S&lt;:ParametricSurface{T,N},AbstractRay{T,N}}} where N where T" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S} where S&lt;:ParametricSurface{T,N},AbstractRay{T,N}}} where N where T"><code>OpticSim.surfaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}</code></pre><p>Calculates the intersection of <code>r</code> with a surface of any type, <code>surf</code>. Note that some surfaces cannot be intersected analytically so must be wrapped in an <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a> in order to be intersected.</p><p>Returns an <a href="../csg/#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no <a href="../csg/#OpticSim.Intersection"><code>Intersection</code></a>, an <a href="../csg/#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections and a <a href="../csg/#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AccelSurface.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real" href="#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number}, Tuple{T}} where T&lt;:Real"><code>OpticSim.temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temperature(system::OpticalSystem{T}) -&gt; T</code></pre><p>Get the temperature of <code>system</code> in °C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T},OpticalRay{T,N}}} where D&lt;:Number where N where T&lt;:Real" href="#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T},OpticalRay{T,N}}} where D&lt;:Number where N where T&lt;:Real"><code>OpticSim.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(system::OpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)</code></pre><p>Traces <code>system</code> with <code>ray</code>, if <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a <a href="#OpticSim.LensTrace"><code>LensTrace</code></a> if the ray hits the detector or <code>nothing</code> otherwise.</p><p><code>trackrays</code> can be passed an empty vector to accumulate the <code>LensTrace</code> objects at each intersection of <code>ray</code> with a surface in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T},OpticalRay{T,N}}, Tuple{LensAssembly{T},OpticalRay{T,N},T}, Tuple{LensAssembly{T},OpticalRay{T,N},T,T}} where N where T&lt;:Real" href="#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T},OpticalRay{T,N}}, Tuple{LensAssembly{T},OpticalRay{T,N},T}, Tuple{LensAssembly{T},OpticalRay{T,N},T,T}} where N where T&lt;:Real"><code>OpticSim.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)</code></pre><p>Returns the ray as it exits the assembly in the form of a <a href="#OpticSim.LensTrace"><code>LensTrace</code></a> object if it hits any element in the assembly, otherwise <code>nothing</code>. Recursive rays are offset by a small amount (<code>RAY_OFFSET</code>) to prevent it from immediately reintersecting the same lens element.</p><p><code>trackrays</code> can be passed an empty vector to accumulate the <code>LensTrace</code> objects at each intersection of <code>ray</code> with a surface in the assembly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/LensAssembly.jl#L337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> on a single thread. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. If <code>outpath</code> is specified then the result will be saved to this path.</p><p>Returns the detector image of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L335-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T,S,S1,L} where L&lt;:LensAssembly{T} where S1&lt;:Surface{T},OpticalRayGenerator{T}}} where S&lt;:Number where T&lt;:Real" href="#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T,S,S1,L} where L&lt;:LensAssembly{T} where S1&lt;:Surface{T},OpticalRayGenerator{T}}} where S&lt;:Number where T&lt;:Real"><code>OpticSim.traceMT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traceMT(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> using as many threads as possible. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. If <code>outpath</code> is specified then the result will be saved to this path.</p><p>Returns the accumulated detector image from all threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L384-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tracehits(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> on a single thread. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct.</p><p>Returns a list of <a href="#OpticSim.LensTrace"><code>LensTrace</code></a>s which hit the detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L598-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T,D,S,L} where L&lt;:LensAssembly{T} where S&lt;:Surface{T} where D&lt;:Number,OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehitsMT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tracehitsMT(system::OpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> using as many threads as possible. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct.</p><p>Returns a list of <a href="#OpticSim.LensTrace"><code>LensTrace</code></a>s which hit the detector, accumulated from all threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Optical/OpticalSystem.jl#L490-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.translation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number" href="#OpticSim.translation-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Number"><code>OpticSim.translation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translation([S::Type], x::T, y::T, z::T) -&gt; RigidBodyTransform{S}</code></pre><p>Returns the <a href="#OpticSim.RigidBodyTransform"><code>RigidBodyTransform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the translation by <code>x</code>, <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/CSG/RigidBodyTransform.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Int64}, Tuple{ParametricSurface{T,N},Int64,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool,Bool}} where N where T" href="#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T,N},Int64}, Tuple{ParametricSurface{T,N},Int64,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool}, Tuple{ParametricSurface{T,N},Int64,Bool,Bool,Bool,Bool}} where N where T"><code>OpticSim.triangulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)</code></pre><p>Create an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S},AbstractRay{T,N}}} where S where N where T&lt;:Real" href="#OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T,N,S},AbstractRay{T,N}}} where S where N where T&lt;:Real"><code>OpticSim.triangulatedintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangulatedintersection(surf::AcceleratedParametricSurface{T,N,S}, r::AbstractRay{T,N})</code></pre><p>Intersection of a ray, <code>r</code>, with a triangulated surface, <code>surf</code>, no concept of inside so never returns a <a href="../csg/#OpticSim.RayOrigin"><code>RayOrigin</code></a> <a href="../csg/#OpticSim.Interval"><code>Interval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/AccelSurface.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real" href="#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T,3},T,T,T}} where T&lt;:Real"><code>OpticSim.uv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uv(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; SVector{2,T}
uv(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; SVector{2,T}</code></pre><p>Returns the uv coordinate on <code>surf</code> of a point, <code>p</code>, in 3D space. If <code>onsurface(surf, p)</code> is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface" href="#OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface"><code>OpticSim.uvrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uvrange(s::ParametricSurface)
uvrange(::Type{S}) where {S&lt;:ParametricSurface}</code></pre><p>Returns a tuple of the form: <code>((umin, umax), (vmin, vmax))</code> specifying the limits of the parameterisation for this surface type. Also implemented for some <code>Surface</code>s which are not <code>ParametricSurface</code>s (e.g. <code>Rectangle</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Surface.jl#L151-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T},StaticArrays.SArray{Tuple{2},T,1,2},Tuple{Int64,Int64}}} where T&lt;:Real" href="#OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T},StaticArrays.SArray{Tuple{2},T,1,2},Tuple{Int64,Int64}}} where T&lt;:Real"><code>OpticSim.uvtopix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -&gt; Tuple{Int,Int}</code></pre><p>Converts a uvcoordinate on <code>surf</code> to an integer index to a pixel in an image of size <code>imsize</code>. Not implemented on all <code>Surface</code> objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an <a href="../systems/#OpticSim.OpticalSystem"><code>OpticalSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/NonCSG/Rectangle.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T&lt;:Real" href="#OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T,N},StaticArrays.SArray{Tuple{N},T,1,N}}} where N where T&lt;:Real"><code>OpticSim.α</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">α(ray::AbstractRay{T,N}, point::SVector{N,T}) -&gt; T</code></pre><p>Computes the alpha corresponding to the closest position on the ray to point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Ray.jl#L117-L121">source</a></section></article><h2 id="Zernike"><a class="docs-heading-anchor" href="#Zernike">Zernike</a><a id="Zernike-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike" href="#OpticSim.Zernike"><code>OpticSim.Zernike</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module to enclose <a href="https://en.wikipedia.org/wiki/Zernike_polynomials">Zernike polynomial</a> specific functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.NolltoNM-Tuple{Int64}" href="#OpticSim.Zernike.NolltoNM-Tuple{Int64}"><code>OpticSim.Zernike.NolltoNM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NolltoNM(j::Int) -&gt; Tuple{Int, Int}</code></pre><p>Convert Noll zernike index <code>j</code> to <code>(N,M)</code> form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.OSAtoNM-Tuple{Int64}" href="#OpticSim.Zernike.OSAtoNM-Tuple{Int64}"><code>OpticSim.Zernike.OSAtoNM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OSAtoNM(j::Int) -&gt; Tuple{Int, Int}</code></pre><p>Convert OSA zernike index <code>j</code> to <code>(N,M)</code> form according to formula <code>J = N * (N + 2) + M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64,Int64,T}} where T&lt;:Real" href="#OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64,Int64,T}} where T&lt;:Real"><code>OpticSim.Zernike.R</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R(N::Int, M::Int, ρ::T) -&gt; T</code></pre><p>Evaluate radial polynomial <span>$R_{n}^{m}(\rho)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T},Int64,Int64}} where T&lt;:Real" href="#OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T},Int64,Int64}} where T&lt;:Real"><code>OpticSim.Zernike.normalisation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalisation(::Type{T}, N::Int, M::Int) -&gt; T</code></pre><p>Normalisation coefficient for Zernike polynomial term <span>$Z_{n}^{m}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real" href="#OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real"><code>OpticSim.Zernike.δζ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">δζ(N::Int, M::Int, ρ::T, ϕ::T) -&gt; Tuple{T,T}</code></pre><p>Evaluate partial derivatives of Zernike polynomial term <span>$Z_{n}^{m}(\rho, \phi)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real" href="#OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real"><code>OpticSim.Zernike.ζ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ζ(N::Int, M::Int, ρ::T, ϕ::T) -&gt; Tuple{T,T}</code></pre><p>Evaluate Zernike polynomial term <span>$Z_{n}^{m}(\rho, \phi)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Zernike.jl#L74-L78">source</a></section></article><h2 id="QType"><a class="docs-heading-anchor" href="#QType">QType</a><a id="QType-1"></a><a class="docs-heading-anchor-permalink" href="#QType" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType" href="#OpticSim.QType"><code>OpticSim.QType</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module to enclose QType polynomial specific functionality. For reference see:</p><ol><li><a href="https://www.osapublishing.org/viewmedia.cfm?uri=oe-18-19-19700&amp;seq=0"><em>Robust, efficient computational methods for axially symmetric optical aspheres</em> - G. W. Forbes, 2010</a></li><li><a href="https://www.osapublishing.org/viewmedia.cfm?uri=oe-20-3-2483&amp;seq=0"><em>Characterizing the shape of freeform optics</em> - G. W. Forbes, 2012</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Qtype.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T&lt;:Real" href="#OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.S</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S(coeffs::SVector{NP1,T}, m::Int x::T) -&gt; T</code></pre><p>Evaluates <span>$\sum_{n=0}^{N}c_n^mQ_n^m(x)$</span> where <span>$c_n^m$</span> is either an <span>$\alpha$</span> or <span>$\beta$</span> QType coefficient and <span>$m \gt 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Qtype.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T&lt;:Real" href="#OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.S0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S0(coeffs::SVector{NP1,T}, x::T) -&gt; T</code></pre><p>Evaluates <span>$\sum_{n=0}^{N}\alpha_n^0Q_n^0(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Qtype.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T&lt;:Real" href="#OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.dS0dx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dS0dx(coeffs::SVector{NP1,T}, x::T) -&gt; T</code></pre><p>Evaluates <span>$\frac{\partial}{\partial x}\sum_{n=0}^{N}\alpha_n^0Q_n^0(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Qtype.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T&lt;:Real" href="#OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SArray{Tuple{NP1},T,1,NP1},Int64,T}} where NP1 where T&lt;:Real"><code>OpticSim.QType.dSdx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dSdx(coeffs::SVector{NP1,T}, x::T) -&gt; T</code></pre><p>Evaluates <span>$\frac{\partial}{\partial x}\sum_{n=0}^{N}c_n^mQ_n^m(x)$</span> where <span>$c_n^m$</span> is either an <span>$\alpha$</span> or <span>$\beta$</span> QType coefficient and <span>$m \gt 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Qtype.jl#L201-L205">source</a></section></article><h2 id="Chebyshev"><a class="docs-heading-anchor" href="#Chebyshev">Chebyshev</a><a id="Chebyshev-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev" href="#OpticSim.Chebyshev"><code>OpticSim.Chebyshev</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module to enclose <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev polynomial</a> specific functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Chebyshev.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real" href="#OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.T</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T(n::Int, q::R, fast::Bool = true) -&gt; R</code></pre><p>Evaluate Chebyshev polynomial of the first kind <span>$T_n(q)$</span>.</p><p><code>fast</code> will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Chebyshev.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real" href="#OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U(n::Int, q::R, fast::Bool = true) -&gt; R</code></pre><p>Evaluate Chebyshev polynomial of the second kind <span>$U_n(q)$</span>.</p><p><code>fast</code> will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Chebyshev.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real" href="#OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64,R}, Tuple{Int64,R,Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.dTdq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dTdq(n::Int, q::R, fast::Bool = true) -&gt; R</code></pre><p>Evaluate derivative of Chebyshev polynomial of the first kind <span>$\frac{dT_n}{dq}(q)$</span>.</p><p><code>fast</code> will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Geometry/Primitives/Chebyshev.jl#L77-L83">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples" href="#OpticSim.Examples"><code>OpticSim.Examples</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Contains example usage of the features in the OpticSim.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/410b4127ae26ecd49e78c36c4bc8da43d1ee96e2/src/Examples.jl#L23">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">« Optimization</a><a class="docs-footer-nextpage" href="../roadmap/">Roadmap »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 March 2021 13:51">Tuesday 23 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
