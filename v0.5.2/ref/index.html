<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · OpticSim.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">OpticSim.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../basic_types/">Basic Types</a></li><li><a class="tocitem" href="../primitives/">Primitives</a></li><li><a class="tocitem" href="../csg/">CSG</a></li><li><a class="tocitem" href="../repeat/">Repeating Structures</a></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li><a class="tocitem" href="../vis/">Visualization</a></li><li><a class="tocitem" href="../glasscat/">Glass Functions</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../cloud/">Cloud Execution</a></li><li><a class="tocitem" href="../notebooksutils/">Notebook utilities</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#OpticSim"><span>OpticSim</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Zernike"><span>Zernike</span></a></li><li><a class="tocitem" href="#QType"><span>QType</span></a></li><li><a class="tocitem" href="#Chebyshev"><span>Chebyshev</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/microsoft/OpticSim.jl/blob/master/docs/src/ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Complete-Reference"><a class="docs-heading-anchor" href="#Complete-Reference">Complete Reference</a><a id="Complete-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Reference" title="Permalink"></a></h1><p>This page contains what should be a complete list of all docstrings in the OpticSim module, and its submodule.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#OpticSim.Chebyshev"><code>OpticSim.Chebyshev</code></a></li><li><a href="#OpticSim.Examples"><code>OpticSim.Examples</code></a></li><li><a href="#OpticSim.QType"><code>OpticSim.QType</code></a></li><li><a href="#OpticSim.Zernike"><code>OpticSim.Zernike</code></a></li><li><a href="#OpticSim.BSplineCurve"><code>OpticSim.BSplineCurve</code></a></li><li><a href="#OpticSim.BeamState"><code>OpticSim.BeamState</code></a></li><li><a href="#OpticSim.BezierCurve"><code>OpticSim.BezierCurve</code></a></li><li><a href="#OpticSim.CircularStopShape"><code>OpticSim.CircularStopShape</code></a></li><li><a href="#OpticSim.ConvexPolygon"><code>OpticSim.ConvexPolygon</code></a></li><li><a href="#OpticSim.CurveType"><code>OpticSim.CurveType</code></a></li><li><a href="#OpticSim.GeometricRayGenerator"><code>OpticSim.GeometricRayGenerator</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArrays.SVector{4, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}, NTuple{4, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, L} where L, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SMatrix{3, N, T, L} where L}, Tuple{T}, Tuple{N}} where {N, T&lt;:Real}"><code>OpticSim.Geometry.Vec4</code></a></li><li><a href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Vec4</code></a></li><li><a href="#OpticSim.GridSagInterpolation"><code>OpticSim.GridSagInterpolation</code></a></li><li><a href="#OpticSim.InterfaceMode"><code>OpticSim.InterfaceMode</code></a></li><li><a href="#OpticSim.KnotVector"><code>OpticSim.KnotVector</code></a></li><li><a href="#OpticSim.OpticalRay"><code>OpticSim.OpticalRay</code></a></li><li><a href="#OpticSim.OpticalRayGenerator"><code>OpticSim.OpticalRayGenerator</code></a></li><li><a href="#OpticSim.PlanarShape"><code>OpticSim.PlanarShape</code></a></li><li><a href="#OpticSim.Primitive"><code>OpticSim.Primitive</code></a></li><li><a href="#OpticSim.Ray"><code>OpticSim.Ray</code></a></li><li><a href="#OpticSim.RectangularStopShape"><code>OpticSim.RectangularStopShape</code></a></li><li><a href="#OpticSim.Spline"><code>OpticSim.Spline</code></a></li><li><a href="#OpticSim.SplineSurface"><code>OpticSim.SplineSurface</code></a></li><li><a href="#OpticSim.StopSurface"><code>OpticSim.StopSurface</code></a></li><li><a href="#OpticSim.ZernikeIndexType"><code>OpticSim.ZernikeIndexType</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Ray{T, 3}}} where T"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Intersection{T, 3}}} where T&lt;:Real"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Interval{T}}} where T&lt;:Real"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Triangle{T}}} where T&lt;:Real"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, TriangleMesh{T}}} where T&lt;:Real"><code>Base.:*</code></a></li><li><a href="#OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Annulus</code></a></li><li><a href="#OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ArizonaEye</code></a></li><li><a href="#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}"><code>OpticSim.AsphericLens</code></a></li><li><a href="#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.BoundedCylinder</code></a></li><li><a href="#OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.T</code></a></li><li><a href="#OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.U</code></a></li><li><a href="#OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.dTdq</code></a></li><li><a href="#OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Circle</code></a></li><li><a href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a></li><li><a href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a></li><li><a href="#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}"><code>OpticSim.ConicLens</code></a></li><li><a href="#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Cuboid</code></a></li><li><a href="#OpticSim.Examples.drawhex12RGB-Tuple{}"><code>OpticSim.Examples.drawhex12RGB</code></a></li><li><a href="#OpticSim.Examples.drawhex3RGB-Tuple{}"><code>OpticSim.Examples.drawhex3RGB</code></a></li><li><a href="#OpticSim.Examples.drawhexneighbors-Tuple{}"><code>OpticSim.Examples.drawhexneighbors</code></a></li><li><a href="#OpticSim.Examples.drawhexrect-Tuple{}"><code>OpticSim.Examples.drawhexrect</code></a></li><li><a href="#OpticSim.Examples.drawhexrectcolors-Tuple{}"><code>OpticSim.Examples.drawhexrectcolors</code></a></li><li><a href="#OpticSim.Examples.drawhexregion-Tuple{}"><code>OpticSim.Examples.drawhexregion</code></a></li><li><a href="#OpticSim.Examples.hemisphere-Tuple{}"><code>OpticSim.Examples.hemisphere</code></a></li><li><a href="#OpticSim.Examples.hex3RGB-Tuple{}"><code>OpticSim.Examples.hex3RGB</code></a></li><li><a href="#OpticSim.Examples.hex3cluster-Tuple{}"><code>OpticSim.Examples.hex3cluster</code></a></li><li><a href="#OpticSim.Examples.hexRGBW-Tuple{}"><code>OpticSim.Examples.hexRGBW</code></a></li><li><a href="#OpticSim.Examples.opticalhemisphere-Tuple{}"><code>OpticSim.Examples.opticalhemisphere</code></a></li><li><a href="#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, T, T, T, T, T}} where {T&lt;:Real, G&lt;:OpticSim.GlassCat.AbstractGlass, H&lt;:OpticSim.GlassCat.AbstractGlass}"><code>OpticSim.FresnelLens</code></a></li><li><a href="#OpticSim.Geometry.decomposeRTS-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.decomposeRTS</code></a></li><li><a href="#OpticSim.Geometry.forward-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.Geometry.forward</code></a></li><li><a href="#OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.identitytransform</code></a></li><li><a href="#OpticSim.Geometry.local2world-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.local2world</code></a></li><li><a href="#OpticSim.Geometry.right-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.Geometry.right</code></a></li><li><a href="#OpticSim.Geometry.rotate-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.rotate</code></a></li><li><a href="#OpticSim.Geometry.rotation-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.rotation</code></a></li><li><a href="#OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotation</code></a></li><li><a href="#OpticSim.Geometry.rotationX-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationX</code></a></li><li><a href="#OpticSim.Geometry.rotationY-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationY</code></a></li><li><a href="#OpticSim.Geometry.rotationZ-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationZ</code></a></li><li><a href="#OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotationd</code></a></li><li><a href="#OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmat</code></a></li><li><a href="#OpticSim.Geometry.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.rotmatbetween</code></a></li><li><a href="#OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmatd</code></a></li><li><a href="#OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a></li><li><a href="#OpticSim.Geometry.scale-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a></li><li><a href="#OpticSim.Geometry.scale-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a></li><li><a href="#OpticSim.Geometry.translation-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.translation</code></a></li><li><a href="#OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T&lt;:Number, S&lt;:Real}"><code>OpticSim.Geometry.translation</code></a></li><li><a href="#OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitW4</code></a></li><li><a href="#OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX3</code></a></li><li><a href="#OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX4</code></a></li><li><a href="#OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY3</code></a></li><li><a href="#OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY4</code></a></li><li><a href="#OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ3</code></a></li><li><a href="#OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ4</code></a></li><li><a href="#OpticSim.Geometry.up-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.Geometry.up</code></a></li><li><a href="#OpticSim.Geometry.world2local-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.world2local</code></a></li><li><a href="#OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C&lt;:(CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}})}, Tuple{T}} where T&lt;:Real"><code>OpticSim.GridField</code></a></li><li><a href="#OpticSim.GridField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.GridField</code></a></li><li><a href="#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.HexagonalPrism</code></a></li><li><a href="#OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a></li><li><a href="#OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C&lt;:(CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}})}, Tuple{T}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a></li><li><a href="#OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:Real}"><code>OpticSim.ModelEye</code></a></li><li><a href="#OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.S</code></a></li><li><a href="#OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.S0</code></a></li><li><a href="#OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.dS0dx</code></a></li><li><a href="#OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.dSdx</code></a></li><li><a href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a></li><li><a href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a></li><li><a href="#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.RectangularPrism</code></a></li><li><a href="#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}"><code>OpticSim.SphericalLens</code></a></li><li><a href="#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Spider</code></a></li><li><a href="#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.TriangularPrism</code></a></li><li><a href="#OpticSim.Zernike.NolltoNM-Tuple{Int64}"><code>OpticSim.Zernike.NolltoNM</code></a></li><li><a href="#OpticSim.Zernike.OSAtoNM-Tuple{Int64}"><code>OpticSim.Zernike.OSAtoNM</code></a></li><li><a href="#OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>OpticSim.Zernike.R</code></a></li><li><a href="#OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T&lt;:Real"><code>OpticSim.Zernike.normalisation</code></a></li><li><a href="#OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T&lt;:Real"><code>OpticSim.Zernike.δζ</code></a></li><li><a href="#OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T&lt;:Real"><code>OpticSim.Zernike.ζ</code></a></li><li><a href="#OpticSim.area-Union{Tuple{SphericalPolygon{N, T}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}"><code>OpticSim.area</code></a></li><li><a href="#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.assembly</code></a></li><li><a href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a></li><li><a href="#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}"><code>OpticSim.closestpointonray</code></a></li><li><a href="#OpticSim.curvedimension-Tuple{Array}"><code>OpticSim.curvedimension</code></a></li><li><a href="#OpticSim.curveorder-Tuple{Array}"><code>OpticSim.curveorder</code></a></li><li><a href="#OpticSim.detectorimage-Tuple{CSGOpticalSystem}"><code>OpticSim.detectorimage</code></a></li><li><a href="#OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}"><code>OpticSim.distance</code></a></li><li><a href="#OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArrays.SVector{3, T} where T}"><code>OpticSim.distancefromplane</code></a></li><li><a href="#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real"><code>OpticSim.doesintersect</code></a></li><li><a href="#OpticSim.evalcsg"><code>OpticSim.evalcsg</code></a></li><li><a href="#OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Matrix{T}, Real}} where T&lt;:Real"><code>OpticSim.evaluatecurve</code></a></li><li><a href="#OpticSim.extractmovinglines-NTuple{4, Any}"><code>OpticSim.extractmovinglines</code></a></li><li><a href="#OpticSim.fresnel-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real"><code>OpticSim.fresnel</code></a></li><li><a href="#OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.halfspaceintersection</code></a></li><li><a href="#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S&lt;:ParametricSurface{T, N}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.interface</code></a></li><li><a href="#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T&lt;:Real, N}"><code>OpticSim.intersections</code></a></li><li><a href="#OpticSim.isemptyinterval-Tuple{EmptyInterval}"><code>OpticSim.isemptyinterval</code></a></li><li><a href="#OpticSim.isinfinity-Tuple{Infinity}"><code>OpticSim.isinfinity</code></a></li><li><a href="#OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ispositivehalfspace</code></a></li><li><a href="#OpticSim.israyorigin-Tuple{Any}"><code>OpticSim.israyorigin</code></a></li><li><a href="#OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.israyorigininterval</code></a></li><li><a href="#OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, T, T, StaticArrays.SVector{M, T}, StaticArrays.SVector{M, T}}} where {T&lt;:Real, N, M}"><code>OpticSim.jacobian</code></a></li><li><a href="#OpticSim.leaf-Union{Tuple{ParametricSurface{T, N} where N}, Tuple{T}, Tuple{ParametricSurface{T, N} where N, StaticArrays.SMatrix{4, 4, T, 16}}} where T&lt;:Real"><code>OpticSim.leaf</code></a></li><li><a href="#OpticSim.linedimension-Tuple{Array}"><code>OpticSim.linedimension</code></a></li><li><a href="#OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T&lt;:Real}"><code>OpticSim.makemesh</code></a></li><li><a href="#OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}"><code>OpticSim.makemesh</code></a></li><li><a href="#OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Array{T, 3}}} where {T, N}"><code>OpticSim.matricesforeigen</code></a></li><li><a href="#OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, AbstractRay{T, N}, StaticArrays.SVector{2, T}}} where {T, N}"><code>OpticSim.newton</code></a></li><li><a href="#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T, N} where N, T, T}} where T&lt;:Real"><code>OpticSim.normal</code></a></li><li><a href="#OpticSim.numberoflines-Tuple{Array}"><code>OpticSim.numberoflines</code></a></li><li><a href="#OpticSim.origin-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.origin</code></a></li><li><a href="#OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T"><code>OpticSim.orthogonalitymatrix</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArrays.SMatrix{2, N, T, L} where L}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Tuple{OpticSim.VirtualPoint}"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T&lt;:Real"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.pressure</code></a></li><li><a href="#OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool, Bool}} where {T&lt;:Real, N}"><code>OpticSim.processintersection</code></a></li><li><a href="#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T"><code>OpticSim.reset!</code></a></li><li><a href="#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.resetdetector!</code></a></li><li><a href="#OpticSim.reversenormal-Union{Tuple{Intersection{T, N}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}"><code>OpticSim.reversenormal</code></a></li><li><a href="#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T&lt;:Real, N}"><code>OpticSim.samplesurface</code></a></li><li><a href="#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}"><code>OpticSim.semidiameter</code></a></li><li><a href="#OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S, S, T, T}} where {T&lt;:Real, S&lt;:(AbstractArray{T, N} where N)}"><code>OpticSim.snell</code></a></li><li><a href="#OpticSim.sphericalangle-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.sphericalangle</code></a></li><li><a href="#OpticSim.sphericalcircle"><code>OpticSim.sphericalcircle</code></a></li><li><a href="#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T"><code>OpticSim.sum!</code></a></li><li><a href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S&lt;:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}"><code>OpticSim.surfaceintersection</code></a></li><li><a href="#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.temperature</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T&lt;:Real, N}"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRay{T, N}}} where {T&lt;:Real, N, D&lt;:Number}"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T&lt;:Real, S&lt;:Number}"><code>OpticSim.traceMT</code></a></li><li><a href="#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehits</code></a></li><li><a href="#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehitsMT</code></a></li><li><a href="#OpticSim.transform-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T}, StaticArrays.SMatrix{4, 4, T, 16}}} where T&lt;:Real"><code>OpticSim.transform</code></a></li><li><a href="#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool, Bool}} where {T, N}"><code>OpticSim.triangulate</code></a></li><li><a href="#OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S}, AbstractRay{T, N}}} where {T&lt;:Real, N, S}"><code>OpticSim.triangulatedintersection</code></a></li><li><a href="#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.uv</code></a></li><li><a href="#OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface"><code>OpticSim.uvrange</code></a></li><li><a href="#OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T}, StaticArrays.SVector{2, T}, Tuple{Int64, Int64}}} where T&lt;:Real"><code>OpticSim.uvtopix</code></a></li><li><a href="#OpticSim.vertices-Tuple{OpticSim.PlanarShape}"><code>OpticSim.vertices</code></a></li><li><a href="#OpticSim.vertices-Tuple{ParaxialLens}"><code>OpticSim.vertices</code></a></li><li><a href="#OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices</code></a></li><li><a href="#OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a></li><li><a href="#OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a></li><li><a href="#OpticSim.virtualdistance-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.virtualdistance</code></a></li><li><a href="#OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T"><code>OpticSim.virtualpoint</code></a></li><li><a href="#OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T&lt;:Real, N}"><code>OpticSim.α</code></a></li></ul><h2 id="OpticSim"><a class="docs-heading-anchor" href="#OpticSim">OpticSim</a><a id="OpticSim-1"></a><a class="docs-heading-anchor-permalink" href="#OpticSim" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BSplineCurve" href="#OpticSim.BSplineCurve"><code>OpticSim.BSplineCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSplineCurve{P,S,N,M} &lt;: Spline{P,S,N,M}</code></pre><p><code>N</code> is the spatial dimension of the curve. <code>M</code> is the curve order, i.e., the highest power of the parameterizing variable, <code>u</code>. All curve segments are assumed to be of the same order.</p><pre><code class="language-julia">BSplineCurve{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{MVector{N,S},1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Curves/BSpline.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BeamState" href="#OpticSim.BeamState"><code>OpticSim.BeamState</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ConvergingBeam</code>, <code>DivergingBeam</code> or <code>CollimatedBeam</code>, defines the behavior of a beam in a <a href="../interfaces/#OpticSim.HologramInterface"><code>HologramInterface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalInterface.jl#L203-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BezierCurve" href="#OpticSim.BezierCurve"><code>OpticSim.BezierCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BezierCurve{P,S,N,M} &lt;: Spline{P,S,N,M}</code></pre><p><code>N</code> is the dimension of the curve, <code>M</code> is the curve order</p><pre><code class="language-julia">BezierCurve{P,S,N,M}(controlpoints::AbstractArray{&lt;:AbstractArray{S,1},1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Curves/Bezier.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularStopShape" href="#OpticSim.CircularStopShape"><code>OpticSim.CircularStopShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CircularStopShape &lt;: StopShape</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ConvexPolygon" href="#OpticSim.ConvexPolygon"><code>OpticSim.ConvexPolygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConvexPolygon{N, T&lt;:Real} &lt;: PlanarShape{T}</code></pre><p>General Convex Polygon surface, not a valid CSG object. The rotation of the polygon around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p><pre><code class="language-julia">ConvexPolygon(local_frame::Transform{T}, local_polygon_points::Vector{SVector{2, T}}, interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The local frame defines the plane (spans by the right and up vectors) with the plane normal given by the forward vector. the local<em>polygon</em>points are given with respect to the local frame and are 2D points. NOTE: This class uses static vectors to hold the points which will lead to more efficient performance, but should not be used with polygons with more than 20-30 points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/ConvexPolygon.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CurveType" href="#OpticSim.CurveType"><code>OpticSim.CurveType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Either <code>Rational</code> or <code>Euclidean</code>, used for <a href="#OpticSim.Spline"><code>Spline</code></a>s and <a href="#OpticSim.SplineSurface"><code>SplineSurface</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Curves/Spline.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GeometricRayGenerator" href="#OpticSim.GeometricRayGenerator"><code>OpticSim.GeometricRayGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeometricRayGenerator{T,O&lt;:RayOriginGenerator{T}} &lt;: AbstractRayGenerator{T}</code></pre><p>Generates geometric <a href="#OpticSim.Ray"><code>Ray</code></a>s according to the specific implementation of the subclass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/RayGenerator.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridSagInterpolation" href="#OpticSim.GridSagInterpolation"><code>OpticSim.GridSagInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Either <code>GridSagLinear</code> or <code>GridSagBicubic</code> - determines the interpolation between sample points in the grid for a <a href="../primitives/#OpticSim.GridSagSurface"><code>GridSagSurface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/GridSag.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.InterfaceMode" href="#OpticSim.InterfaceMode"><code>OpticSim.InterfaceMode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Valid modes for deterministic raytracing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalInterface.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.KnotVector" href="#OpticSim.KnotVector"><code>OpticSim.KnotVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KnotVector{T&lt;:Number}</code></pre><p>Vector to define knots used for <a href="#OpticSim.BSplineCurve"><code>BSplineCurve</code></a> and <a href="../primitives/#OpticSim.BSplineSurface"><code>BSplineSurface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Curves/Knots.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.OpticalRay" href="#OpticSim.OpticalRay"><code>OpticSim.OpticalRay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OpticalRay{T,N} &lt;: AbstractRay{T,N}</code></pre><p>Ray with power, wavelength and optical path length.</p><p><strong>NOTE</strong>: we use monte carlo integration to get accurate results on the detector, this means that all rays essentially hit the detector with power = 1 and some rays are thrown away at any interface to correctly match the reflection/transmission at that interface. For inspection purposes we also track the &#39;instantaneous&#39; power of the ray in the <code>power</code> field of the <code>OpticalRay</code>.</p><pre><code class="language-julia">OpticalRay(ray::Ray{T,N}, power::T, wavelength::T, opl=zero(T))
OpticalRay(origin::SVector{N,T}, direction::SVector{N,T}, power::T, wavelength::T, opl=zero(T))</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia">ray(r::OpticalRay{T,N}) -&gt; Ray{T,N}
direction(r::OpticalRay{T,N}) -&gt; SVector{N,T}
origin(r::OpticalRay{T,N}) -&gt; SVector{N,T}
power(r::OpticalRay{T,N}) -&gt; T
wavelength(r::OpticalRay{T,N}) -&gt; T
pathlength(r::OpticalRay{T,N}) -&gt; T
sourcepower(r::OpticalRay{T,N}) -&gt; T
nhits(r::OpticalRay{T,N}) -&gt; Int
sourcenum(r::OpticalRay{T,N}) -&gt; Int</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalRay.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.OpticalRayGenerator" href="#OpticSim.OpticalRayGenerator"><code>OpticSim.OpticalRayGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OpticalRayGenerator{T} &lt;: AbstractRayGenerator{T}</code></pre><p>Generates <a href="#OpticSim.OpticalRay"><code>OpticalRay</code></a>s according to the specific implementation of the subclass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/RayGenerator.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.PlanarShape" href="#OpticSim.PlanarShape"><code>OpticSim.PlanarShape</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The PlanarShape interface:</p><p><code>distancefromplane(p::PlanarShape,point)</code>  returns distance of the point from the plane the planar shape lies within <code>normal(p::PlanarShape)</code> returns normal of plane <code>interface(p::PlanarShape)</code> returns optical interface of plane <code>vertices(p::PlanarShape)</code> returns vertices of shape. For Ellipse this is an approximation.</p><p>There are default functions for plane,normal,interface,vertices which assume each PlanarShape type has a field of the same name <code>plane(a::PlanarShape) = a.plane     normal(a::PlanaShape) = a.plane.normal</code> etc.</p><p>If your type doesn&#39;t have these fields then you should define a more specialized method to handle this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/PlanarShape.jl#L6-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Primitive" href="#OpticSim.Primitive"><code>OpticSim.Primitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Primitive{T&lt;:Real}</code></pre><p><code>T</code> is the number type used to represent the primitive,  e.g., <code>Float64</code>. Primitives are the basic elements which can be stored in bounding volume hierarchies and include surfaces and CSG objects</p><p><strong>Must</strong> implement the following:</p><pre><code class="language-julia">boundingbox(a::Primitive{T})::BoundingBox{T}
centroid(a::Primitive{T})::SVector{3,T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Ray" href="#OpticSim.Ray"><code>OpticSim.Ray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ray{T,N} &lt;: AbstractRay{T,N}</code></pre><p>Purely geometric ray, defined as <code>origin + alpha * direction</code>.</p><pre><code class="language-julia">Ray(origin::SVector{N,T}, direction::SVector{N,T})</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia">direction(ray::Ray{T,N}) -&gt; SVector{N,T}
origin(ray::Ray{T,N}) -&gt; SVector{N,T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Ray.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularStopShape" href="#OpticSim.RectangularStopShape"><code>OpticSim.RectangularStopShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectangularStopShape &lt;: StopShape</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Spline" href="#OpticSim.Spline"><code>OpticSim.Spline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Spline{P&lt;:CurveType,S&lt;:Number,N,M}</code></pre><p><code>M</code> is the curve order, i.e., the highest power of the parameterizing variable, u. <code>P</code> determines the <a href="#OpticSim.CurveType"><code>CurveType</code></a>.</p><p>All Spline types must implement:</p><pre><code class="language-julia">point(curve,u)</code></pre><p>and have field <code>controlpolygon</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Curves/Spline.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.SplineSurface" href="#OpticSim.SplineSurface"><code>OpticSim.SplineSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SplineSurface{P,S,N,M} &lt;: ParametricSurface{S,N}</code></pre><p>Curve order, <code>M</code>, is the same in the u and v direction and fixed over all spans. <code>P</code> determines the <a href="#OpticSim.CurveType"><code>CurveType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Curves/Spline.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.StopSurface" href="#OpticSim.StopSurface"><code>OpticSim.StopSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StopSurface{T} &lt;: Surface{T}</code></pre><p>Abstract type to encapsulate any surfaces acting as a stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ZernikeIndexType" href="#OpticSim.ZernikeIndexType"><code>OpticSim.ZernikeIndexType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Either <code>ZernikeIndexingOSA</code> or <code>ZernikeIndexingNoll</code>, see <a href="https://en.wikipedia.org/wiki/Zernike_polynomials">Zernike polynomials wikipedia entry</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Intersection{T, 3}}} where T&lt;:Real" href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Intersection{T, 3}}} where T&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a Transform to an Intersection object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Intersection.jl#L170-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Interval{T}}} where T&lt;:Real" href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Interval{T}}} where T&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a Transform to an Interval object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Interval.jl#L562-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Ray{T, 3}}} where T" href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Ray{T, 3}}} where T"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a Transform to a Ray object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Ray.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, TriangleMesh{T}}} where T&lt;:Real" href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, TriangleMesh{T}}} where T&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a Transform to a TriangleMesh object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Triangle.jl#L147-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Triangle{T}}} where T&lt;:Real" href="#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Triangle{T}}} where T&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a Transform to a Triangle object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Triangle.jl#L158-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a circle i.e. <code>FiniteStop{T,CircularStopShape,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ArizonaEye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)</code></pre><p>The popular Arizona eye model taken from <a href="https://photonengr.com/wp-content/uploads/kbasefiles/ArizonaEyeModel.pdf">this definition</a>. The <code>accommodation</code> of the eye can be varied in this model. Returns a <code>DataFrame</code> specifying the prescription of the eye model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Eye.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}" href="#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}"><code>OpticSim.AsphericLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)</code></pre><p>Cosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Lenses.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.BoundedCylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cylinder with planar caps on both ends centred at <code>(0, 0, 0)</code> with axis <code>(0, 0, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Geometry.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))</code></pre><p>Shortcut method to create a circle. The minimal case returns a circle centred at the origin with <code>normal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Ellipse.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a plane i.e. <code>InfiniteStop{T,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a circular aperture in a rectangle i.e. <code>FiniteStop{T,CircularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}" href="#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}"><code>OpticSim.ConicLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)</code></pre><p>Constructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Lenses.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real" href="#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cuboid centred at <code>(0, 0, 0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Geometry.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, T, T, T, T, T}} where {T&lt;:Real, G&lt;:OpticSim.GlassCat.AbstractGlass, H&lt;:OpticSim.GlassCat.AbstractGlass}" href="#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, T, T, T, T, T}} where {T&lt;:Real, G&lt;:OpticSim.GlassCat.AbstractGlass, H&lt;:OpticSim.GlassCat.AbstractGlass}"><code>OpticSim.FresnelLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = OpticSim.GlassCat.Air)</code></pre><p>Create a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on <code>groovedepth</code>. For negative radii the vertex on the central surface is at <code>frontvertex</code>, so the total thickness of the lens is <code>thickness</code> + <code>groovedepth</code>. <strong>Aspherics currently not supported</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Lenses.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C&lt;:(CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}})}, Tuple{T}} where T&lt;:Real" href="#OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C&lt;:(CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}})}, Tuple{T}} where T&lt;:Real"><code>OpticSim.GridField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over the entrance pupil of the system in a rectangular grid pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fields.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.GridField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.GridField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.GridField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridField(semidiameter, pupilpos; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over a circular pupil with half-diameter defined by <code>semidiameter</code>, centred at <code>pupilpos</code> in a rectangular grid pattern. <code>samples</code> is the number of rays on each side of the grid, so there are <code>samples×samples</code> rays in total.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fields.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.HexagonalPrism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall hexagonal prism with axis <code>(0, 0, 1)</code>, the longer hexagon diameter is along the x axis. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Geometry.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C&lt;:(CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}})}, Tuple{T}} where T&lt;:Real" href="#OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C&lt;:(CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}})}, Tuple{T}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HexapolarField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over the entrance pupil of the system in a hexapolar pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fields.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.HexapolarField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HexapolarField(semidiameter, pupilpos; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)</code></pre><p>Distributes rays over a circular pupil with half-diameter defined by <code>semidiameter</code>, centred at <code>pupilpos</code> in a hexapolar pattern. <code>samples</code> is the number of rings in the hexapolar pattern, so the number of rays in total is <code>samples * (samples + 1) / 2) * 6 + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fields.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:Real}" href="#OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:Real}"><code>OpticSim.ModelEye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::Transform{T} = identitytransform(T))</code></pre><p>Geometrically accurate model of the human eye focussed at infinity with variable <code>pupil_radius</code>. The eye is added to the provided <code>assembly</code> to create a <a href="../systems/#OpticSim.CSGOpticalSystem"><code>CSGOpticalSystem</code></a> with the retina of the eye as the detector.</p><p>The eye can be positioned in the scene using the <code>transform</code> argument and the resolution of the detector specified with <code>detpixels</code>. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.</p><p><code>nsamples</code> determines the resolution at which accelerated surfaces within the eye are triangulated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Eye.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a plane i.e. <code>InfiniteStop{T,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L172-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a rectangle i.e. <code>FiniteStop{T,RectangularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec×surfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Stop.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T&lt;:Real" href="#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.RectangularPrism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall rectangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Geometry.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}" href="#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S}} where {R&lt;:OpticSim.GlassCat.AbstractGlass, Q&lt;:OpticSim.GlassCat.AbstractGlass, T&lt;:OpticSim.GlassCat.AbstractGlass, S&lt;:Real}"><code>OpticSim.SphericalLens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)</code></pre><p>Constructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Lenses.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Spider</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -&gt; Vector{Rectangle{T}}</code></pre><p>Creates a &#39;spider&#39; obscuration with <code>narms</code> rectangular arms evenly spaced around a circle defined by <code>origin</code> and <code>normal</code>. Each arm is a rectangle <code>armwidth</code>×<code>radius</code>.</p><p>e.g. for 3 and 4 arms we get:</p><pre><code class="language-none">   |         _|_
  / \         |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Geometry.jl#L156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.TriangularPrism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall triangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Geometry.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.area-Union{Tuple{SphericalPolygon{N, T}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}" href="#OpticSim.area-Union{Tuple{SphericalPolygon{N, T}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}"><code>OpticSim.area</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Conceptually breaks the convex spherical polygon into spherical triangles and computes the sum of the angles of all the triangles. The sum of all the angles around the centroid is 2π. Have to subtract π for each of the N triangles. Rather than compute the angles of triangles formed by taking edges from the centroid to each vertex, can instead just compute the internal angle of neighboring edges. Total polygon area is 2π -Nπ + ∑(interior angles).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/SphericalPolygon.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.assembly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assembly(system::AbstractOpticalSystem{T}) -&gt; LensAssembly{T}</code></pre><p>Get the <a href="#OpticSim.LensAssembly"><code>LensAssembly</code></a> of <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.closestintersection" href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -&gt; Union{Nothing,Intersection{T,3}}</code></pre><p>Returns the closest <a href="#OpticSim.Intersection"><code>Intersection</code></a> from an <a href="#OpticSim.Interval"><code>Interval</code></a> or <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a>. Ignores intersection with null interfaces if <code>ignorenull</code> is true. Will return <code>nothing</code> if there is no valid intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Interval.jl#L272-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}" href="#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}"><code>OpticSim.closestpointonray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">closestpointonray(r::Ray{T,N}, point::SVector{N,T}) -&gt; SVector{T,N</code></pre><p>Returns the point on the ray closest to point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Ray.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.curvedimension-Tuple{Array}" href="#OpticSim.curvedimension-Tuple{Array}"><code>OpticSim.curvedimension</code></a> — <span class="docstring-category">Method</span></header><section><div><p>spatial dimension of curve represented as an array of coefficients <code>x[i] = ∑Bj(θ)*x[i,j]</code> where <code>Bj(θ)</code> is the curve basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.curveorder-Tuple{Array}" href="#OpticSim.curveorder-Tuple{Array}"><code>OpticSim.curveorder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>highest polynomial power of the curve represented as an array of coefficients <code>x[i] = ∑Bj(θ)*x[i,j]</code> where <code>Bj(θ)</code> is the curve basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.detectorimage-Tuple{CSGOpticalSystem}" href="#OpticSim.detectorimage-Tuple{CSGOpticalSystem}"><code>OpticSim.detectorimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">detectorimage(system::AbstractOpticalSystem{T}) -&gt; HierarchicalImage{D}</code></pre><p>Get the detector image of <code>system</code>. <code>D</code> is the datatype of the detector image and is not necessarily the same as the datatype of the system <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}" href="#OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}"><code>OpticSim.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(r::Ray{T,N}, point::SVector{N,T}) -&gt; Union{Nothing,T}</code></pre><p>Returns distance to the position on the ray closest to point. If t &lt; 0 returns nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Ray.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArrays.SVector{3, T} where T}" href="#OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArrays.SVector{3, T} where T}"><code>OpticSim.distancefromplane</code></a> — <span class="docstring-category">Method</span></header><section><div><p>All planar shapes lie on a plane. This function computes the distance from a point to that plane. This is a signed distance. If the point is on the positive side of the plane (the side the normal points toward) the distance will be positive, otherwise negative or 0 if the point lies in the plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/PlanarShape.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real" href="#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real"><code>OpticSim.doesintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -&gt; Bool</code></pre><p>Tests whether <code>r</code> intersects an axis-aligned <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a>, <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/BoundingBox.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.evalcsg" href="#OpticSim.evalcsg"><code>OpticSim.evalcsg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evalcsg(
    a::Union{UnionNode{T},IntersectionNode{T},ComplementNode{T},LeafNode{T}},
    ray::AbstractRay{T,N},
    normalreverse::Bool = false
)::Union{EmptyInterval{T},DisjointUnion{T},Interval{T}}</code></pre><p>[TODO]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/CSG.jl#L203-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Matrix{T}, Real}} where T&lt;:Real" href="#OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Matrix{T}, Real}} where T&lt;:Real"><code>OpticSim.evaluatecurve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluates a curve defined in the power basis. Curves and moving lines accessed like this: <code>[xi,ci]</code> where <code>xi</code> is the dimension index, and <code>ci</code> is the coefficient index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.extractmovinglines-NTuple{4, Any}" href="#OpticSim.extractmovinglines-NTuple{4, Any}"><code>OpticSim.extractmovinglines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns 3D array indexed like this: <code>x[line curve order,spatial dimension, line number]</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.fresnel-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real" href="#OpticSim.fresnel-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real"><code>OpticSim.fresnel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fresnel(nᵢ::T, nₜ::T, sinθᵢ::T, sinθₜ::T) -&gt; Tuple{T,T}</code></pre><p>Returns reflectance and tranmission power coefficients according to the <a href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel equations</a>. For geometric ray tracing this coefficient can be used directly to compute intensity on the detector plane. For Huygens phase optics need to take the square root to compute the amplitude. The power of the transmitted and refracted rays may not sum to one because of the area correction applied to the transmitted component. The intensity per area can increase or decrease depending on the indices of refraction.</p><p><code>nᵢ</code> is the RI of the material which the incident ray travels in, <code>nₜ</code> is the RI of the material the transmitted ray travels in. <code>sinθᵢ</code> and <code>sinθₜ</code> are the sin of the angles of incidence and transmission respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fresnel.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.halfspaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">halfspaceintersection(a::Interval{T}) -&gt; Intersection{T,3}</code></pre><p>Returns the <a href="#OpticSim.Intersection"><code>Intersection</code></a> from a half space <a href="#OpticSim.Interval"><code>Interval</code></a>, throws an error if not a half space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Interval.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S&lt;:ParametricSurface{T, N}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S&lt;:ParametricSurface{T, N}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.interface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interface(surf::Surface{T}) -&gt; OpticalInterface{T}</code></pre><p>Return the <a href="../interfaces/#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> associated with <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AccelSurface.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T&lt;:Real, N}" href="#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T&lt;:Real, N}"><code>OpticSim.intersections</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns an array of intersection points. Each element in the array is (<code>[x,y,...],alpha,theta)</code> where <code>[x,y,...]</code> is the n-dimensional intersection point, alpha is the line parameter value at the intersection point, and theta is the curve parameter value at the intersection point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.isemptyinterval-Tuple{EmptyInterval}" href="#OpticSim.isemptyinterval-Tuple{EmptyInterval}"><code>OpticSim.isemptyinterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isemptyinterval(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a>. In performance critical contexts use <code>a isa EmptyInterval{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Interval.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.isinfinity-Tuple{Infinity}" href="#OpticSim.isinfinity-Tuple{Infinity}"><code>OpticSim.isinfinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinfinity(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts use <code>a isa Infinity{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Intersection.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.ispositivehalfspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispositivehalfspace(a) -&gt; Bool</code></pre><p>Returns true if <code>upper(a)</code> is <a href="#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts check directly i.e. <code>upper(a) isa Infinity{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Interval.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.israyorigin-Tuple{Any}" href="#OpticSim.israyorigin-Tuple{Any}"><code>OpticSim.israyorigin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">israyorigin(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts use <code>a isa RayOrigin{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Intersection.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.israyorigininterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">israyorigininterval(a) -&gt; Bool</code></pre><p>Returns true if <code>lower(a)</code> is <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts check directly i.e. <code>lower(a) isa RayOrigin{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Interval.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, T, T, StaticArrays.SVector{M, T}, StaticArrays.SVector{M, T}}} where {T&lt;:Real, N, M}" href="#OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, T, T, StaticArrays.SVector{M, T}, StaticArrays.SVector{M, T}}} where {T&lt;:Real, N, M}"><code>OpticSim.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian(surf::ParametricSurface{T,N}, u::T, v::T, P1::SVector{M,T}, P2::SVector{M,T})</code></pre><p>Computes Jacobian of <code>f(t,u,v) = ( dot(P1,[surf(u,v),1],P2,[surf(u,v),1]) )</code>. <code>P1</code>, <code>P2</code> are orthogonal planes that pass through the ray. <code>J = [ ∂f1/∂u ∂f1/∂v ; ∂f2/∂u ∂f2/∂v]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AccelSurface.jl#L220-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.leaf-Union{Tuple{ParametricSurface{T, N} where N}, Tuple{T}, Tuple{ParametricSurface{T, N} where N, StaticArrays.SMatrix{4, 4, T, 16}}} where T&lt;:Real" href="#OpticSim.leaf-Union{Tuple{ParametricSurface{T, N} where N}, Tuple{T}, Tuple{ParametricSurface{T, N} where N, StaticArrays.SMatrix{4, 4, T, 16}}} where T&lt;:Real"><code>OpticSim.leaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a leaf node from a parametric surface with a given transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/CSG.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.linedimension-Tuple{Array}" href="#OpticSim.linedimension-Tuple{Array}"><code>OpticSim.linedimension</code></a> — <span class="docstring-category">Method</span></header><section><div><p>spatial dimension of the moving line represented as an array of coefficients <code>g[i] = ∑Bl(θ)*gl[i,j]</code> where <code>Bl(θ)</code> is the polynomial basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T&lt;:Real}" href="#OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T&lt;:Real}"><code>OpticSim.makemesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makemesh(poly::ConvexPolygon{N, T}, ::Int = 0) where {N, T&lt;:Real} -&gt; TriangleMesh</code></pre><p>Create a triangle mesh that can be rendered by iterating on the polygon&#39;s edges and for each edge use the centroid as the third vertex of the triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/ConvexPolygon.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}" href="#OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}"><code>OpticSim.makemesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makemesh(object, subdivisions::Int = 30) -&gt; TriangleMesh</code></pre><p>Creates a <a href="#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> from an object, either a <a href="#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>, <a href="../csg/#OpticSim.CSGTree"><code>CSGTree</code></a> or certain surfaces (e.g. <code>Circle</code>, <code>Rectangle</code>). This is used for visualization purposes only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Array{T, 3}}} where {T, N}" href="#OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Array{T, 3}}} where {T, N}"><code>OpticSim.matricesforeigen</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>movinglines[:,i]</code> is the ith moving line. For <code>li = movinglines[:,i] (dimension+1,lineorder) = size(li)</code>. <code>rline[:,1] = pt1</code> and <code>rline[:,2] = pt2</code>. The line equation is <code>pt1 + alpha*pt2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, AbstractRay{T, N}, StaticArrays.SVector{2, T}}} where {T, N}" href="#OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, AbstractRay{T, N}, StaticArrays.SVector{2, T}}} where {T, N}"><code>OpticSim.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newton(surf::ParametricSurface{T,N}, r::AbstractRay{T,N}, startingpoint::SVector{2,T})</code></pre><p>Newton iteration to find the precise intersection of a parametric surface with a ray given a starting point (in uv space) on the surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AccelSurface.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T, N} where N, T, T}} where T&lt;:Real" href="#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T, N} where N, T, T}} where T&lt;:Real"><code>OpticSim.normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal(surf::ParametricSurface{T}, u::T, v::T) -&gt; SVector{3,T}
normal(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; SVector{3,T}</code></pre><p>Returns the normal to <code>surf</code> at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.numberoflines-Tuple{Array}" href="#OpticSim.numberoflines-Tuple{Array}"><code>OpticSim.numberoflines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>number of lines in moving line array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T" href="#OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T"><code>OpticSim.orthogonalitymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns a matrix expressing the relationship <code>[x(θ) 1]⋅g(θ) = 0</code>. The vectors in the right nullspace of this matrix contain the coefficients of the moving lines <code>gᵢ(θ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AnalyticIntersection.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.point-Tuple{OpticSim.VirtualPoint}" href="#OpticSim.point-Tuple{OpticSim.VirtualPoint}"><code>OpticSim.point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This will return (Inf,Inf,Inf) if the point is at infinity. In this case you probably should be using the direction of the VirtualPoint rather than its position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Paraxial.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T&lt;:Real}" href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point(ray::AbstractRay{T,N}, alpha::T) -&gt; SVector{T, N}</code></pre><p>Returns a point on the ray at origin + alpha * direction. Alpha must be &gt;= 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Ray.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArrays.SMatrix{2, N, T, L} where L}} where {N, T&lt;:Real}" href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArrays.SMatrix{2, N, T, L} where L}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns a 3D point. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Rectangle.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T&lt;:Real" href="#OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T&lt;:Real"><code>OpticSim.point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns a 3D point in the plane of the rectangle. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Rectangle.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pressure(system::AbstractOpticalSystem{T}) -&gt; T</code></pre><p>Get the pressure of <code>system</code> in Atm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool, Bool}} where {T&lt;:Real, N}" href="#OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool, Bool}} where {T&lt;:Real, N}"><code>OpticSim.processintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -&gt; Tuple{SVector{N,T}, T, T}</code></pre><p>Processes an intersection of an <a href="../ref/#OpticSim.OpticalRay"><code>OpticalRay</code></a> with an <a href="#OpticSim.OpticalInterface"><code>OpticalInterface</code></a>, distinct behaviors must be implemented for each subclass of <code>OpticalInterface</code>.</p><p><code>point</code> is the 3D intersection point in global space, <code>normal</code> is the surface normal at the intersection point.</p><p>If <code>test</code> is true then the behavior of the ray should be deterministic. <code>firstray</code> indicates that this ray is the first segment of the trace and therefore the origin is not offset.</p><p>The values returned are the normalized direction of the ray after the intersection, the <em>instantaneous</em> power of the ray after the intersection and the optical path length of the ray up to the intersection.</p><p><code>nothing</code> is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration <code>nothing</code> should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fresnel.jl#L111-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T" href="#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T"><code>OpticSim.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset!(a::HierarchicalImage{T})</code></pre><p>Resets the pixels in the image to <code>zero(T)</code>. Do this rather than <code>image .= zero(T)</code> because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/HierarchicalImage.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.resetdetector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resetdetector!(system::AbstractOpticalSystem{T})</code></pre><p>Reset the deterctor image of <code>system</code> to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.reversenormal-Union{Tuple{Intersection{T, N}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}" href="#OpticSim.reversenormal-Union{Tuple{Intersection{T, N}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}"><code>OpticSim.reversenormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reversenormal(a::Intersection{T,N})</code></pre><p>Used by the CSG complement operator (i.e. <a href="../csg/#Base.:-"><code>-</code></a>) to reverse the inside outside sense of the object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/Intersection.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T&lt;:Real, N}" href="#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T&lt;:Real, N}"><code>OpticSim.samplesurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)</code></pre><p>Sample a parametric surface on an even <code>numsamples</code>×<code>numsamples</code> grid in UV space with provided function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}" href="#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}"><code>OpticSim.semidiameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">semidiameter(system::AxisymmetricOpticalSystem{T}) -&gt; T</code></pre><p>Get the semidiameter of <code>system</code>, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S, S, T, T}} where {T&lt;:Real, S&lt;:(AbstractArray{T, N} where N)}" href="#OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S, S, T, T}} where {T&lt;:Real, S&lt;:(AbstractArray{T, N} where N)}"><code>OpticSim.snell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">snell(surfacenormal::AbstractVector{T}, raydirection::AbstractVector{T}, nᵢ::T, nₜ::T) -&gt; Tuple{T,T}</code></pre><p><code>nᵢ</code> is the index of refraction on the incidence side of the interface. <code>nₜ</code> is the index of refraction on the transmission side.</p><p>Returns <code>sinθᵢ</code> and <code>sinθₜ</code> according to <a href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell&#39;s law</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Fresnel.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.sphericalangle-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.sphericalangle-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.sphericalangle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the spherical angle formed by the cone with centervector at its center with neighbor1,neighbor2 the edges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/SphericalPolygon.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.sphericalcircle" href="#OpticSim.sphericalcircle"><code>OpticSim.sphericalcircle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>creates a circular polygon that subtends a half angle of θ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/SphericalPolygon.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T" href="#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T"><code>OpticSim.sum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})</code></pre><p>Add the contents of <code>b</code> to <code>a</code> in an efficient way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/HierarchicalImage.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S&lt;:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S&lt;:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}"><code>OpticSim.surfaceintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}</code></pre><p>Calculates the intersection of <code>r</code> with a surface of any type, <code>surf</code>. Note that some surfaces cannot be intersected analytically so must be wrapped in an <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a> in order to be intersected.</p><p>Returns an <a href="../csg/#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no <a href="../csg/#OpticSim.Intersection"><code>Intersection</code></a>, an <a href="../csg/#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections and a <a href="../csg/#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AccelSurface.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temperature(system::AbstractOpticalSystem{T}) -&gt; T</code></pre><p>Get the temperature of <code>system</code> in °C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRay{T, N}}} where {T&lt;:Real, N, D&lt;:Number}" href="#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRay{T, N}}} where {T&lt;:Real, N, D&lt;:Number}"><code>OpticSim.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(system::AbstractOpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)</code></pre><p>Traces <code>system</code> with <code>ray</code>, if <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a <a href="#OpticSim.LensTrace"><code>LensTrace</code></a> if the ray hits the detector or <code>nothing</code> otherwise.</p><p><code>trackrays</code> can be passed an empty vector to accumulate the <code>LensTrace</code> objects at each intersection of <code>ray</code> with a surface in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T&lt;:Real, N}" href="#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T&lt;:Real, N}"><code>OpticSim.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)</code></pre><p>Returns the ray as it exits the assembly in the form of a <a href="#OpticSim.LensTrace"><code>LensTrace</code></a> object if it hits any element in the assembly, otherwise <code>nothing</code>. Recursive rays are offset by a small amount (<code>RAY_OFFSET</code>) to prevent it from immediately reintersecting the same lens element.</p><p><code>trackrays</code> can be passed an empty vector to accumulate the <code>LensTrace</code> objects at each intersection of <code>ray</code> with a surface in the assembly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/LensAssembly.jl#L319-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> on a single thread. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. If <code>outpath</code> is specified then the result will be saved to this path.</p><p>Returns the detector image of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L470-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T&lt;:Real, S&lt;:Number}" href="#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T&lt;:Real, S&lt;:Number}"><code>OpticSim.traceMT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traceMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> using as many threads as possible. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. If <code>outpath</code> is specified then the result will be saved to this path.</p><p>Returns the accumulated detector image from all threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L530-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tracehits(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> on a single thread. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct.</p><p>Returns a list of <a href="#OpticSim.LensTrace"><code>LensTrace</code></a>s which hit the detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L766-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehitsMT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tracehitsMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> using as many threads as possible. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct.</p><p>Returns a list of <a href="#OpticSim.LensTrace"><code>LensTrace</code></a>s which hit the detector, accumulated from all threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/OpticalSystem.jl#L646-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.transform-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T}, StaticArrays.SMatrix{4, 4, T, 16}}} where T&lt;:Real" href="#OpticSim.transform-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T}, StaticArrays.SMatrix{4, 4, T, 16}}} where T&lt;:Real"><code>OpticSim.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(surf::CSGGenerator{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Returns a new CSGGenerator with another transform applied. This is useful if you want multiple copies of a premade CSG structure with different transforms, for example in an MLA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/CSG/CSG.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool, Bool}} where {T, N}" href="#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool, Bool}} where {T, N}"><code>OpticSim.triangulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)</code></pre><p>Create an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S}, AbstractRay{T, N}}} where {T&lt;:Real, N, S}" href="#OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S}, AbstractRay{T, N}}} where {T&lt;:Real, N, S}"><code>OpticSim.triangulatedintersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangulatedintersection(surf::AcceleratedParametricSurface{T,N,S}, r::AbstractRay{T,N})</code></pre><p>Intersection of a ray, <code>r</code>, with a triangulated surface, <code>surf</code>, no concept of inside so never returns a <a href="../csg/#OpticSim.RayOrigin"><code>RayOrigin</code></a> <a href="../csg/#OpticSim.Interval"><code>Interval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/AccelSurface.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real" href="#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.uv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uv(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; SVector{2,T}
uv(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; SVector{2,T}</code></pre><p>Returns the uv coordinate on <code>surf</code> of a point, <code>p</code>, in 3D space. If <code>onsurface(surf, p)</code> is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface" href="#OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface"><code>OpticSim.uvrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uvrange(s::ParametricSurface)
uvrange(::Type{S}) where {S&lt;:ParametricSurface}</code></pre><p>Returns a tuple of the form: <code>((umin, umax), (vmin, vmax))</code> specifying the limits of the parameterisation for this surface type. Also implemented for some <code>Surface</code>s which are not <code>ParametricSurface</code>s (e.g. <code>Rectangle</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Surface.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T}, StaticArrays.SVector{2, T}, Tuple{Int64, Int64}}} where T&lt;:Real" href="#OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T}, StaticArrays.SVector{2, T}, Tuple{Int64, Int64}}} where T&lt;:Real"><code>OpticSim.uvtopix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -&gt; Tuple{Int,Int}</code></pre><p>Converts a uvcoordinate on <code>surf</code> to an integer index to a pixel in an image of size <code>imsize</code>. Not implemented on all <code>Surface</code> objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an <a href="../systems/#OpticSim.AbstractOpticalSystem"><code>AbstractOpticalSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Rectangle.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.vertices-Tuple{OpticSim.PlanarShape}" href="#OpticSim.vertices-Tuple{OpticSim.PlanarShape}"><code>OpticSim.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The vertices of planar shapes are defined in a plane so they are two dimensional. In the local coordinate frame this is the x,y plane, so the implied z coordinate is 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/PlanarShape.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.vertices-Tuple{ParaxialLens}" href="#OpticSim.vertices-Tuple{ParaxialLens}"><code>OpticSim.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the 2 dimensional vertex points of the shape defining the lens aperture. These points lie in the plane of the shape</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Paraxial.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real" href="#OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the 2D vertices in the plane of the rectangle</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Rectangle.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the vertices of the Hexagon represented in the local coordinate frame. The vertices lie in the z = 0 plane and are 2D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Hexagon.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real" href="#OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the vertices of the rectangle in 3D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/NonCSG/Rectangle.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.virtualdistance-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.virtualdistance-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.virtualdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the virtual distance of the point from the lens plane. When |distance| == focallength then virtualdistance = ∞</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Paraxial.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T" href="#OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T"><code>OpticSim.virtualpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>computes the virtual point position corresponding to the input <code>point</code>, or returns nothing for points at infinity. <code>point</code> is specified in the lens coordinate frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Optical/Paraxial.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T&lt;:Real, N}" href="#OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T&lt;:Real, N}"><code>OpticSim.α</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">α(ray::AbstractRay{T,N}, point::SVector{N,T}) -&gt; T</code></pre><p>Computes the alpha corresponding to the closest position on the ray to point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Ray.jl#L99-L103">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transform(origin, forward) -&gt; Transform{S}</code></pre><p>Returns the <a href="../basic_types/#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the local frame with origin and forward direction. the other 2 axes are computed automaticlly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArrays.SVector{4, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArrays.SVector{4, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T&lt;:Real}</code></pre><p>Costruct a transform from the input columns.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transform(rotation::AbstractArray{T,2}, translation::AbstractArray{T,1}) where {T&lt;:Real} -&gt; Transform{S}</code></pre><p>Returns the <a href="../basic_types/#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) created by a rotation matrix (3x3) and translation vector of length 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, L} where L, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, L} where L, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transform(rotation::SMatrix{3,3,T}, translation::SVector{3,T}) where {T&lt;:Real} -&gt; Transform{S}</code></pre><p>Returns the <a href="../basic_types/#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) created by a rotation matrix and translation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}, NTuple{4, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}, NTuple{4, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T&lt;:Real}</code></pre><p>Costruct a transform from the input columns.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transform([S::Type]) -&gt; Transform{S}</code></pre><p>Returns the <a href="../basic_types/#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the identity transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SMatrix{3, N, T, L} where L}, Tuple{T}, Tuple{N}} where {N, T&lt;:Real}" href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SMatrix{3, N, T, L} where L}, Tuple{T}, Tuple{N}} where {N, T&lt;:Real}"><code>OpticSim.Geometry.Vec4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Vec4(m::SMatrix{3,N,T} where{N,T&lt;:Real} -&gt; SMatrix{3,N,T})</code></pre><p>Input is matrix of 3d points, each column is one point. Returns matrix of 3d points with 1 appended in the last row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Vec4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Vec4(v::SVector{3, T}) where {T&lt;:Real} -&gt; Vec4{T}</code></pre><p>Accept <code>SVector</code> and create a <code>Vec4</code> type [v[1], v[2], v[3], 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.decomposeRTS-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.decomposeRTS-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.decomposeRTS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decomposeRTS(tr::Transform{T}) where {T&lt;:Real}</code></pre><p>return a touple containing the rotation matrix, the translation vector and the scale vecto represnting the transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.forward-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}" href="#OpticSim.Geometry.forward-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.Geometry.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forward(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the third column, representing the &quot;Z&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.identitytransform</code></a> — <span class="docstring-category">Method</span></header><section><div><p>identitytransform([S::Type]) -&gt; Transform{S}</p><p>Returns the <a href="#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the identity transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.local2world-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.local2world-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.local2world</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">local2world(t::Transform{T}) where {T&lt;:Real}</code></pre><p>return the transform matrix that takes a point in the local coordinate system to the global one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L416-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.right-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}" href="#OpticSim.Geometry.right-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.Geometry.right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">right(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the first column, representing the &quot;X&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotate-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.rotate-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate(a::Transform{T}, vector::Union{Vec3{T}, SVector{3,T}}) where {T&lt;:Real} -&gt; Vec3{T}</code></pre><p>apply the rotation part of the transform <code>a</code> to the vector <code>vector</code> - this operation is usually used to rotate direction vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotation-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.rotation-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotation(t::Transform{T}) where {T&lt;:Real} -&gt; SMatrix{3,3,T}</code></pre><p>returns the rotation part of the transform <code>t</code> - a 3x3 matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotation([S::Type], θ::T, ϕ::T, ψ::T) -&gt; Transform{S}</code></pre><p>Returns the <a href="#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotationX-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.rotationX-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotationX(angle::T) where {T&lt;:Real} -&gt; Transform</code></pre><p>Builds a rotation matrix for a rotation around the x-axis.  Parameters:     The counter-clockwise <code>angle</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotationY-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.rotationY-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotationY(angle::T) where {T&lt;:Real} -&gt; Transform</code></pre><p>Builds a rotation matrix for a rotation around the y-axis.  Parameters:     The counter-clockwise <code>angle</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L280-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotationZ-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.rotationZ-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotationZ(angle::T) where {T&lt;:Real} -&gt; Transform</code></pre><p>Builds a rotation matrix for a rotation around the z-axis.  Parameters:     The counter-clockwise <code>angle</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotationd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotationd([S::Type], θ::T, ϕ::T, ψ::T) -&gt; Transform{S}</code></pre><p>Returns the <a href="#OpticSim.Geometry.Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in degrees</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L350-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmat([S::Type], θ::T, ϕ::T, ψ::T) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L507-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.rotmatbetween</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation between vetors <code>a</code> and <code>b</code>, i.e. rotation(a,b) * a = b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L484-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmatd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>θ</code>, <code>ϕ</code> and <code>ψ</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in degrees</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L499-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.scale-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.scale-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale(s::T) where {T&lt;:Real}</code></pre><p>Creates a uniform scaling transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L397-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.scale-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.scale-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale(t::Vec3{T}) where {T&lt;:Real}</code></pre><p>Creates a scaling transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L406-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real" href="#OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale(x::T, y::T, z::T) where {T&lt;:Real}</code></pre><p>Creates a scaling transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L383-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.translation-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.translation-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.translation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translation(x::T, y::T, z::T) where {T&lt;:Real}</code></pre><p>Creates a translation transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T&lt;:Number, S&lt;:Real}" href="#OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T&lt;:Number, S&lt;:Real}"><code>OpticSim.Geometry.translation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translation(x::T, y::T, z::T) where {T&lt;:Real}</code></pre><p>Creates a translation transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitW4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[0, 0, 0, 1]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[1, 0, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[1, 0, 0, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[0, 1, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[0, 1, 0, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[0, 0, 1]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unit vector <code>[0, 0, 1, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.up-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}" href="#OpticSim.Geometry.up-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.Geometry.up</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">up(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the second column, representing the &quot;Y&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Geometry.world2local-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.world2local-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.world2local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">world2local(t::Transform{T}) where {T&lt;:Real}</code></pre><p>return the transform matrix that takes a point in the global coordinate system to the local one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.origin-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}" href="#OpticSim.origin-Tuple{StaticArrays.SMatrix{4, 4, var&quot;#s31&quot;, 16} where var&quot;#s31&quot;&lt;:Real}"><code>OpticSim.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">origin(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the fourth column, containing the translation part of the transform in 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Transform.jl#L249-L253">source</a></section></article><h2 id="Zernike"><a class="docs-heading-anchor" href="#Zernike">Zernike</a><a id="Zernike-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike" href="#OpticSim.Zernike"><code>OpticSim.Zernike</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module to enclose <a href="https://en.wikipedia.org/wiki/Zernike_polynomials">Zernike polynomial</a> specific functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.NolltoNM-Tuple{Int64}" href="#OpticSim.Zernike.NolltoNM-Tuple{Int64}"><code>OpticSim.Zernike.NolltoNM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NolltoNM(j::Int) -&gt; Tuple{Int, Int}</code></pre><p>Convert Noll zernike index <code>j</code> to <code>(N,M)</code> form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.OSAtoNM-Tuple{Int64}" href="#OpticSim.Zernike.OSAtoNM-Tuple{Int64}"><code>OpticSim.Zernike.OSAtoNM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OSAtoNM(j::Int) -&gt; Tuple{Int, Int}</code></pre><p>Convert OSA zernike index <code>j</code> to <code>(N,M)</code> form according to formula <code>J = N * (N + 2) + M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>OpticSim.Zernike.R</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R(N::Int, M::Int, ρ::T) -&gt; T</code></pre><p>Evaluate radial polynomial <span>$R_{n}^{m}(\rho)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T&lt;:Real" href="#OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T&lt;:Real"><code>OpticSim.Zernike.normalisation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalisation(::Type{T}, N::Int, M::Int) -&gt; T</code></pre><p>Normalisation coefficient for Zernike polynomial term <span>$Z_{n}^{m}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T&lt;:Real" href="#OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T&lt;:Real"><code>OpticSim.Zernike.δζ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">δζ(N::Int, M::Int, ρ::T, ϕ::T) -&gt; Tuple{T,T}</code></pre><p>Evaluate partial derivatives of Zernike polynomial term <span>$Z_{n}^{m}(\rho, \phi)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T&lt;:Real" href="#OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T&lt;:Real"><code>OpticSim.Zernike.ζ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ζ(N::Int, M::Int, ρ::T, ϕ::T) -&gt; Tuple{T,T}</code></pre><p>Evaluate Zernike polynomial term <span>$Z_{n}^{m}(\rho, \phi)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Zernike.jl#L56-L60">source</a></section></article><h2 id="QType"><a class="docs-heading-anchor" href="#QType">QType</a><a id="QType-1"></a><a class="docs-heading-anchor-permalink" href="#QType" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType" href="#OpticSim.QType"><code>OpticSim.QType</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module to enclose QType polynomial specific functionality. For reference see:</p><ol><li><a href="https://www.osapublishing.org/viewmedia.cfm?uri=oe-18-19-19700&amp;seq=0"><em>Robust, efficient computational methods for axially symmetric optical aspheres</em> - G. W. Forbes, 2010</a></li><li><a href="https://www.osapublishing.org/viewmedia.cfm?uri=oe-20-3-2483&amp;seq=0"><em>Characterizing the shape of freeform optics</em> - G. W. Forbes, 2012</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Qtype.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T&lt;:Real, NP1}" href="#OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.S</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S(coeffs::SVector{NP1,T}, m::Int x::T) -&gt; T</code></pre><p>Evaluates <span>$\sum_{n=0}^{N}c_n^mQ_n^m(x)$</span> where <span>$c_n^m$</span> is either an <span>$\alpha$</span> or <span>$\beta$</span> QType coefficient and <span>$m \gt 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Qtype.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T&lt;:Real, NP1}" href="#OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.S0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S0(coeffs::SVector{NP1,T}, x::T) -&gt; T</code></pre><p>Evaluates <span>$\sum_{n=0}^{N}\alpha_n^0Q_n^0(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Qtype.jl#L268-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T&lt;:Real, NP1}" href="#OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.dS0dx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dS0dx(coeffs::SVector{NP1,T}, x::T) -&gt; T</code></pre><p>Evaluates <span>$\frac{\partial}{\partial x}\sum_{n=0}^{N}\alpha_n^0Q_n^0(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Qtype.jl#L296-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T&lt;:Real, NP1}" href="#OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T&lt;:Real, NP1}"><code>OpticSim.QType.dSdx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dSdx(coeffs::SVector{NP1,T}, x::T) -&gt; T</code></pre><p>Evaluates <span>$\frac{\partial}{\partial x}\sum_{n=0}^{N}c_n^mQ_n^m(x)$</span> where <span>$c_n^m$</span> is either an <span>$\alpha$</span> or <span>$\beta$</span> QType coefficient and <span>$m \gt 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Qtype.jl#L183-L187">source</a></section></article><h2 id="Chebyshev"><a class="docs-heading-anchor" href="#Chebyshev">Chebyshev</a><a id="Chebyshev-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev" href="#OpticSim.Chebyshev"><code>OpticSim.Chebyshev</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module to enclose <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev polynomial</a> specific functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Chebyshev.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real" href="#OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.T</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T(n::Int, q::R, fast::Bool = true) -&gt; R</code></pre><p>Evaluate Chebyshev polynomial of the first kind <span>$T_n(q)$</span>.</p><p><code>fast</code> will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Chebyshev.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real" href="#OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U(n::Int, q::R, fast::Bool = true) -&gt; R</code></pre><p>Evaluate Chebyshev polynomial of the second kind <span>$U_n(q)$</span>.</p><p><code>fast</code> will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Chebyshev.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real" href="#OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R&lt;:Real"><code>OpticSim.Chebyshev.dTdq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dTdq(n::Int, q::R, fast::Bool = true) -&gt; R</code></pre><p>Evaluate derivative of Chebyshev polynomial of the first kind <span>$\frac{dT_n}{dq}(q)$</span>.</p><p><code>fast</code> will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Geometry/Primitives/Chebyshev.jl#L59-L65">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples" href="#OpticSim.Examples"><code>OpticSim.Examples</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Contains example usage of the features in the OpticSim.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/Examples.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.drawhex12RGB-Tuple{}" href="#OpticSim.Examples.drawhex12RGB-Tuple{}"><code>OpticSim.Examples.drawhex12RGB</code></a> — <span class="docstring-category">Method</span></header><section><div><p>draw 3 repeats of hex12RGB cluster </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.drawhex3RGB-Tuple{}" href="#OpticSim.Examples.drawhex3RGB-Tuple{}"><code>OpticSim.Examples.drawhex3RGB</code></a> — <span class="docstring-category">Method</span></header><section><div><p>draw 3 repeats of hex3RGB cluster </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.drawhexneighbors-Tuple{}" href="#OpticSim.Examples.drawhexneighbors-Tuple{}"><code>OpticSim.Examples.drawhexneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>draw the 2 ring neighbors of the hex cell at coordinates (0,0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.drawhexrect-Tuple{}" href="#OpticSim.Examples.drawhexrect-Tuple{}"><code>OpticSim.Examples.drawhexrect</code></a> — <span class="docstring-category">Method</span></header><section><div><p>draw hex cells that fit within a rectangular box centered at coordinates (0,0). Use fill color yellow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.drawhexrectcolors-Tuple{}" href="#OpticSim.Examples.drawhexrectcolors-Tuple{}"><code>OpticSim.Examples.drawhexrectcolors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>draw hex cells that fit within a rectangular box centered at coordinates (0,0). Use random fill colors selected for maximum distinguishability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.drawhexregion-Tuple{}" href="#OpticSim.Examples.drawhexregion-Tuple{}"><code>OpticSim.Examples.drawhexregion</code></a> — <span class="docstring-category">Method</span></header><section><div><p>draw hex cell at coordinates (0,0) and the 1 and 2 ring neighbors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.hemisphere-Tuple{}" href="#OpticSim.Examples.hemisphere-Tuple{}"><code>OpticSim.Examples.hemisphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hemisphere()</code></pre><p>Create a geometric hemisphere</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/other_examples.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.hex3RGB-Tuple{}" href="#OpticSim.Examples.hex3RGB-Tuple{}"><code>OpticSim.Examples.hex3RGB</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a ClusterWithProperties with three types of elements, R,G,B </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.hex3cluster-Tuple{}" href="#OpticSim.Examples.hex3cluster-Tuple{}"><code>OpticSim.Examples.hex3cluster</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a LatticeCluser with three elements at (0,0),(-1,0),(-1,1) coordinates in the HexBasis1 lattice</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.hexRGBW-Tuple{}" href="#OpticSim.Examples.hexRGBW-Tuple{}"><code>OpticSim.Examples.hexRGBW</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a ClusterWithProperties with four types of elements, R,G,B,W </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/repeating_structure_examples.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpticSim.Examples.opticalhemisphere-Tuple{}" href="#OpticSim.Examples.opticalhemisphere-Tuple{}"><code>OpticSim.Examples.opticalhemisphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">opticalhemisphere()</code></pre><p>Create an optical hemisphere that has optical material properties so it will reflect and refract light. In the previous example the hemisphere object had optical properties of Air, which is the default optical interface, so it won&#39;t refract or reflect light.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/microsoft/OpticSim.jl/blob/61bc6876339a82933b5448f8920ae9a7c1d85ecc/src/Examples/other_examples.jl#L21-L27">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../notebooksutils/">« Notebook utilities</a><a class="docs-footer-nextpage" href="../roadmap/">Roadmap »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 7 September 2021 10:52">Tuesday 7 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
