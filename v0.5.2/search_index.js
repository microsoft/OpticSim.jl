var documenterSearchIndex = {"docs":
[{"location":"glasscat/#GlassCat","page":"Glass Functions","title":"GlassCat","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"This submodule is used to download, parse, install and manage AGF glass specifications for use in OpticSim.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"The central configuration file for GlassCat is located at src/GlassCat/data/sources.txt, which ships with the following default entries.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"NIKON a49714470fa875ad4fd8d11cbc0edbf1adfe877f42926d7612c1649dd9441e75 https://www.nikon.com/products/components/assets/pdf/nikon_zemax_data.zip\nOHARA 0c9021bf11b8d4e660012191818685ad3110d4f9490699cabdc89aae1fd26d2e https://www.oharacorp.com/xls/OHARA_201130_CATALOG.zip\nHOYA b02c203e5a5b7a8918cc786badf0a9db1fe2572372c1c163dc306b0a8a908854 http://www.hoya-opticalworld.com/common/agf/HOYA20210105.agf\nSCHOTT e9aabbb8ebff116ba0c106a71afd86e72f2a397ac9bc447469129e325e795f4e https://www.schott.com/d/advanced_optics/6959f9a4-0e4f-4ef2-a302-2347468a82f5/1.31/schott-optical-glass-overview-zemax-format.zip\nSUMITA c1093e42a1d08acbe30698aba730161e3b43f8f0d50533f65de8b6b11100fdc8 https://www.sumita-opt.co.jp/en/wp/wp-content/themes/sumita-opt-en/download-files.php files%5B%5D=new_sumita.agf&category=data","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Each line corresponds to one AGF source, which is described by 2 to 4 space-delimited columns. The first column provides the installed module name for the catalog, e.g. GlassCat.NIKON. The second column is the expected SHA256 checksum for the AGF file.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"The final two columns are optional, specifying download instructions for acquiring the zipped AGF files automatically from the web. The fourth column allows us to use POST requests to acquire files from interactive sites.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"When ] build OpticSim is run, the sources are verified and parsed into corresponding Julia files. These are then included in OpticSim via AGFGlassCat.jl. These steps are run automatically when the package is first installed using ] add OpticSim, creating a sufficient working environment for our examples and tests.","category":"page"},{"location":"glasscat/#Adding-glass-catalogs","page":"Glass Functions","title":"Adding glass catalogs","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"sources.txt can be edited freely to add more glass catalogs. However, this is a somewhat tedious process, so we have a convenience function for adding a locally downloaded AGF file to the source list.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.add_agf","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.add_agf","page":"Glass Functions","title":"OpticSim.GlassCat.add_agf","text":"add_agf(agffile; agfdir = AGF_DIR, sourcefile = SOURCES_PATH, name = nothing, rebuild = true)\n\nCopies a file at agffile (this can be either a download link or local path) to agfdir and appends a corresponding entry to the source list at sourcefile.\n\nIf a name is not provided for the catalog, an implicit name is derived from agffile.\n\nIf rebuild is true, Pkg.build is called at the end to install the new catalog.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#Using-installed-glasses","page":"Glass Functions","title":"Using installed glasses","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Glass types are accessed like so: OpticSim.GlassCat.CATALOG_NAME.GLASS_NAME, e.g.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.SUMITA.LAK7\nOpticSim.GlassCat.SCHOTT.PK3","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"All glasses and catalogs are exported in their respective modules, so it is possible to invoke using calls for convenience, e.g.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"using OpticSim\nGlassCat.SUMITA.LAK7\nusing OpticSim.GlassCat\nSCHOTT.PK3\nusing OpticsSim.GlassCat.SCHOTT\nN_BK7","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Autocompletion can be used to see available catalogs and glasses. All catalog glasses are of type OpticSim.GlassCat.Glass. Note that special characters in glass/catalog names are replaced with _. There is a special type and constant value for air: OpticSim.GlassCat.Air.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"Unitful.jl is used to manage units, meaning any valid unit can be used for all arguments, e.g., wavelength can be passed in as μm or nm (or cm, mm, m, etc.). Non-unitful options are also available, in which case units are assumed to be μm, °C and Atm for length, temperature and pressure respectively.","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"TEMP_REF and PRESSURE_REF are constants:","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"const TEMP_REF = 20.0 # °C\nconst PRESSURE_REF = 1.0 # Atm","category":"page"},{"location":"glasscat/#Types","page":"Glass Functions","title":"Types","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.AbstractGlass\nOpticSim.GlassCat.Glass\nOpticSim.GlassCat.Air\nOpticSim.GlassCat.GlassID","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.AbstractGlass","page":"Glass Functions","title":"OpticSim.GlassCat.AbstractGlass","text":"Abstract type encapsulating all glasses.\n\n\n\n\n\n","category":"type"},{"location":"glasscat/#OpticSim.GlassCat.Glass","page":"Glass Functions","title":"OpticSim.GlassCat.Glass","text":"Stores all attributes relating to a glass type specified in an .AGF glass catalog.\n\nNever used directly, instead created using catalog glasses, e.g. GlassCat.SCHOTT.N_BK7.\n\nIn order to prevent type ambiguities in OpticSim.jl we can't have this type paramaterized.\n\n\n\n\n\n","category":"type"},{"location":"glasscat/#OpticSim.GlassCat.Air","page":"Glass Functions","title":"OpticSim.GlassCat.Air","text":"Special glass to represent air. Refractive index is defined to always be 1.0 for any temperature and pressure (other indices are relative to this).\n\n\n\n\n\n","category":"constant"},{"location":"glasscat/#OpticSim.GlassCat.GlassID","page":"Glass Functions","title":"OpticSim.GlassCat.GlassID","text":"Object identifying a glass, containing a type (e.g. MODEL, MIL, OTHER or AGF) depending on how the glass is defined, and an integer ID. Air is AIR:0, others are on the form AGF:N, for example.\n\n\n\n\n\n","category":"type"},{"location":"glasscat/#Functions","page":"Glass Functions","title":"Functions","text":"","category":"section"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.index\nOpticSim.GlassCat.absairindex\nOpticSim.GlassCat.absorption","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.index","page":"Glass Functions","title":"OpticSim.GlassCat.index","text":"index(glass::AbstractGlass, wavelength; temperature=20°C, pressure=1Atm)\n\nCompute the refractive index of glass at wavelength, optionally at specified temperature and pressure. Result is relative to the refractive index of air at given temperature and pressure.\n\nIf unitless, arguments are interpretted as μm, °C and Atm respectively.\n\nThis is defined to always equal 1.0 for Air at any temperature and pressure, use absairindex for the absolute refractive index of air at a given temperature and pressure.\n\nExamples\n\njulia> index(GlassCat.SUMITA.LAK7, 700u\"nm\")\n1.646494204478318\n\njulia> index(GlassCat.SCHOTT.N_BK7, 0.55, temperature = 22.0)\n1.51852824383283\n\njulia> index(GlassCat.HOYA.FF1, 532u\"nm\", temperature = 25u\"°C\", pressure = 1.3)\n1.5144848290944655\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.absairindex","page":"Glass Functions","title":"OpticSim.GlassCat.absairindex","text":"absairindex(wavelength; temperature=20°C, pressure=1Atm)\n\nCompute the absolute refractive index of air at wavelength, optionally at specified temperature and pressure. If unitless, arguments are interpretted as μm, °C and Atm respectively.\n\nExamples\n\njulia> absairindex(700u\"nm\")\n1.000271074905147\n\njulia> absairindex(0.7, temperature=27.0)\n1.000264738846504\n\njulia> absairindex(532u\"nm\", temperature = 25u\"°C\", pressure = 1.3)\n1.0003494991178161\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.absorption","page":"Glass Functions","title":"OpticSim.GlassCat.absorption","text":"absorption(glass::AbstractGlass, wavelength; temperature=20°C, pressure=1Atm)\n\nCompute the intensity absorption per mm of glass at wavelength, optionally at specified temperature and pressure. Transmission values are linearly interpolated from the adjacent values in the data table of glass, if wavelength is below the minimum or above the maximum in the table then the nearest value is taken.\n\nAbsorption is defined as frac-log(t)tau where t is the transmission value and tau is the thickness, both of which are provided in the data table.\n\nIf unitless, arguments are interpretted as μm, °C and Atm respectively.\n\nExamples\n\njulia> absorption(GlassCat.SUMITA.LAK7, 700u\"nm\")\n0.0006018072325563021\n\njulia> absorption(GlassCat.SCHOTT.N_BK7, 0.55, temperature = 22.0)\n0.00016504471175660636\n\njulia> absorption(GlassCat.SCHOTT.PSK3, 532u\"nm\", temperature = 25u\"°C\", pressure = 1.3)\n0.00020855284788532435\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.glassfromMIL\nOpticSim.GlassCat.modelglass","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.glassfromMIL","page":"Glass Functions","title":"OpticSim.GlassCat.glassfromMIL","text":"glassfromMIL(glasscode::Union{Float64,Int}) -> Glass\n\nGenerates a glass object for the given glass code based on U.S. military standard MIL-G-174, see the MIL specification for further details.\n\nThe glass code is a six-digit number specifying the glass according to its refractive index Nd at d-light (587.5618nm), and its Abbe number Vd also taken at d-light. The resulting glass code is the value of Nd - 1 rounded to three digits, followed by Vd rounded to three digits, with all decimal points ignored. For example, N_BK7 has Nd = 1.5168 and Vd = 64.17, giving a six-digit glass code of 517642.\n\nFor Nd > 1.999 the format 1.123642 can be used representing Nd = 2.123 and Vd = 64.2.\n\nAccuracy is poor given the low precision of the input parameters, the mean error to measured data may be significant. Behavior may differ from other optical simulation tools when using MIL glasses. The approximate dispersion calculation used these glasses is generally only valid for visible wavelengths, in this case a limit of 360nm to 750nm is imposed.\n\nExamples\n\njulia> index(glassfromMIL(517642), 0.5875618)\n1.5170003960064509\n\njulia> index(glassfromMIL(1.134642), 0.5875618)\n2.1340008686098946\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.modelglass","page":"Glass Functions","title":"OpticSim.GlassCat.modelglass","text":"modelglass(Nd::Float64, Vd::Float64, ΔPgF::Float64) -> Glass\n\nGenerates a glass object for the given refractive index at d-light (587.5618nm), Nd, the Abbe number also at d-light, Vd, and partial dispersion, ΔPgF. The mean error to measured data for these models is typically small - usually < 0.0001. Behavior may differ from other optical simulation tools when using model glasses.\n\nThe approximate dispersion calculation used for these glasses is generally only valid for visible wavelengths, in this case a limit of 360nm to 750nm is imposed.\n\nExamples\n\njulia> index(modelglass(1.5168, 64.17, 0.0), 0.5875618)\n1.5168003970108495\n\njulia> index(modelglass(1.2344, 61.57, 0.003), 0.678)\n1.2329425902693352\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.glasscatalogs\nOpticSim.GlassCat.glassnames\nOpticSim.GlassCat.info\nOpticSim.GlassCat.findglass\nOpticSim.GlassCat.isair","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.glasscatalogs","page":"Glass Functions","title":"OpticSim.GlassCat.glasscatalogs","text":"glasscatalogs()\n\nReturns the complete list of glass catalogs available from GlassCat.\n\nExample\n\njulia> glasscatalogs()\n41-element Array{Any,1}:\n OpticSim.GlassCat.AMTIR\n OpticSim.GlassCat.ANGSTROMLINK\n OpticSim.GlassCat.APEL\n OpticSim.GlassCat.ARCHER\n OpticSim.GlassCat.ARTON\n OpticSim.GlassCat.AUER_LIGHTING\n OpticSim.GlassCat.BIREFRINGENT\n ⋮\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.glassnames","page":"Glass Functions","title":"OpticSim.GlassCat.glassnames","text":"glassnames(catalog::Module)\n\nReturns the glass names available from a given catalog.\n\nExample\n\njulia> glassnames(GlassCat.CARGILLE)\n3-element Array{Any,1}:\n \"OG0607\"\n \"OG0608\"\n \"OG081160\"\n\n\n\n\n\nglassnames()\n\nReturns the glass names available from all catalogs.\n\nExample\n\njulia> glassnames()\n6-element Array{Pair{Module,Array{Any,1}},1}:\n OpticSim.GlassCat.CARGILLE => [\"OG0607\", \"OG0608\", \"OG081160\"]\n     OpticSim.GlassCat.HOYA => [\"BAC4\", \"BACD11\"  …  \"TAFD65\"]\n    OpticSim.GlassCat.NIKON => [\"BAF10\", \"BAF11\"  …  \"_7054\"]\n    OpticSim.GlassCat.OHARA => [\"L_BAL35\", \"L_BAL35P\"  …  \"S_TIM8\"]\n   OpticSim.GlassCat.SCHOTT => [\"AF32ECO\", \"BAFN6\"  …  \"SFL6\"]\n   OpticSim.GlassCat.SUMITA => [\"BAF1\", \"BAF10\"  …  \"ZNSF8\"]\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.info","page":"Glass Functions","title":"OpticSim.GlassCat.info","text":"info([io::IO], glass::AbstractGlass)\n\nPrint out all data associated with glass in an easily readable format.\n\nExamples\n\njulia> info(GlassCat.RPO.IG4)\nID:                                                AGF:52\nDispersion formula:                                Schott (1)\nDispersion formula coefficients:\n     a₀:                                           6.91189161\n     a₁:                                           -0.000787956404\n     a₂:                                           -4.22296071\n     a₃:                                           142.900646\n     a₄:                                           -1812.32748\n     a₅:                                           7766.33028\nValid wavelengths:                                 3.0μm to 12.0μm\nReference temperature:                              20.0°C\nThermal ΔRI coefficients:\n     D₀:                                           3.24e-5\n     D₁:                                           0.0\n     D₂:                                           0.0\n     E₀:                                           0.0\n     E₁:                                           0.0\n     λₜₖ:                                          0.0\nTCE (÷1e-6):                                       20.4\nIgnore thermal expansion:                          false\nDensity (p):                                       4.47g/m³\nΔPgF:                                              0.0\nRI at sodium D-Line (587nm):                       1.0\nAbbe Number:                                       0.0\nCost relative to N_BK7:                              ?\nStatus:                                            Standard (0)\nMelt frequency:                                    0\nExclude substitution:                              false\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.findglass","page":"Glass Functions","title":"OpticSim.GlassCat.findglass","text":"findglass(condition::Function) -> Vector{Glass}\n\nReturns the list of glasses which satisfy condition where condition::(Glass -> Bool).\n\nExample\n\njulia> findglass(x -> (x.Nd > 2.3 && x.λmin < 0.5 && x.λmax > 0.9))\n8-element Array{GlassCat.Glass,1}:\n BIREFRINGENT.TEO2_E\n BIREFRINGENT.PBMOO4\n BIREFRINGENT.LINBO3\n INFRARED.CLEARTRAN_OLD\n INFRARED.CLEARTRAN\n INFRARED.SRTIO3\n INFRARED.ZNS_BROAD\n INFRARED.ZNS_VIS\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.isair","page":"Glass Functions","title":"OpticSim.GlassCat.isair","text":"isair(a) -> Bool\n\nTests if a is Air.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.glassname\nOpticSim.GlassCat.glassid\nOpticSim.GlassCat.glassforid","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.glassname","page":"Glass Functions","title":"OpticSim.GlassCat.glassname","text":"glassname(g::Union{AbstractGlass,GlassID})\n\nGet the name (including catalog) of the glass, or glass with this ID.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.glassid","page":"Glass Functions","title":"OpticSim.GlassCat.glassid","text":"glassid(g::AbstractGlass) -> GlassID\n\nGet the ID of the glass, see GlassID.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.glassforid","page":"Glass Functions","title":"OpticSim.GlassCat.glassforid","text":"glassforid(ID::GlassID)\n\nGet the glass for a given ID.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.polyfit_indices\nOpticSim.GlassCat.plot_indices\nOpticSim.GlassCat.drawglassmap","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.polyfit_indices","page":"Glass Functions","title":"OpticSim.GlassCat.polyfit_indices","text":"polyfit_indices(wavelengths, n_rel; degree=5)\n\nFit a polynomial to indices at wavelengths, optionally specifying the degree of the polynomial. Returns tuple of array of fitted indices at wavelengths and the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.plot_indices","page":"Glass Functions","title":"OpticSim.GlassCat.plot_indices","text":"plot_indices(glass::AbstractGlass; polyfit=false, fiterror=false, degree=5, temperature=20°C, pressure=1Atm, nsamples=300, sampling_domain=\"wavelength\")\n\nPlot the refractive index for glass for nsamples within its valid range of wavelengths, optionally at temperature and pressure. polyfit will show a polynomial of optionally specified degree fitted to the data, fiterror will also show the fitting error of the result. sampling_domain specifies whether the samples will be spaced uniformly in \"wavelength\" or \"wavenumber\".\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.drawglassmap","page":"Glass Functions","title":"OpticSim.GlassCat.drawglassmap","text":"drawglassmap(glasscatalog::Module; λ::Length = 550nm, glassfontsize::Integer = 3, showprefixglasses::Bool = false)\n\nDraw a scatter plot of index vs dispersion (the derivative of index with respect to wavelength). Both index and dispersion are computed at wavelength λ.\n\nIf showprefixglasses is true then glasses with names like F_BAK7 will be displayed. Otherwise glasses that have a leading letter prefix followed by an underscore, such as F_, will not be displayed.\n\nThe index formulas for some glasses may give incorrect results if λ is outside the valid range for that glass. This can give anomalous results, such as indices less than zero or greater than 6. To filter out these glasses set maximumindex to a reasonable value such as 3.0.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"","category":"page"},{"location":"glasscat/","page":"Glass Functions","title":"Glass Functions","text":"OpticSim.GlassCat.verify_sources!\nOpticSim.GlassCat.verify_source\nOpticSim.GlassCat.download_source","category":"page"},{"location":"glasscat/#OpticSim.GlassCat.verify_sources!","page":"Glass Functions","title":"OpticSim.GlassCat.verify_sources!","text":"verify_sources!(sources::AbstractVector{<:AbstractVector{<:AbstractString}}, agfdir::AbstractString)\n\nVerify a list of sources located in agfdir. If AGF files are missing or invalid, try to download them using the information provided in sources.\n\nEach source ∈ sources is a collection of strings in the format name, sha256sum, url [, POST_data], where the last optional string is used to specify data to be sent in a POST request. This allows us to download a greater range of sources (e.g. SUMITA).\n\nModifies sources in-place such that only verified sources remain.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.verify_source","page":"Glass Functions","title":"OpticSim.GlassCat.verify_source","text":"verify_source(agffile::AbstractString, expected_sha256sum::AbstractString)\n\nVerify a source file using SHA256, returning true if successful. Otherwise, remove the file and return false.\n\n\n\n\n\n","category":"function"},{"location":"glasscat/#OpticSim.GlassCat.download_source","page":"Glass Functions","title":"OpticSim.GlassCat.download_source","text":"download_source(dest::AbstractString, url::AbstractString, POST_data::Union{Nothing,AbstractString} = nothing)\n\nDownload and unzip an AGF glass catalog from a publicly available source. Supports POST requests.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We are currently in the early stages of implementing optimization for lens surfaces.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We have had success using Optim.jl and ForwardDiff.jl among other packages, though ForwardDiff.jl gradient and hessian pre-compilation can be very slow for complex systems.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Other optimization packages should integrate easily with the system too: JuMP.jl, Ipopt.jl and NLOpt.jl are some options.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Merit functions must currently be implemented by the user, this is quite straight-forward as trace returns the vast majority of information that could be needed in the form of a LensTrace which hits the detector (or nothing if the ray doesn't reach the detector).","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"There are some helper functions implemented for AxisymmetricOpticalSystems which can make optimization of basic systems much easier:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"OpticSim.Optimization\nOpticSim.Optimization.optimizationvariables\nOpticSim.Optimization.updateoptimizationvariables","category":"page"},{"location":"optimization/#OpticSim.Optimization","page":"Optimization","title":"OpticSim.Optimization","text":"Optimization interface consists of two functions optimizationvariables and updateoptimizationvariables. optimizationvariables packs variables to be optimized into a vector. updateoptimizationvariables receives a vector of variables and creates a new optical system with the variable values.\n\n\n\n\n\n","category":"module"},{"location":"optimization/#OpticSim.Optimization.optimizationvariables","page":"Optimization","title":"OpticSim.Optimization.optimizationvariables","text":"optimizationvariables(a::AxisymmetricOpticalSystem{T}) -> Vector{T}\n\nPack variables that have been marked to be optimized into a vector in a form suitable for the optimizer. Variables are marked for optimization by having a true value in the :OptimizeName column, where Name can be Radius, Thickness or Conic.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#OpticSim.Optimization.updateoptimizationvariables","page":"Optimization","title":"OpticSim.Optimization.updateoptimizationvariables","text":"updateoptimizationvariables(a::AxisymmetricOpticalSystem{T}, optimizationvariables::Vector{S}) -> AxisymmetricOpticalSystem{S}\n\nCreates a new optical system with updated variables corresponding to the optimization variables.\n\n\n\n\n\n","category":"function"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"It is of course possible to write your own optimization loop for more complex (i.e. non-AxisymmetricOpticalSystem) systems and this should work without issue.","category":"page"},{"location":"optimization/#Example","page":"Optimization","title":"Example","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"using OpticSim\nusing ForwardDiff\nusing Optim\n\nfunction objective(a::AbstractVector{T}, b::AxisymmetricOpticalSystem{T}, samples::Int = 3) where {T}\n    # RMSE spot size\n    system = Optimization.updateoptimizationvariables(b, a)\n    # distribute rays evenly across entrance pupil using HexapolarField\n    field = HexapolarField(system, collimated = true, samples = samples)\n    error = zero(T)\n    hits = 0\n    for r in field\n        traceres = trace(system, r, test = true)\n        if traceres !== nothing # ignore rays which miss\n            hitpoint = point(traceres)\n            if abs(hitpoint[1]) > eps(T) && abs(hitpoint[2]) > eps(T)\n                dist_to_axis = hitpoint[1]^2 + hitpoint[2]^2\n                error += dist_to_axis\n            end\n            hits += 1\n        end\n    end\n    if hits > 0\n        error = sqrt(error / hits)\n    end\n    # if hits == 0 returns 0 - not ideal!\n    return error\nend\n\nstart, lower, upper = Optimization.optimizationvariables(system)\noptimobjective = arg -> objective(arg, system)\ngcfg = ForwardDiff.GradientConfig(optimobjective, start, ForwardDiff.Chunk{1}()) # speed up ForwardDiff significantly\nhcfg = ForwardDiff.HessianConfig(optimobjective, start, ForwardDiff.Chunk{1}())\ng! = (G, x) -> ForwardDiff.gradient!(G, optimobjective, x, gcfg)\nh! = (H, x) -> ForwardDiff.hessian!(H, optimobjective, x, hcfg)\ndf = TwiceDifferentiable(optimobjective, g!, h!, start)\ndfc = TwiceDifferentiableConstraints(lower, upper) # constrain the optimization to avoid e.g. thickness < 0\nres = optimize(df, dfc, start, algo, Optim.Options(show_trace = true, iterations = 100, allow_f_increases = true))\nfinal = Optim.minimizer(res)\nnew_system = Optimization.updateoptimizationvariables(system, final)","category":"page"},{"location":"systems/#Optical-Systems","page":"Systems","title":"Optical Systems","text":"","category":"section"},{"location":"systems/#Assemblies","page":"Systems","title":"Assemblies","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"All systems are made up of a LensAssembly which contains all the optical components in the system, excluding any sources (see Emitters) and the detector (see below).","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"LensAssembly","category":"page"},{"location":"systems/#OpticSim.LensAssembly","page":"Systems","title":"OpticSim.LensAssembly","text":"LensAssembly{T<:Real}\n\nStructure which contains the elements of the optical system, these can be CSGTree or Surface objects.\n\nIn order to prevent type ambiguities bespoke structs are created for each possible number of elements e.g. LensAssembly3. These are parameterized by the types of the elements to prevent ambiguities. Basic surface types such as Rectangle (which can occur in large numbers) are stored independently in Vectors, so type paramters are only needed for CSG objects.\n\nEach struct looks like this:\n\nstruct LensAssemblyN{T,T1,T2,...,TN} <: LensAssembly{T}\n    axis::SVector{3,T}\n    rectangles::Vector{Rectangle{T}}\n    ellipses::Vector{Ellipse{T}}\n    hexagons::Vector{Hexagon{T}}\n    paraxials::Vector{ParaxialLens{T}}\n    E1::T1\n    E2::T2\n    ...\n    EN::TN\nend\n\nWhere Ti <: Union{Surface{T},CSGTree{T}}.\n\nTo create a LensAssembly object the following functions can be used:\n\nLensAssembly(elements::Vararg{Union{Surface{T},CSGTree{T},LensAssembly{T}}}; axis = SVector(0.0, 0.0, 1.0)) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"systems/#Images","page":"Systems","title":"Images","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"The detector image is stored within the system as a HierarchicalImage for memory efficiency.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"HierarchicalImage\nOpticSim.reset!\nOpticSim.sum!","category":"page"},{"location":"systems/#OpticSim.HierarchicalImage","page":"Systems","title":"OpticSim.HierarchicalImage","text":"HierarchicalImage{T<:Number} <: AbstractArray{T,2}\n\nImage type which dynamically allocated memory for pixels when their value is set, the value of unset pixels is assumed to be zero.\n\nThis is used for the detector image of AbstractOpticalSystems which can typically be very high resolution, but often have a large proportion of the image blank.\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.reset!","page":"Systems","title":"OpticSim.reset!","text":"reset!(a::HierarchicalImage{T})\n\nResets the pixels in the image to zero(T). Do this rather than image .= zero(T) because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.sum!","page":"Systems","title":"OpticSim.sum!","text":"sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})\n\nAdd the contents of b to a in an efficient way.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"There are two types of AbstractOpticalSystem which can be used depending on the requirements.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"AbstractOpticalSystem\nCSGOpticalSystem\nAxisymmetricOpticalSystem\ntemperature\npressure\ndetectorimage\nresetdetector!\nassembly\nsemidiameter","category":"page"},{"location":"systems/#OpticSim.AbstractOpticalSystem","page":"Systems","title":"OpticSim.AbstractOpticalSystem","text":"AbstractOpticalSystem{T<:Real}\n\nAbstract type for any optical system, must parameterized by the datatype of entities within the system T.\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.CSGOpticalSystem","page":"Systems","title":"OpticSim.CSGOpticalSystem","text":"CSGOpticalSystem{T,D<:Real,S<:Surface{T},L<:LensAssembly{T}} <: AbstractOpticalSystem{T}\n\nAn optical system containing a lens assembly with all optical elements and a detector surface with associated image. The system can be at a specified temperature and pressure.\n\nThere are two number types in the type signature. The T type parameter is the numeric type for geometry in the optical system, the D type parameter is the numeric type of the pixels in the detector image. This way you can have Float64 geometry, where high precision is essential, but the pixels in the detector can be Float32 since precision is much less critical for image data, or Complex if doing wave optic simulations.\n\nThe detector can be any Surface which implements uv, uvtopix and onsurface, typically this is one of Rectangle, Ellipse or SphericalCap.\n\nCSGOpticalSystem(\n    assembly::LensAssembly,\n    detector::Surface,\n    detectorpixelsx = 1000,\n    detectorpixelsy = 1000, ::Type{D} = Float32;\n    temperature = OpticSim.GlassCat.TEMP_REF,\n    pressure = OpticSim.GlassCat.PRESSURE_REF\n)\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.AxisymmetricOpticalSystem","page":"Systems","title":"OpticSim.AxisymmetricOpticalSystem","text":"AxisymmetricOpticalSystem{T,C<:CSGOpticalSystem{T}} <: AbstractOpticalSystem{T}\n\nOptical system which has lens elements and an image detector, created from a DataFrame containing prescription data.\n\nThese tags are supported for columns: :Radius, :SemiDiameter, :SurfaceType, :Thickness, :Conic, :Parameters, :Reflectance, :Material.\n\nThese tags are supported for entries in a SurfaceType column: Object, Image, Stop. Assumes the Image row will be the last row in the DataFrame.\n\nIn practice a CSGOpticalSystem is generated automatically and stored within this system.\n\nAxisymmetricOpticalSystem{T}(\n    prescription::DataFrame,\n    detectorpixelsx = 1000,\n    detectorpixelsy:: = 1000,\n    ::Type{D} = Float32;\n    temperature = OpticSim.GlassCat.TEMP_REF,\n    pressure = OpticSim.GlassCat.PRESSURE_REF\n)\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.temperature","page":"Systems","title":"OpticSim.temperature","text":"temperature(system::AbstractOpticalSystem{T}) -> T\n\nGet the temperature of system in °C.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.pressure","page":"Systems","title":"OpticSim.pressure","text":"pressure(system::AbstractOpticalSystem{T}) -> T\n\nGet the pressure of system in Atm.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.detectorimage","page":"Systems","title":"OpticSim.detectorimage","text":"detectorimage(system::AbstractOpticalSystem{T}) -> HierarchicalImage{D}\n\nGet the detector image of system. D is the datatype of the detector image and is not necessarily the same as the datatype of the system T.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.resetdetector!","page":"Systems","title":"OpticSim.resetdetector!","text":"resetdetector!(system::AbstractOpticalSystem{T})\n\nReset the deterctor image of system to zero.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.assembly","page":"Systems","title":"OpticSim.assembly","text":"assembly(system::AbstractOpticalSystem{T}) -> LensAssembly{T}\n\nGet the LensAssembly of system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.semidiameter","page":"Systems","title":"OpticSim.semidiameter","text":"semidiameter(system::AxisymmetricOpticalSystem{T}) -> T\n\nGet the semidiameter of system, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Tracing","page":"Systems","title":"Tracing","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"We can trace an individual OpticalRay through the system (or directly through a LensAssembly), or we can trace using an OpticalRayGenerator to create a large number of rays.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"trace\ntraceMT\ntracehits\ntracehitsMT\nOpticSim.LensTrace","category":"page"},{"location":"systems/#OpticSim.trace","page":"Systems","title":"OpticSim.trace","text":"trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)\n\nReturns the ray as it exits the assembly in the form of a LensTrace object if it hits any element in the assembly, otherwise nothing. Recursive rays are offset by a small amount (RAY_OFFSET) to prevent it from immediately reintersecting the same lens element.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the assembly.\n\n\n\n\n\ntrace(system::AbstractOpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)\n\nTraces system with ray, if test is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a LensTrace if the ray hits the detector or nothing otherwise.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the system.\n\n\n\n\n\ntrace(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the detector image of the system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.traceMT","page":"Systems","title":"OpticSim.traceMT","text":"traceMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the accumulated detector image from all threads.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.tracehits","page":"Systems","title":"OpticSim.tracehits","text":"tracehits(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.tracehitsMT","page":"Systems","title":"OpticSim.tracehitsMT","text":"tracehitsMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector, accumulated from all threads.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.LensTrace","page":"Systems","title":"OpticSim.LensTrace","text":"LensTrace{T<:Real,N}\n\nContains an intersection point and the ray segment leading to it from within an optical trace. The ray carries the path length, power, wavelength, number of intersections and source number, all of which are accessible directly on this class too.\n\nHas the following accessor methods:\n\nray(a::LensTrace{T,N}) -> OpticalRay{T,N}\nintersection(a::LensTrace{T,N}) -> Intersection{T,N}\npower(a::LensTrace{T,N}) -> T\nwavelength(a::LensTrace{T,N}) -> T\npathlength(a::LensTrace{T,N}) -> T\npoint(a::LensTrace{T,N}) -> SVector{N,T}\nuv(a::LensTrace{T,N}) -> SVector{2,T}\nsourcenum(a::LensTrace{T,N}) -> Int\nnhits(a::LensTrace{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Lenses-and-Other-Optical-Components","page":"Lenses","title":"Lenses and Other Optical Components","text":"","category":"section"},{"location":"lenses/#Lenses","page":"Lenses","title":"Lenses","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"A number of helper functions are provided to make constructing simple lenses easier. Firstly ordinary thick lenses:","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"SphericalLens\nConicLens\nAsphericLens\nFresnelLens","category":"page"},{"location":"lenses/#OpticSim.SphericalLens","page":"Lenses","title":"OpticSim.SphericalLens","text":"SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.ConicLens","page":"Lenses","title":"OpticSim.ConicLens","text":"ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.AsphericLens","page":"Lenses","title":"OpticSim.AsphericLens","text":"AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nCosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.FresnelLens","page":"Lenses","title":"OpticSim.FresnelLens","text":"FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = OpticSim.GlassCat.Air)\n\nCreate a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on groovedepth. For negative radii the vertex on the central surface is at frontvertex, so the total thickness of the lens is thickness + groovedepth. Aspherics currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"As well as idealized lenses:","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"ParaxialLens","category":"page"},{"location":"lenses/#OpticSim.ParaxialLens","page":"Lenses","title":"OpticSim.ParaxialLens","text":"ParaxialLens{T} <: Surface{T}\n\nsurfacenormal is the output direction of the lens. Paraxial lens cannot act as the interface between two materials, hence only a single outside material is specified, by default Air.\n\nCreate with the following functions\n\nParaxialLensEllipse(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = OpticSim.GlassCat.Air, decenteruv = (0.0, 0.0))\nParaxialLensRect(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = OpticSim.GlassCat.Air, decenteruv = (0.0, 0.0))\nParaxialLensHex(focaldistance, side_length, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = OpticSim.GlassCat.Air, decenteruv = (0.0, 0.0))\nParaxialLensConvexPoly(focaldistance, local_frame, local_polygon_points, local_center_point; outsidematerial = OpticSim.GlassCat.Air)\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Other-Components","page":"Lenses","title":"Other Components","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"We also have some holographic elements implemented, note that these have not been extensively tested and should not be treated as wholely accurate at this stage.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"It is relatively simple to extend the existing code to add these kinds of specialized surfaces providing a paired OpticalInterface subclass is also defined. In this case the WrapperSurface can often serve as a suitable base for extension.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"WrapperSurface\nThinGratingSurface\nHologramSurface\nMultiHologramSurface","category":"page"},{"location":"lenses/#OpticSim.WrapperSurface","page":"Lenses","title":"OpticSim.WrapperSurface","text":"WrapperSurface{T,S<:Surface{T}} <: Surface{T}\n\nA generic surface type which serves as a basis for extension of Surfaces for custom OpticalInterface subclasses. Essentially just forwards all Surface and ParametricSurface methods to a field of the WrapperSurface named surface. Also provides a generic implementation of surfaceintersection which tests for an intersection with the underlying surface and returns either an EmptyInterval or a half space (never a closed interval).\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.ThinGratingSurface","page":"Lenses","title":"OpticSim.ThinGratingSurface","text":"ThinGratingSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with ThinGratingInterface.\n\nThinGratingSurface(surface::Surface{T}, interface::ThinGratingInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.HologramSurface","page":"Lenses","title":"OpticSim.HologramSurface","text":"HologramSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with HologramInterface.\n\nHologramSurface(surface::Surface{T}, interface::HologramInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.MultiHologramSurface","page":"Lenses","title":"OpticSim.MultiHologramSurface","text":"MultiHologramSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with MultiHologramInterface.\n\nMultiHologramSurface(surface::Surface{T}, interface::MultiHologramInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Eye-Models","page":"Lenses","title":"Eye Models","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"Eye models are often very useful in simulation of head mounted display systems. We have two models implemented currently.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"ModelEye\nArizonaEye","category":"page"},{"location":"lenses/#OpticSim.ModelEye","page":"Lenses","title":"OpticSim.ModelEye","text":"ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::Transform{T} = identitytransform(T))\n\nGeometrically accurate model of the human eye focussed at infinity with variable pupil_radius. The eye is added to the provided assembly to create a CSGOpticalSystem with the retina of the eye as the detector.\n\nThe eye can be positioned in the scene using the transform argument and the resolution of the detector specified with detpixels. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nnsamples determines the resolution at which accelerated surfaces within the eye are triangulated.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.ArizonaEye","page":"Lenses","title":"OpticSim.ArizonaEye","text":"ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)\n\nThe popular Arizona eye model taken from this definition. The accommodation of the eye can be varied in this model. Returns a DataFrame specifying the prescription of the eye model.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"There are a number of powerful visualization tools available, we primarily rely on 3D visualization of systems using Makie.","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"There are a number of helper methods, as well as the ability to draw objects, surfaces, points, rays and more individually. For example, looking at rays passing through a system in 3D and 2D:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"using OpticSim","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100)\nVis.save(\"assets/vis_ex_3d.png\") # hide\nVis.drawtracerays(Examples.cooketriplet(), trackallrays=true, test=true, numdivisions=100, drawsys=true, resolution = (1000, 700))\nVis.make2dy()\nVis.save(\"assets/vis_ex_2d.png\"); nothing #hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: 3D visualization example) (Image: 2D visualization example)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"And the image on the detector for a trace of a system:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.drawtraceimage(Examples.cooketriplet(), test=true)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"using Images # hide\nim = Vis.drawtraceimage(Examples.cooketriplet(Float64, 400), test=true)\nsave(\"assets/vis_ex_im.png\", colorview(Gray, real.(im ./ maximum(im)))); nothing # hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: detector image example)","category":"page"},{"location":"vis/#Basic-Drawing","page":"Visualization","title":"Basic Drawing","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"These methods are all you need to build up a visualization piece by piece. For example:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"obj = (Sphere(0.5) ∩ Plane(0.0, 1.0, 0.0, 0.0, 0.1, 0.0))()\nray1 = Ray([0.0, -0.1, 1.0], [0.0, 0.0, -1.0])\nray2 = Ray([0.8, 0.0, 0.0], [-1.0, 0.0, 0.0])\nVis.draw(obj)\nVis.draw!(ray1, rayscale=0.2)\nVis.draw!(ray2, rayscale=0.2, color=:blue)\nVis.draw!(surfaceintersection(obj, ray1), color=:red)\nVis.draw!(surfaceintersection(obj, ray2), color=:green)\nVis.save(\"assets/vis_ex_3d_parts.png\"); nothing # hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: basic drawing example)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"OpticSim.Vis.scene\nOpticSim.Vis.draw\nOpticSim.Vis.draw!(::Any; kwargs...)\nOpticSim.Vis.save","category":"page"},{"location":"vis/#OpticSim.Vis.scene","page":"Visualization","title":"OpticSim.Vis.scene","text":"scene(resolution = (1000, 1000))\n\nCreate a new Makie scene with the given resolution including control buttons.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.draw","page":"Visualization","title":"OpticSim.Vis.draw","text":"draw(ob; resolution = (1000, 1000), kwargs...)\n\nDraw an object in a new scene. kwargs depends on the object type.\n\n\n\n\n\ndraw the LatticeCluster offset to (0,0) \n\n\n\n\n\ndraw the ClusterWithProperties at coordinates specified by cells \n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.draw!-Tuple{Any}","page":"Visualization","title":"OpticSim.Vis.draw!","text":"draw!([scene = currentscene], ob; kwargs...)\n\nDraw an object in an existing scene. kwargs depends on the object type.\n\n\n\n\n\n","category":"method"},{"location":"vis/#OpticSim.Vis.save","page":"Visualization","title":"OpticSim.Vis.save","text":"save(path::String)\n\nSave the current Makie scene to an image file.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Helper-Methods","page":"Visualization","title":"Helper Methods","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"These are the helper methods to provide common visualizations more easily, as used above. Another example:","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"Vis.surfacesag(AcceleratedParametricSurface(TestData.zernikesurface2()), (256, 256), (1.55, 1.55))","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"using Plots; include(\"../../test/TestData/TestData.jl\") # hide\np = Vis.surfacesag(AcceleratedParametricSurface(TestData.zernikesurface2()), (256, 256), (1.55, 1.55))\nPlots.savefig(p, \"assets/surface_sag.svg\"); nothing # hide","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"(Image: surface sag example)","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"OpticSim.Vis.drawtracerays\nOpticSim.Vis.drawtraceimage\nOpticSim.Vis.spotdiag\nOpticSim.Vis.surfacesag\nOpticSim.Vis.eyebox_eval_eye\nOpticSim.Vis.eyebox_eval_planar","category":"page"},{"location":"vis/#OpticSim.Vis.drawtracerays","page":"Visualization","title":"OpticSim.Vis.drawtracerays","text":"drawtracerays(system::Q; raygenerator::S = Source(transform = Transform.translation(0.0,0.0,10.0), origins = Origins.RectGrid(10.0,10.0,25,25),directions = Constant(0.0,0.0,-1.0)), test::Bool = false, trackallrays::Bool = false, colorbysourcenum::Bool = false, colorbynhits::Bool = false, rayfilter::Union{Nothing,Function} = onlydetectorrays, kwargs...)\n\nDisplays a model of the optical system. raygenerator is an iterator that generates rays. If trackallrays is true then ray paths from the emitter will be displayed otherwise just the final rays that intersect the image detector will be shown, not the entire ray path. colorbysourcenum and colorbynhits will color rays accordingly, otherwise rays will be colored according to their wavelength.\n\nBy default only ray paths that eventually intersect the detector surface are displayed. If you want to display all ray paths set rayfilter = nothing.\n\nAlso drawtracerays! to add to an existing scene, with drawsys and drawgen to specify whether system and raygenerator should be drawn respectively.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.drawtraceimage","page":"Visualization","title":"OpticSim.Vis.drawtraceimage","text":"drawtraceimage(system::Q; raygenerator::S = Source(transform = translation(0.0,0.0,10.0), origins = Origins.RectGrid(10.0,10.0,25,25),directions = Constant(0.0,0.0,-1.0)), test::Bool = false)\n\nTraces rays from raygenerator through system and shows and returns the detector image. verbose will print progress updates.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.spotdiag","page":"Visualization","title":"OpticSim.Vis.spotdiag","text":"spotdiag(sys::CSGOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; size = (500, 500), kwargs...)\n\nPlot a spot diagram for an arbitrary CSGOpticalSystem and OpticalRayGenerator. All rays from raygenerator will be traced through sys and their intersection location on the detector plotted.\n\nAlso spotdiag! of the same arguments to add to an existing plot.\n\n\n\n\n\nspotdiag(sys::AxisymmetricOpticalSystem{T}; size = (500, 500), hexapolar::Bool = true, collimated::Bool = true, samples::Int = 5, wavelength::T = 0.55, sourceangle::T = zero(T), sourcepos::SVector{3,T} = SVector{3,T}(0.0, 0.0, 10.0), kwargs...)\n\nPlot a spot diagram for an AxisymmetricOpticalSystem, rays are distributed across the entrance pupil of the system either in a hexapolar of rectangular grid pattern depending on hexapolar.\n\nThe input rays can be collimated, in which case the sourceangle parameter determines their direction. Otherwise rays are treated as coming from a point source at sourcepos.\n\nAlso spotdiag! of the same arguments to add to an existing plot.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.surfacesag","page":"Visualization","title":"OpticSim.Vis.surfacesag","text":"surfacesag(object::Union{CSGTree{T},Surface{T}}, resolution::Tuple{Int,Int}, halfsizes::Tuple{T,T}; offset::T = T(10), position::SVector{3,T} = SVector{3,T}(0.0, 0.0, 10.0), direction::SVector{3,T} = SVector{3,T}(0.0, 0.0, -1.0), rotationvec::SVector{3,T} = SVector{3,T}(0.0, 1.0, 0.0))\n\nCalculates and displays the surface sag of an arbitrary Surface or CSGTree.\n\nRays are shot in a grid of size defined by resolution across a arectangular area defined by halfsizes. This rectangle is centred at postion with normal along direction and rotation defined by rotationvec. offset is subtracted from the sag measurements to provide values relative to the appropriate zero level.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.eyebox_eval_eye","page":"Visualization","title":"OpticSim.Vis.eyebox_eval_eye","text":"eyebox_eval_eye(assembly::LensAssembly{T}, raygen::OpticalRayGenerator{T}, eye_rotation_x::T, eye_rotation_y::T, sample_points_x::Int, sample_points_y::Int; pupil_radius::T = T(2.0), resolution::Int = 512, eye_transform::Transform{T} = identitytransform(T))\n\nVisualise the images formed when tracing assembly with a human eye for an evenly sampled sample_points_x × sample_points_y grid in the angular range of eyeball rotations -eye_rotation_x:eye_rotation_x and -eye_rotation_y:eye_rotation_y in each dimension respectively. resolution is the size of the detector image (necessarily square).\n\nThe eye must be positioned appropriately relative to the system using eye_transform, this should transform the eye to the correct position and orientation when at 0 rotation in both dimensions. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nThe result is displayed as a 4D image - the image seen by the eye is shown in 2D as normal with sliders to vary eye rotation in x and y. The idea being that the whole image should be visible for all rotations in the range.\n\n\n\n\n\n","category":"function"},{"location":"vis/#OpticSim.Vis.eyebox_eval_planar","page":"Visualization","title":"OpticSim.Vis.eyebox_eval_planar","text":"eyebox_eval_planar(assembly::LensAssembly{T}, raygen::OpticalRayGenerator{T}, eyebox::Rectangle{T}, sample_points_x::Int, sample_points_y::Int, vsize::T; pupil_radius::T = T(2.0), resolution::Int = 512)\n\nVisualise the images formed when tracing assembly for multiple pupil positions within a planar eyebox. Any angles which are present in a circle radius pupil_radius around each sampling point on an even sample_points_x × sample_points_y grid on the eyebox are added to the sub-image at that grid point.\n\nA paraxial lens focal length 1mm is placed at the eyebox and a detector of size vsize × vsizemm placed 1mm behind it. The normal of the detector rectangle should point towards the system (and away from the fake detector). Any rays which miss the detector are ignored.\n\nThe pupil is always fully contained in the eyebox, i.e., the extreme sample position in u would be eyebox.halfsizeu - pupil_radius, for example.\n\nThe result is displayed as a 4D image - each sub-image is shown as normal with sliders to vary eye rotation in x and y. The idea being that the whole FoV should be visible for all rotations in the range.\n\n\n\n\n\n","category":"function"},{"location":"vis/#Complete-Drawing-Functions","page":"Visualization","title":"Complete Drawing Functions","text":"","category":"section"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"As mentioned above, Vis.draw! can be used to draw a large variety of objects, each with their own additional arguments. Here is a full list of the available drawing function and their associated options.","category":"page"},{"location":"vis/","page":"Visualization","title":"Visualization","text":"OpticSim.Vis.draw!","category":"page"},{"location":"vis/#OpticSim.Vis.draw!","page":"Visualization","title":"OpticSim.Vis.draw!","text":"draw!([scene = currentscene], ob; kwargs...)\n\nDraw an object in an existing scene. kwargs depends on the object type.\n\n\n\n\n\ndraw!(scene::Makie.LScene, surf::Surface{T}; numdivisions = 20, normals = false, normalcolor = :blue, kwargs...)\n\nTransforms surf into a mesh using makemesh and draws the result. normals of the surface can be drawn at evenly sampled points with provided normalcolor. numdivisions determines the resolution with which the mesh is triangulated. kwargs is passed on to the TriangleMesh drawing function.\n\n\n\n\n\ndraw!(scene::Makie.LScene, tmesh::TriangleMesh{T}; linewidth = 3, shaded = true, wireframe = false, color = :orange, normals = false, normalcolor = :blue, transparency = false, kwargs...)\n\nDraw a TriangleMesh, optionially with a visible wireframe. kwargs are passed on to Makie.mesh.\n\n\n\n\n\ndraw!(scene::Makie.LScene, meshes::Vararg{S}; colors::Bool = false, kwargs...) where {T<:Real,S<:Union{TriangleMesh{T},Surface{T}}}\n\nDraw a series of TriangleMesh or Surface objects, if colors is true then each mesh will be colored automatically with a diverse series of colors. kwargs are is passed on to the drawing function for each element.\n\n\n\n\n\ndraw!(scene::Makie.LScene, csg::Union{CSGTree,CSGGenerator}; numdivisions::Int = 20, kwargs...)\n\nConvert a CSG object (CSGTree or CSGGenerator) to a mesh using makemesh with resolution set by numdivisions and draw the resulting TriangleMesh.\n\n\n\n\n\ndraw!(scene::Makie.LScene, bbox::BoundingBox{T}; kwargs...)\n\nDraw a BoundingBox as a wireframe, ie series of lines.\n\n\n\n\n\ndraw!(scene::Makie.LScene, ass::LensAssembly; kwargs...)\n\nDraw each element in a LensAssembly, with each element automatically colored differently.\n\n\n\n\n\ndraw!(scene::Makie.LScene, sys::AbstractOpticalSystem; kwargs...)\n\nDraw each element in the lens assembly of an AbstractOpticalSystem, with each element automatically colored differently, as well as the detector of the system.\n\n\n\n\n\ndraw!(scene::Makie.LScene, rays::AbstractVector{<:AbstractRay{T,N}}; kwargs...)\n\nDraw a vector of Ray or OpticalRay objects.\n\n\n\n\n\ndraw!(scene::Makie.LScene, traces::AbstractVector{LensTrace{T,N}}; kwargs...)\n\nDraw a vector of LensTrace objects.\n\n\n\n\n\ndraw!(scene::Makie.LScene, trace::LensTrace{T,N}; colorbysourcenum::Bool = false, colorbynhits::Bool = false, kwargs...)\n\nDraw a LensTrace as a line which can be colored automatically by its sourcenum or nhits attributes. The alpha is determined by the power attribute of trace.\n\n\n\n\n\ndraw!(scene::Makie.LScene, ray::OpticalRay{T,N}; colorbysourcenum::Bool = false, colorbynhits::Bool = false, kwargs...)\n\nDraw an OpticalRay which can be colored automatically by its sourcenum or nhits attributes. The alpha of the ray is determined by the power attribute of ray. kwargs are passed to draw!(scene, ray::Ray).\n\n\n\n\n\ndraw!(scene::Makie.LScene, ray::Ray{T,N}; color = :yellow, rayscale = 1.0, kwargs...)\n\nDraw a Ray in a given color optionally scaling the size using rayscale. kwargs are passed to Makie.arrows.\n\n\n\n\n\ndraw!(scene::Makie.LScene, du::DisjointUnion{T}; kwargs...)\n\nDraw each Interval in a DisjointUnion.\n\n\n\n\n\ndraw!(scene::Makie.LScene, intervals::AbstractVector{Interval{T}}; kwargs...)\n\nDraw a vector of Intervals.\n\n\n\n\n\ndraw!(scene::Makie.LScene, interval::Interval{T}; kwargs...)\n\nDraw an Interval as a line with circles at each Intersection point.\n\n\n\n\n\ndraw!(scene::Makie.LScene, intersection::Intersection; normal::Bool = false, kwargs...)\n\nDraw an Intersection as a circle, optionally showing the surface normal at the point.\n\n\n\n\n\ndraw!(scene::Makie.LScene, lines::AbstractVector{Tuple{AbstractVector{T},AbstractVector{T}}}; kwargs...)\n\nDraw a vector of lines.\n\n\n\n\n\ndraw!(scene::Makie.LScene, line::Tuple{AbstractVector{T},AbstractVector{T}}; color = :yellow, kwargs...)\n\nDraw a line between two points, kwargs are passed to Makie.linesegments.\n\n\n\n\n\ndraw!(s::Makie.LScene, point::AbstractVector{T}; kwargs...)\n\nDraw a single point, kwargs are passed to draw!(scene, points::AbstractVector{AbstractVector{T}}).\n\n\n\n\n\ndraw!(scene::Makie.LScene, points::AbstractVector{AbstractVector{T}}; markersize = 20, color = :black, kwargs...)\n\nDraw a vector of points. kwargs are passed to Makie.scatter.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#Optical-Interfaces","page":"Interfaces","title":"Optical Interfaces","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"Every Surface must have an OpticalInterface associated with it to defined the behavior of any ray when it intersects that surface.","category":"page"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"OpticSim.OpticalInterface\nOpticSim.NullInterface\nFresnelInterface\nParaxialInterface\nThinGratingInterface\nHologramInterface\nMultiHologramInterface","category":"page"},{"location":"interfaces/#OpticSim.OpticalInterface","page":"Interfaces","title":"OpticSim.OpticalInterface","text":"OpticalInterface{T<:Real}\n\nAny subclass of OpticalInterface must implement the following:\n\nprocessintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nSee documentation for processintersection for details.\n\nThese methods are also commonly implemented, but not essential:\n\ninsidematerialid(i::OpticalInterface{T}) -> OpticSim.GlassCat.AbstractGlass\noutsidematerialid(i::OpticalInterface{T}) -> OpticSim.GlassCat.AbstractGlass\nreflectance(i::OpticalInterface{T}) -> T\ntransmission(i::OpticalInterface{T}) -> T\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.NullInterface","page":"Interfaces","title":"OpticSim.NullInterface","text":"NullInterface{T} <: OpticalInterface{T}\n\nInterface which will be ignored totally by any rays, used only in construction of CSG objects.\n\nNullInterface(T = Float64)\nNullInterface{T}()\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.FresnelInterface","page":"Interfaces","title":"OpticSim.FresnelInterface","text":"FresnelInterface{T} <: OpticalInterface{T}\n\nInterface between two materials with behavior defined according to the Fresnel equations, with a specified reflectance and transmission. Assumes unpolarized light.\n\nFresnelInterface{T}(insidematerial, outsidematerial; reflectance = 0, transmission = 1, interfacemode = ReflectOrTransmit)\n\nThe interfacemode can be used to trace rays deterministically. Valid values are defined in the InterfaceMode enum. Reflect means that all values are reflected, Transmit means that all values are transmitted. ReflectOrTransmit will randomly reflect and transmit rays with the distribution given by the reflection and transmission arguments. This is also the default. In all cases the power recorded with the ray is correctly updated. This can be used to fake sequential raytracing. For example a beamsplitter surface may be set to either Reflect or Transmit to switch between the two outgoing ray paths.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.ParaxialInterface","page":"Interfaces","title":"OpticSim.ParaxialInterface","text":"ParaxialInterface{T} <: OpticalInterface{T}\n\nInterface describing an idealized planar lens, i.e. one that is thin and with no aberrations.\n\nIn general this interface should not be constructed directly, the ParaxialLensEllipse and ParaxialLensRect functions should be used to create a ParaxialLens object directly.\n\nParaxialInterface(focallength::T, centroid::SVector{3,T}, outsidematerial::Y)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.ThinGratingInterface","page":"Interfaces","title":"OpticSim.ThinGratingInterface","text":"ThinGratingInterface{T} <: OpticalInterface{T}\n\nInterface representing an idealized thin grating. period is in microns, vector should lie in the plane of the surface. Transmission and reflectance can be specified for an arbitrary number of orders up to 10, selected using the maxorder and minorder parameters. If nothing then reflectance is assumed to be 0 and transmission is assumed to be 1.\n\nThinGratingInterface(vector, period, insidematerial, outsidematerial; maxorder = 1, minorder = -1, reflectance = nothing, transmission = nothing)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.HologramInterface","page":"Interfaces","title":"OpticSim.HologramInterface","text":"HologramInterface{T} <: OpticalInterface{T}\n\nInterface representing a thick hologram (though geometrically thin). The efficiency, η, is calculated using Kogelnik's coupled wave theory so is only valid for the first order. If the zero order is included then it has efficiency 1 - η. Also assumes that the HOE was recorded under similar conditions to the playback conditions, thickness is in microns.\n\nBeatState arguments can be one of ConvergingBeam, DivergingBeam and CollimatedBeam. In the first two cases signalpointordir and referencepointordir are 3D point in global coordinate space. For CollimatedBeam they are normalized direction vectors.\n\nFor reference, see:\n\nCoupled Wave Theory for Thick Hologram Gratings - H Kogelnik, 1995\nSequential and non-sequential simulation of volume holographic gratings - M Kick et al, 2018\n\nHologramInterface(signalpointordir::SVector{3,T}, signalbeamstate::BeamState, referencepointordir::SVector{3,T}, referencebeamstate::BeamState, recordingλ::T, thickness::T, beforematerial, substratematerial, aftermaterial, signalrecordingmaterial, referencerecordingmaterial, RImodulation::T, include0order  = false)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.MultiHologramInterface","page":"Interfaces","title":"OpticSim.MultiHologramInterface","text":"MultiHologramInterface{T} <: OpticalInterface{T}\n\nInterface to represent multiple overlapped HologramInterfaces on a single surface. Each ray randomly selects an interface to use.\n\nMultiHologramInterface(interfaces::Vararg{HologramInterface{T}})\nMultiHologramInterface(interfaces::Vector{HologramInterface{T}})\n\n\n\n\n\n","category":"type"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"The critical behavior of each interface is defined in the processintersection function:","category":"page"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"OpticSim.processintersection","category":"page"},{"location":"interfaces/#OpticSim.processintersection","page":"Interfaces","title":"OpticSim.processintersection","text":"processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nProcesses an intersection of an OpticalRay with an OpticalInterface, distinct behaviors must be implemented for each subclass of OpticalInterface.\n\npoint is the 3D intersection point in global space, normal is the surface normal at the intersection point.\n\nIf test is true then the behavior of the ray should be deterministic. firstray indicates that this ray is the first segment of the trace and therefore the origin is not offset.\n\nThe values returned are the normalized direction of the ray after the intersection, the instantaneous power of the ray after the intersection and the optical path length of the ray up to the intersection.\n\nnothing is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration nothing should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return nothing.\n\n\n\n\n\n","category":"function"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"OpticSim.jl is still under active development. Here are things we are considering:","category":"page"},{"location":"roadmap/#User-Interface","page":"Roadmap","title":"User Interface","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Improvements to visualization tools\nBetter control of 3D/2D system views\nMore drawing options (e.g. wireframe)\nMore analysis tools e.g. grids of spot diagrams, OPD diagrams etc.\nInteractive editor, probably in a spreadsheet format or similar\nEasily usable optimization features","category":"page"},{"location":"roadmap/#Optimization","page":"Roadmap","title":"Optimization","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Performance improvements\nMore rigorous local optimization (better parameter limits)\nGlobal optimization/smart initialization\nBetter interface (particularly for merit function design)","category":"page"},{"location":"roadmap/#Raytracing","page":"Roadmap","title":"Raytracing","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Improvements to ray energy accuracy\nImprove HOE implementations\nFinish implementation of Bezier and BSpline surfaces (mostly done)","category":"page"},{"location":"roadmap/#Other","page":"Roadmap","title":"Other","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Properly support Julia 1.6 once released\nAdd automatic 'run on azure' options\nSome long standing bug fixes/improvements to implementations","category":"page"},{"location":"roadmap/#Long-Term","page":"Roadmap","title":"Long-Term","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Simulation of gradient index (GRIN) materials\nSimulation of meta-materials\nCSG file import/export\nSimulate physical effects of thermal variation (physical expansion)\nSupport polarization of rays and elements relying on this","category":"page"},{"location":"notebooksutils/#Notebook-utilities","page":"Notebook utilities","title":"Notebook utilities","text":"","category":"section"},{"location":"notebooksutils/","page":"Notebook utilities","title":"Notebook utilities","text":"CurrentModule = NotebooksUtils","category":"page"},{"location":"notebooksutils/","page":"Notebook utilities","title":"Notebook utilities","text":"[TODO]","category":"page"},{"location":"notebooksutils/","page":"Notebook utilities","title":"Notebook utilities","text":"run_sample\nSetBackend\nrun\nInitNotebook","category":"page"},{"location":"notebooksutils/#OpticSim.NotebooksUtils.run_sample","page":"Notebook utilities","title":"OpticSim.NotebooksUtils.run_sample","text":"run_sample(sample_name::String)\n\nLaunch Pluto and allow the user to open a specific sample notebook. If a notebook of the same name exists in the current working folder, it will be opened in Pluto, otherwise, the original sample notebook will be copied to the current folder and be used. This beheviour will prevent users from updating the original sample notebook. \n\n\n\n\n\n","category":"function"},{"location":"notebooksutils/#OpticSim.NotebooksUtils.SetBackend","page":"Notebook utilities","title":"OpticSim.NotebooksUtils.SetBackend","text":"function SetBackend(defs::Defs, be::String)\n\nthis is my first comment try\n\n\n\n\n\n","category":"function"},{"location":"notebooksutils/#OpticSim.NotebooksUtils.run","page":"Notebook utilities","title":"OpticSim.NotebooksUtils.run","text":"function run(notebook_filename)\n\nLaunch Pluto and allow teh user to open a specific notebook.\n\n\n\n\n\nfunction run(; port=nothing, path=nothing, sysimage_file=nothing )\n\nLaunch Pluto and allow teh user to open a specific notebook. Also allow the usage of a sysimage file for faster loading.        \n\n\n\n\n\n","category":"function"},{"location":"notebooksutils/#OpticSim.NotebooksUtils.InitNotebook","page":"Notebook utilities","title":"OpticSim.NotebooksUtils.InitNotebook","text":"InitNotebook(; port=8449)\n\ninitialize the JSServe package.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"All geometry is built up from a small(ish) number of primitives and a number of constructive solid geometry (CSG) operations (see CSG). Primitives are split into two types, Surfaces and ParametricSurfaces, the latter being a subset of the former. Surfaces are standalone surfaces which cannot be used in CSG operations, e.g. an aperture or rectangle. ParametricSurfaces are valid csg objects and can be composed into very complex structures.","category":"page"},{"location":"primitives/#Surfaces","page":"Primitives","title":"Surfaces","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A surface can be any surface in 3D space, it can be bounded and not create a half-space (i.e. not partition space into inside and outside).","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Surface","category":"page"},{"location":"primitives/#OpticSim.Surface","page":"Primitives","title":"OpticSim.Surface","text":"Surface{T<:Real}\n\nT is the number type used to represent the surface, e.g., Float64. Basic Surfaces are not valid CSG objects, they function only in a stand-alone capacity.\n\nMust implement the following:\n\nsurfaceintersection(surface::Surface{T}, ray::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\nnormal(surface::Surface{T}) -> SVector{3,T}\ninterface(surface::Surface{T}) -> OpticalInterface{T}\nmakemesh(surface::Surface{T}) -> TriangleMesh{T}\n\nIn a conventional ray tracer the surface intersection function would only return the first surface the ray intersects. Because our ray tracer does CSG operations the surface intersection function intersects the ray with all leaf surfaces which are part of the CSG tree. \n\nEach leaf surface returns one or more 1D intervals along the ray. These intervals contain the part of the ray which is inside the surface. The intervals computed at the leaves are propagated upward through the CSG tree and the CSG operations of union, intersection, and difference are applied to generate new intervals which are themselves propagated upward.\n\nThe result is a union of 1D intervals, which may be disjoint, a single interval, or empty. The union of intervals represents the parts of the ray which are inside the CSG object.\n\nInside is well defined for halfspaces such as cylinders and spheres which divide space into two parts, but not for Bezier or NURBS patches which generally do not enclose a volume.  For surfaces which are not halfspaces the notion of inside is defined locally by computing the angle between the incoming ray and the normal of the surface at the point of intersection. All surfaces must be defined so that the normal points to the outside of the surface. \n\nA negative dot product between the incoming ray and the normal indicates the ray is coming from the outside of the surface and heading toward the inside. A positive dot product indicates the ray is coming from the inside of the surface and heading toward the outside.\n\nIntervals are defined along the ray which is being intersected with the surface, so they are one dimensional. For example, assume we have a ray with origin o on the outside of a plane and an intersection with the plane at point int = o + td where t is a scalar and d is the unit direction of the ray. The inside interval will be (Intersection(t),Infinity). This interval begins at the intersection point on the plane and continues to positive infinity. The Intersection struct stores both the parametric value t and the 3D point of intersection to make various operations more efficient. But the interval operations only depend on the parametric value t.\n\nIf the origin o is on the inside of the plane then the inside interval will be (RayOrigin,Intersection(t)). Only the part of the ray from the ray origin to the intersection point is inside the plane. \n\nIt is the programmer's responsibility to return Interval results from surfaceintersection that maintain these properties.\n\nThe following must be impemented only if the surface is being used as a detector\n\nuv(surface::Surface{T}, p::SVector{3,T}) -> SVector{2,T}\nuvtopix(surface::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\nonsurface(surface::Surface{T}, p::SVector{3,T}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Basic-Shapes","page":"Primitives","title":"Basic Shapes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are the simple shapes with are provided already, they act only as standalone objects and cannot be used in CSG objects. Adding a new Surface is easy, the new structure must simply follow the interface defined above.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Ellipse\nCircle\nRectangle\nHexagon\nTriangle\nTriangleMesh","category":"page"},{"location":"primitives/#OpticSim.Ellipse","page":"Primitives","title":"OpticSim.Ellipse","text":"Ellipse{T} <: Surface{T}\n\nElliptical surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nEllipse(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns an ellipse centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Circle","page":"Primitives","title":"OpticSim.Circle","text":"Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))\n\nShortcut method to create a circle. The minimal case returns a circle centred at the origin with normal = [0, 0, 1].\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.Rectangle","page":"Primitives","title":"OpticSim.Rectangle","text":"Rectangle{T} <: Surface{T}\n\nRectangular surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nRectangle(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Hexagon","page":"Primitives","title":"OpticSim.Hexagon","text":"Hexagon{T} <: Surface{T}\n\nHexagonal surface, not a valid CSG object. The rotation of the hexagon around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nHexagon(side_length::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Triangle","page":"Primitives","title":"OpticSim.Triangle","text":"Triangle{T} <: Surface{T}\n\nTriangular surface, not a valid CSG object. Primarily used as a component part of TriangleMesh or to enable intersection of AcceleratedParametricSurfaces. Can never be used directly as an optical surface as it doesn't have an OpticalInterface.\n\nTriangle(v1::SVector{3,T}, v2::SVector{3,T}, v3::SVector{3,T}, [uv1::SVector{2,T}, uv2::SVector{2,T}, uv3::SVector{2,T}])\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.TriangleMesh","page":"Primitives","title":"OpticSim.TriangleMesh","text":"TriangleMesh{T} <: Surface{T}\n\nAn array of Triangles forming a mesh. Used for visualization purposes only.\n\nTriangleMesh(tris::Vector{Triangle{T}})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Stops","page":"Primitives","title":"Stops","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A number of simple occlusive apertures are provided as constructing such objects using CSG can be inefficient and error-prone.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"InfiniteStop\nFiniteStop\nRectangularAperture\nCircularAperture\nAnnulus","category":"page"},{"location":"primitives/#OpticSim.InfiniteStop","page":"Primitives","title":"OpticSim.InfiniteStop","text":"InfiniteStop{T,P<:StopShape} <: Surface{T}\n\nStop surface with infinite extent (outside of the aperture). P refers to the shape of the aperture.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.FiniteStop","page":"Primitives","title":"OpticSim.FiniteStop","text":"FiniteStop{T,P<:StopShape,Q<:StopShape} <: Surface{T}\n\nStop surface with finite extent. P refers to the shape of the aperture and Q represents the shape of the bounds of the stop surface.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.RectangularAperture","page":"Primitives","title":"OpticSim.RectangularAperture","text":"RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a plane i.e. InfiniteStop{T,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\nRectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a rectangle i.e. FiniteStop{T,RectangularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.CircularAperture","page":"Primitives","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a plane i.e. InfiniteStop{T,CircularStopShape}.\n\n\n\n\n\nCircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a circular aperture in a rectangle i.e. FiniteStop{T,CircularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.Annulus","page":"Primitives","title":"OpticSim.Annulus","text":"Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a circle i.e. FiniteStop{T,CircularStopShape,CircularStopShape}.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Parametric-Surfaces","page":"Primitives","title":"Parametric Surfaces","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A parametric surface must partition space into two valid half-spaces, i.e. inside and outside. The surface must also be parameterized by two variables, nominally u and v. Typically these surfaces cannot be intersected with a ray analytically and so must be triangulated and an iterative solution found.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"ParametricSurface\nAcceleratedParametricSurface","category":"page"},{"location":"primitives/#OpticSim.ParametricSurface","page":"Primitives","title":"OpticSim.ParametricSurface","text":"ParametricSurface{T,N} <: Surface{T}\n\nT is the number type used to represent the surface, e.g., Float64. N is the dimension of the space the surface is embedded in. ParametricSurfaces are valid CSG objects, in some cases (where analytic intersection isn't possible) they must be wrapped in an AcceleratedParametricSurface for use.\n\nMust implement the following:\n\nuv(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> SVector{2,T}\nuvrange(surface::ParametricSurface{T,N}) -> Tuple{Tuple{T,T},Tuple{T,T}}\npoint(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\npartials(surface::ParametricSurface{T,N}, u::T, v::T) -> Tuple{SVector{N,T}, SVector{N,T}}\nnormal(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\ninside(surface::ParametricSurface{T,N}, p: :SVector{N,T}) -> Bool\nonsurface(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> Bool\nsurfaceintersection(surface::ParametricSurface{T,N}, AbstractRay::Ray{T,N}) -> Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}\ninterface(surface::ParametricSurface{T,N}) -> OpticalInterface{T}\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.AcceleratedParametricSurface","page":"Primitives","title":"OpticSim.AcceleratedParametricSurface","text":"AcceleratedParametricSurface{T,N,S} <: ParametricSurface{T,N}\n\nWrapper class for ParametricSurfaces where analytical intersection isn't feasible (e.g. ZernikeSurface, ChebyshevSurface). The surface is instead triangulated and an iterative (newton raphson) process carried out to determine precise ray intersection points. S is the type of the ParametricSurface being wrapped.\n\nAcceleratedParametricSurface(surf::ParametricSurface{T,N}, numsamples::Int = 17; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Parametric-Surface-Types","page":"Primitives","title":"Parametric Surface Types","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are the available types of parametric surfaces which are already implemented, all of which can be used in the creation of CSG objects. New ParametricSurfaces can be added with relative ease providing they follow the interface defined above.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Cylinder\nPlane\nSphere\nSphericalCap\nZernikeSurface\nBezierSurface\nBSplineSurface\nQTypeSurface\nChebyshevSurface\nGridSagSurface","category":"page"},{"location":"primitives/#OpticSim.Cylinder","page":"Primitives","title":"OpticSim.Cylinder","text":"Cylinder{T,N} <: ParametricSurface{T,N}\n\nCylinder of infinite height centered at the origin, oriented along the z-axis. visheight is used for visualization purposes only, note that this does not fully represent the surface.\n\nCylinder(radius::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Plane","page":"Primitives","title":"OpticSim.Plane","text":"Plane{T,N} <: ParametricSurface{T,N}\n\nInfinite planar surface where the positive normal side is outside the surface.\n\nBy default this will not create any geometry for visualization, the optional vishalfsizeu and vishalfsizev arguments can be used to draw the plane as a rectangle for visualization note that this does not fully represent the surface. In this case, the rotation of the rectangle around the normal to the plane is defined by visvec - surfacenormal×visvec is taken as the vector along the u axis.\n\nPlane(surfacenormal::SVector{N,T}, pointonplane::SVector{N,T}; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\nPlane(nx::T, ny::T, nz::T, x::T, y::T, z::T; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Sphere","page":"Primitives","title":"OpticSim.Sphere","text":"Sphere{T,N} <: ParametricSurface{T,N}\n\nSpherical surface centered at the origin.\n\nSphere(radius::T = 1.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.SphericalCap","page":"Primitives","title":"OpticSim.SphericalCap","text":"SphericalCap{T} <: ParametricSurface{T}\n\nSpherical cap surface, creates a half-space which is essentially the subtraction of a sphere from an infinite plane. Only the spherical cap itself is visualized, not the plane. The positive normal side is outside the surface.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nSphericalCap(radius::T, ϕmax::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a spherical cap centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.ZernikeSurface","page":"Primitives","title":"OpticSim.ZernikeSurface","text":"ZernikeSurface{T,N,P,Q} <: ParametricSurface{T,N}\n\nSurface incorporating the Zernike polynomials - radius, conic and aspherics are defined relative to absolute semi-diameter, Zernike terms are normalized according to the normradius parameter. T is the datatype, N is the dimensionality, P is the number of Zernike terms and Q is the number of aspheric terms. Only even aspheric terms are supported.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nFor convenience the input zcoeff can be indexed using either OSA or Noll convention, indicated using the indexing argument as either ZernikeIndexingOSA or ZernikeIndexingNoll.\n\nZernikeSurface(semidiameter, radius = Inf, conic = 0, zcoeff = nothing, aspherics = nothing, normradius = semidiameter, indexing = ZernikeIndexingOSA)\n\nzcoeff and aspherics should be vectors containing tuples of the form (i, v) where i is either the index of the Zernike term for the corresponding indexing, or the polynomial power of the aspheric term (must be even) and v is the corresponding coefficient A_i or alpha_i respectively..\n\nThe sag is defined by the equation\n\nz(rphi) = fraccr^21 + sqrt1 - (1+k)c^2r^2 + sum_i^Qalpha_ir^2i + sum_i^PA_iZ_i(rho phi)\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Z_n is the nᵗʰ Zernike polynomial.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.BezierSurface","page":"Primitives","title":"OpticSim.BezierSurface","text":"BezierSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nBezier surface defined by grid of control points.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBezierSurface{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.BSplineSurface","page":"Primitives","title":"OpticSim.BSplineSurface","text":"BSplineSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nCurve order is the same in the u and v direction and fixed over all spans. u and v knot vectors are allowed to be different - may change this to make them both the same.\n\nControl points in the u direction correspond to columns, with the lowest value of u corresponding to row 1. Control points in the v direction correspond to rows, with the lowest value of v corresponding to col 1.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBSplineSurface{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\nBSplineSurface{P,S,N,M}(uknots::KnotVector{S}, vknots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.QTypeSurface","page":"Primitives","title":"OpticSim.QTypeSurface","text":"QTypeSurface{T,D,M,N} <: ParametricSurface{T,D}\n\nSurface incorporating the QType polynomials - radius and conic are defined relative to absolute semi-diameter, QType terms are normalized according to the normradius parameter. T is the datatype, D is the dimensionality, M and N are the maximum QType terms used.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nQTypeSurface(semidiameter; radius = Inf, conic = 0.0, αcoeffs = nothing, βcoeffs = nothing, normradius = semidiameter)\n\nαcoeffs and βcoeffs should be a vector of tuples of the form (m, n, v) where v is the value of the coefficient α_n^m or β_n^m respectively.\n\nThe sag is defined by the equation\n\nbeginaligned\nz(rphi) =  fraccr^21 + sqrt1 - (1+k)c^2r^2 + fracsqrt1 + kc^2r^2sqrt1-(1+k)c^2r^2 cdot \n              left rho^2(1-rho^2)sum_n=0^Nalpha_n^0 Q_n^0 (rho^2) + sum_m=1^Mrho^msum_n=0^N left alpha_n^mcosmphi +beta_n^msinmphirightQ_n^m(rho^2) right\nendaligned\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Q_n^m is the QType polynomial index m, n.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.ChebyshevSurface","page":"Primitives","title":"OpticSim.ChebyshevSurface","text":"ChebyshevSurface{T,N,P,Q} <: ParametricSurface{T,N}\n\nRectangular surface incorporating Chebyshev polynomials as well as radius and conic terms. T is the datatype, N is the dimensionality, P is the number of Chebyshev terms in u and Q is the number of Chebyshev terms in v.\n\nThe surface is centered at the origin and treated as being the cap of an infinite rectangular prism, thus creating a true half-space. Note that the surface is vertically offset so that the center (i.e., (u,v) == (0,0)) lies at 0 on the z-axis.\n\nChebyshevSurface(halfsizeu, halfsizev, chebycoeff; radius = Inf, conic = 0)\n\nchebycoeff is a vector containing tuples of the form (i, j, v) where v is the value of the coefficient c_ij.\n\nThe sag is defined by the equation\n\nz(uv) = fracc(u^2 + v^2)^21 + sqrt1 - (1+k)c^2(u^2 + v^2) + sum_i^Psum_j^Qc_ijT_i(u)T_j(v)\n\nwhere c = frac1textttradius, k = textttconic and T_n is the nᵗʰ Chebyshev polynomial of the first kind.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.GridSagSurface","page":"Primitives","title":"OpticSim.GridSagSurface","text":"GridSagSurface{T,N,S<:Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}},Nu,Nv} <: ParametricSurface{T,N}\n\nEither a Zernike (circular) or Chebyshev (rectangular) surface with grid sag height added to the base sag. The surface shape is determined by either a linear or a bicubic spline interpolation of the Nu×Nv grid of sag values, set by the interpolation argument taking either GridSagLinear or GridSagBicubic.\n\nEach entry in the grid is a vector of the form z fracpartial zpartial x fracpartial zpartial y fracpartial^2 zpartial x partial y. The first data item corresponds to the lower left corner of the surface, that is, the corner defined by the -u and -v limit. Each point that follows is read across the face of the surface from left to right moving upwards. If zero is given for the partials (and using bicubic interpolation) then the partials will be approximated using finite differences.\n\nThe sag grid can be decentered from the surface in uv space, if so the surface may become wild outside of the area over which the grid is defined. It is advised to clip the surface to the valid area using CSG operations in this case.\n\nA surface can also be generated from a .GRD file by passing in the filename as the first and only positional argument. In this case the surface will be rectangular with optional radius and conic.\n\nSee docs for ZernikeSurface and ChebyshevSurface for details of the base surface.\n\nGridSagSurface(basesurface::Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}}, sag_grid::AbstractArray{T,3}; interpolation = GridSagBicubic, decenteruv = (0, 0))\nGridSagSurface{T}(filename::String; radius = Inf, conic = 0, interpolation = GridSagBicubic)\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Functions","page":"Primitives","title":"Functions","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are some useful functions related to Surface objects.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"point(::ParametricSurface{T}, ::T, ::T) where {T<:Real}\nnormal\npartials(::ParametricSurface{T}, ::T, ::T) where {T<:Real}\nuvrange\nuv\nOpticSim.uvtopix\ninside(s::ParametricSurface{T,3}, x::T, y::T, z::T) where {T<:Real}\nonsurface(s::ParametricSurface{T,3}, x::T, y::T, z::T) where {T<:Real}\ninterface\nsurfaceintersection(surf::AcceleratedParametricSurface{S,N}, r::AbstractRay{S,N}) where {S,N}\nsamplesurface\ntriangulate\nmakemesh","category":"page"},{"location":"primitives/#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T, N} where N, T, T}} where T<:Real","page":"Primitives","title":"OpticSim.point","text":"point(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\npoint(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the 3D point on surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.normal","page":"Primitives","title":"OpticSim.normal","text":"normal(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\nnormal(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the normal to surf at the given uv coordinate.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T, N} where N, T, T}} where T<:Real","page":"Primitives","title":"OpticSim.partials","text":"partials(surf::ParametricSurface{T}, u::T, v::T) -> (SVector{3,T}, SVector{3,T})\npartials(surf::ParametricSurface{T}, uv::SVector{2,T}) -> (SVector{3,T}, SVector{3,T})\n\nReturns a tuple of the 3D partial derivatives of surf with respect to u and v at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.uvrange","page":"Primitives","title":"OpticSim.uvrange","text":"uvrange(s::ParametricSurface)\nuvrange(::Type{S}) where {S<:ParametricSurface}\n\nReturns a tuple of the form: ((umin, umax), (vmin, vmax)) specifying the limits of the parameterisation for this surface type. Also implemented for some Surfaces which are not ParametricSurfaces (e.g. Rectangle).\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.uv","page":"Primitives","title":"OpticSim.uv","text":"uv(surf::ParametricSurface{T}, p::SVector{3,T}) -> SVector{2,T}\nuv(surf::ParametricSurface{T}, x::T, y::T, z::T) -> SVector{2,T}\n\nReturns the uv coordinate on surf of a point, p, in 3D space. If onsurface(surf, p) is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.uvtopix","page":"Primitives","title":"OpticSim.uvtopix","text":"uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\n\nConverts a uvcoordinate on surf to an integer index to a pixel in an image of size imsize. Not implemented on all Surface objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an AbstractOpticalSystem.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real","page":"Primitives","title":"OpticSim.inside","text":"inside(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\ninside(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside surf.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real","page":"Primitives","title":"OpticSim.onsurface","text":"onsurface(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\nonsurface(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on surf.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.interface","page":"Primitives","title":"OpticSim.interface","text":"interface(surf::Surface{T}) -> OpticalInterface{T}\n\nReturn the OpticalInterface associated with surf.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{S}, Tuple{AcceleratedParametricSurface{S, N, S1} where S1<:ParametricSurface{S, N}, AbstractRay{S, N}}} where {S, N}","page":"Primitives","title":"OpticSim.surfaceintersection","text":"surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}\n\nCalculates the intersection of r with a surface of any type, surf. Note that some surfaces cannot be intersected analytically so must be wrapped in an AcceleratedParametricSurface in order to be intersected.\n\nReturns an EmptyInterval if there is no Intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.samplesurface","page":"Primitives","title":"OpticSim.samplesurface","text":"samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)\n\nSample a parametric surface on an even numsamples×numsamples grid in UV space with provided function\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.triangulate","page":"Primitives","title":"OpticSim.triangulate","text":"triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)\n\nCreate an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.makemesh","page":"Primitives","title":"OpticSim.makemesh","text":"makemesh(object, subdivisions::Int = 30) -> TriangleMesh\n\nCreates a TriangleMesh from an object, either a ParametricSurface, CSGTree or certain surfaces (e.g. Circle, Rectangle). This is used for visualization purposes only.\n\n\n\n\n\nmakemesh(poly::ConvexPolygon{N, T}, ::Int = 0) where {N, T<:Real} -> TriangleMesh\n\nCreate a triangle mesh that can be rendered by iterating on the polygon's edges and for each edge use the centroid as the third vertex of the triangle.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Bounding-Boxes","page":"Primitives","title":"Bounding Boxes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Bounding boxes are mostly used internally for efficiency, but are also exposed to the user for visualization (and any other) purposes. All bounding boxes are axis aligned.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"BoundingBox\ndoesintersect\nsurfaceintersection(::BoundingBox{T}, ::AbstractRay{T,3}) where {T<:Real}","category":"page"},{"location":"primitives/#OpticSim.BoundingBox","page":"Primitives","title":"OpticSim.BoundingBox","text":"BoundingBox{T<:Real}\n\nAxis-aligned three-dimensional bounding box.\n\nBoundingBox(xmin::T, xmax::T, ymin::T, ymax::T, zmin::T, zmax::T)\nBoundingBox(s::Surface{T})\nBoundingBox(s::ParametricSurface{T,3}, transform::Transform{T} = identitytransform(T))\nBoundingBox(c::CSGTree{T})\nBoundingBox(tri::Triangle{T})\nBoundingBox(triangles::AbstractVector{Triangle{T}})\nBoundingBox(points::AbstractArray{SVector{3,T}})\nBoundingBox(la::LensAssembly{T})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.doesintersect","page":"Primitives","title":"OpticSim.doesintersect","text":"doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Bool\n\nTests whether r intersects an axis-aligned BoundingBox, bbox.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T<:Real","page":"Primitives","title":"OpticSim.surfaceintersection","text":"surfaceintersection(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\n\nCalculates the intersection of r with an axis-aligned BoundingBox, bbox.\n\nReturns an EmptyInterval if there is no intersection or an Interval if there is one or two intersections. Note that the uv of the returned intersection is always 0.\n\n\n\n\n\n","category":"method"},{"location":"emitters/#Emitters","page":"Emitters","title":"Emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"warning: Warning\nThe old emitter implementation is deprecated as of v0.5! See below for the new API.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters create rays in a certain pattern, usually controlled by some parameters. Emitters are defined by Pixels and Spatial Layouts, and have a spectrum and an optical power distribution over the hemisphere. These are intrinsic physical properties of the emitter.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"The basic emitter (Source) is constructed as a combination of 4 basic elements and a 3D Transform. The basic elements include:","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Spectrum\nAngular Power Distribution\nRays Origins Distribution\nRays Directions Distribution","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"The OpticSim package comes with various implementations of each of these basic elements:","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Spectrum - the generate interface returns a tuple (power, wavelength)\nEmitters.Spectrum.Uniform - A flat spectrum bounded (default: from 450nm to 680nm). the range is sampled uniformly.\nEmitters.Spectrum.DeltaFunction - Constant wave length.\nEmitters.Spectrum.Measured - measured spectrum to compute emitter power and wavelength (created by reading CSV files – more details will follow).\nAngular Power Distribution - the interface apply returns an OpticalRay with modified power\nEmitters.AngularPower.Lambertian\nEmitters.AngularPower.Cosine\nEmitters.AngularPower.Gaussian\nRays Origins Distribution - the interface length returns the number of samples, and generate returns the n'th sample.\nEmitters.Origins.Point - a single point\nEmitters.Origins.RectUniform - a uniformly sampled rectangle with user defined number of samples\nEmitters.Origins.RectGrid - a rectangle sampled in a grid fashion\nEmitters.Origins.Hexapolar - a circle (or an ellipse) sampled in an hexapolar fashion (rings)\nRays Directions Distribution - the interface length returns the number of samples, and generate returns the n'th sample.\nEmitters.Directions.Constant\nEmitters.Directions.RectGrid\nEmitters.Directions.UniformCone\nEmitters.Directions.HexapolarCone","category":"page"},{"location":"emitters/#basic_emitters","page":"Emitters","title":"Examples of Basic Emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Note: All of the examples on this page assume that the following statement was executed:","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"dummy = \"switching to WGLMakie in order to produce interactive figures with Makie\"  # hide\nusing OpticSim, OpticSim.Geometry, OpticSim.Emitters                                # hide\nOpticSim.NotebooksUtils.SetDocsBackend(\"Web\")                                       # hide","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters","category":"page"},{"location":"emitters/#Simple-functions-for-creating-commonly-used-emitters","page":"Emitters","title":"Simple functions for creating commonly used emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Many optical systems by convention have their optical axis parallel to the z axis. These utility functions provide a simple interface to the Emitters package to create emitters that direct their rays in the negative z direction, toward the entrance of the optical system.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.pointemitter","category":"page"},{"location":"emitters/#OpticSim.Emitters.pointemitter","page":"Emitters","title":"OpticSim.Emitters.pointemitter","text":"pointemitter(origin::AbstractVector{T}, coneangle; λ::Length = 500nm, numrays = 100) where {T<:Real}\n\nCreates a point source with Lambertian emission power and cone distribution of rays, emitting in the -z direction. λ is a unitful Length quantity, e.g., 550nm.\n\n\n\n\n\n","category":"function"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\npt = Emitters.pointemitter([0.0,0.0,.5],.3)\nVis.draw(pt, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.collimatedemitter","category":"page"},{"location":"emitters/#OpticSim.Emitters.collimatedemitter","page":"Emitters","title":"OpticSim.Emitters.collimatedemitter","text":"collimatedemitter(origin::AbstractVector{T}, halfsquaresize; λ::Length = 500nm, numrays = 100) where {T<:Real}\n\nCreates a square collimated emitter, emitting rays in the -z direction. Rays are emitted on a square grid with sqrt(numrays) on a side. λ can be a unitful quantity, e.g., 550nm, or a number. In the latter case the units are implicitly microns.\n\n\n\n\n\n","category":"function"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\npt = Emitters.collimatedemitter([0.0,0.0,1.0],.5)\nVis.draw(pt, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/#Point-origin-with-various-Direction-distributions","page":"Emitters","title":"Point origin with various Direction distributions","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Point(), directions=Directions.RectGrid(π/4, π/4, 15, 15))\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Point(), directions=Directions.UniformCone(π/6, 1000))\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Point(), directions=Directions.HexapolarCone(π/6, 10))\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/#Various-origins-distributions","page":"Emitters","title":"Various origins distributions","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.RectGrid(1.0, 1.0, 10, 10), directions=Directions.Constant())\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Hexapolar(5, 1.0, 2.0), directions=Directions.Constant())\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/#Examples-of-Angular-Power-Distribution","page":"Emitters","title":"Examples of Angular Power Distribution","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"In these example, the arrow width is proportional to the ray power.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(\n    origins=Origins.Hexapolar(1, 8.0, 8.0),             # Hexapolar Origins\n\tdirections=Directions.RectGrid(π/6, π/6, 15, 15),   # RectGrid Directions\n\tpower=AngularPower.Cosine(10.0)                     # Cosine Angular Power \n)\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(\n\torigins=Origins.RectGrid(1.0, 1.0, 3, 3),           # RectGrid Origins  \n\tdirections=Directions.HexapolarCone(π/6, 10),       # HexapolarCone Directions\n\tpower=AngularPower.Gaussian(2.0, 2.0)               # Gaussian Angular Power \n)\nVis.draw(src, debug=true, resolution = (800, 600))","category":"page"},{"location":"emitters/#Composite-Sources-Display-Example","page":"Emitters","title":"Composite Sources - Display Example","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\n\n# construct the emitter's basic components\nS = Spectrum.Uniform()\nP = AngularPower.Lambertian()\nO = Origins.RectGrid(1.0, 1.0, 3, 3)\nD = Directions.HexapolarCone(deg2rad(5.0), 3)\t\n\t\n# construct the source. in this example a \"pixel\" source will contain only one source as we are simulating a \"b/w\" display. \n# for RGB displays we can combine 3 sources to simulate \"a pixel\".\nTr = Transform(Vec3(0.5, 0.5, 0.0))\nsource1 = Sources.Source(Tr, S, O, D, P)\n\t\n# create a list of pixels - each one is a composite source\npixels = Vector{Sources.CompositeSource{Float64}}(undef, 0)\nfor y in 1:5 # image_height\n    for x in 1:10 # image_width\n        # pixel position relative to the display's origin\n        local pixel_position = Vec3((x-1) * 1.1, (y-1) * 1.5, 0.0)\n        local Tr = Transform(pixel_position)\n\n        # constructing the \"pixel\"\n        pixel = Sources.CompositeSource(Tr, [source1])\n\n        push!(pixels, pixel)\n    end\nend\n\t\nTr = Transform(Vec3(0.0, 0.0, 0.0))\nmy_display = Sources.CompositeSource(Tr, pixels)\n\nVis.draw(my_display)                                                # render the display - nothing but the origins primitives\nrays = AbstractArray{OpticalRay{Float64, 3}}(collect(my_display))   # collect the rays generated by the display\nVis.draw!(rays)                                                     # render the rays ","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"dummy = \"switching Back to the GLMakie to allow the rest of the pages to work with static figures\"  # hide\nusing OpticSim, OpticSim.Geometry, OpticSim.Emitters                                                # hide\nOpticSim.NotebooksUtils.SetDocsBackend(\"Static\")                                                    # hide","category":"page"},{"location":"emitters/#spectrum","page":"Emitters","title":"Spectrum","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.Spectrum.Uniform\nEmitters.Spectrum.DeltaFunction\nEmitters.Spectrum.Measured\nEmitters.Spectrum.spectrumpower","category":"page"},{"location":"emitters/#OpticSim.Emitters.Spectrum.Uniform","page":"Emitters","title":"OpticSim.Emitters.Spectrum.Uniform","text":"Uniform{T} <: AbstractSpectrum{T}\n\nEncapsulates a flat spectrum range which is sampled uniformly. Unless stated diferrently, the range used will be 450nm to 680nm.\n\nUniform(low_end::T, high_end::T) where {T<:Real}\nUniform(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Spectrum.DeltaFunction","page":"Emitters","title":"OpticSim.Emitters.Spectrum.DeltaFunction","text":"DeltaFunction{T} <: AbstractSpectrum{T}\n\nEncapsulates a constant spectrum.\n\nDeltaFunction{T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Spectrum.Measured","page":"Emitters","title":"OpticSim.Emitters.Spectrum.Measured","text":"Measured{T} <: AbstractSpectrum{T}\n\nEncapsulates a measured spectrum to compute emitter power. Create spectrum by reading CSV files. Evaluate spectrum at arbitrary wavelength with spectrumpower (more technical details coming soon)\n\nMeasured(samples::DataFrame)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Spectrum.spectrumpower","page":"Emitters","title":"OpticSim.Emitters.Spectrum.spectrumpower","text":"expects wavelength in nm not um\n\n\n\n\n\n","category":"function"},{"location":"emitters/#angular_power_distribution","page":"Emitters","title":"Angular Power Distribution","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.AngularPower.Lambertian\nEmitters.AngularPower.Cosine\nEmitters.AngularPower.Gaussian","category":"page"},{"location":"emitters/#OpticSim.Emitters.AngularPower.Lambertian","page":"Emitters","title":"OpticSim.Emitters.AngularPower.Lambertian","text":"Lambertian{T} <: AbstractAngularPowerDistribution{T}\n\nRay power is unaffected by angle.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.AngularPower.Cosine","page":"Emitters","title":"OpticSim.Emitters.AngularPower.Cosine","text":"Cosine{T} <: AbstractAngularPowerDistribution{T}\n\nCosine power distribution. Ray power is calculated by:\n\npower = power * (cosine_angle ^ cosine_exp)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.AngularPower.Gaussian","page":"Emitters","title":"OpticSim.Emitters.AngularPower.Gaussian","text":"Gaussian{T} <: AbstractAngularPowerDistribution{T}\n\nGGaussian power distribution. Ray power is calculated by:\n\npower = power * exp(-(gaussianu * l^2 + gaussianv * m^2)) where l and m are the cos_angles between the two axes respectivly.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#rays_origins_distribution","page":"Emitters","title":"Rays Origins Distribution","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.Origins.Point\nEmitters.Origins.RectUniform\nEmitters.Origins.RectGrid\nEmitters.Origins.Hexapolar","category":"page"},{"location":"emitters/#OpticSim.Emitters.Origins.Point","page":"Emitters","title":"OpticSim.Emitters.Origins.Point","text":"Point{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a single point origin.\n\nPoint(position::Vec3{T}) where {T<:Real}\nPoint(x::T, y::T, z::T) where {T<:Real}\nPoint(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Origins.RectUniform","page":"Emitters","title":"OpticSim.Emitters.Origins.RectUniform","text":"RectUniform{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a uniformly sampled rectangle with user defined number of samples.\n\nRectUniform(width::T, height::T, samples_count::Int64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Origins.RectGrid","page":"Emitters","title":"OpticSim.Emitters.Origins.RectGrid","text":"RectGrid{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a rectangle sampled in a grid fashion.\n\nRectGrid(width::T, height::T, usamples::Int64, vsamples::Int64) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Origins.Hexapolar","page":"Emitters","title":"OpticSim.Emitters.Origins.Hexapolar","text":"Hexapolar{T} <: AbstractOriginDistribution{T}\n\nEncapsulates an ellipse (or a circle where halfsizeu=halfsizev) sampled in an hexapolar fashion (rings).\n\nHexapolar(nrings::Int64, halfsizeu::T, halfsizev::T) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"emitters/#rays_directions_distribution","page":"Emitters","title":"Rays Directions Distribution","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.Directions.Constant\nEmitters.Directions.RectGrid\nEmitters.Directions.UniformCone\nEmitters.Directions.HexapolarCone","category":"page"},{"location":"emitters/#OpticSim.Emitters.Directions.Constant","page":"Emitters","title":"OpticSim.Emitters.Directions.Constant","text":"Constant{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].\n\nConstant(direction::Vec3{T}) where {T<:Real}\nConstant(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Directions.RectGrid","page":"Emitters","title":"OpticSim.Emitters.Directions.RectGrid","text":"RectGrid{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].\n\nConstant(direction::Vec3{T}) where {T<:Real}\nConstant(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Directions.UniformCone","page":"Emitters","title":"OpticSim.Emitters.Directions.UniformCone","text":"UniformCone{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates numsamples rays sampled uniformly from a cone with max angle θmax.\n\nUniformCone(direction::Vec3{T}, θmax::T, numsamples::Int64) where {T<:Real}\nUniformCone(θmax::T, numsamples::Int64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Directions.HexapolarCone","page":"Emitters","title":"OpticSim.Emitters.Directions.HexapolarCone","text":"HexapolarCone{T} <: AbstractDirectionDistribution{T}\n\nRays are generated by sampling a cone with θmax angle in an hexapolar fashion. The number of rays depends on the requested rings and is computed using the following formula: 1 + round(Int64, (nrings * (nrings + 1) / 2) * 6)\n\nHexapolarCone(direction::Vec3{T}, θmax::T, nrings::Int64) where {T<:Real}\nHexapolarCone(θmax::T, nrings::Int64 = 3) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#sources","page":"Emitters","title":"Sources","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters.Sources.Source\nEmitters.Sources.CompositeSource","category":"page"},{"location":"emitters/#OpticSim.Emitters.Sources.Source","page":"Emitters","title":"OpticSim.Emitters.Sources.Source","text":"Source{T<:Real, Tr<:Transform{T}, S<:Spectrum.AbstractSpectrum{T}, O<:Origins.AbstractOriginDistribution{T}, D<:Directions.AbstractDirectionDistribution{T}, P<:AngularPower.AbstractAngularPowerDistribution{T}} <: AbstractSource{T}\n\nThis data-type represents the basic emitter (Source), which is a combination of a Spectrum, Angular Power Distribution, Origins and Directions distibution and a 3D Transform.\n\nSource(::Type{T} = Float64;\n       transform::Tr = Transform(),\n       spectrum::S = Spectrum.Uniform(),\n       origins::O = Origins.Point(),\n       directions::D = Directions.Constant(),\n       power::P = AngularPower.Lambertian(),\n       sourcenum::Int64 = 0) where {\n            Tr<:Transform,\n            S<:Spectrum.AbstractSpectrum,\n            O<:Origins.AbstractOriginDistribution,\n            D<:Directions.AbstractDirectionDistribution,\n            P<:AngularPower.AbstractAngularPowerDistribution,\n            T<:Real}\n\nSource(transform::Tr, spectrum::S, origins::O, directions::D, power::P, ::Type{T} = Float64; sourcenum::Int64 = 0) where {   \n            Tr<:Transform,\n            S<:Spectrum.AbstractSpectrum,\n            O<:Origins.AbstractOriginDistribution,\n            D<:Directions.AbstractDirectionDistribution,\n            P<:AngularPower.AbstractAngularPowerDistribution,\n            T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Sources.CompositeSource","page":"Emitters","title":"OpticSim.Emitters.Sources.CompositeSource","text":"CompositeSource{T} <: AbstractSource{T}\n\nThis data-type represents the composite emitter (Source) which is constructed with a list of basic or composite emitters and a 3D Transform.\n\nCompositeSource(transform::Transform{T}, sources::Vector{<:AbstractSource}) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"csg/#CSG","page":"CSG","title":"CSG","text":"","category":"section"},{"location":"csg/#CSG-Operations","page":"CSG","title":"CSG Operations","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"There are three binary csg operations which can construct extremely complex objects from very simple primitives: union (cup), intersection (cap) and subtraction (i.e. difference).","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"This diagram shows the basic idea: (Image: CSG Tree visualization)","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"The code for this in our system would look this this:","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"using OpticSim # hide\ncyl = Cylinder(0.7)\ncyl_cross = cyl ∪ leaf(cyl, Geometry.rotationd(90, 0, 0)) ∪ leaf(cyl, Geometry.rotationd(0, 90, 0))\n\ncube = Cuboid(1.0, 1.0, 1.0)\nsph = Sphere(1.3)\nrounded_cube = cube ∩ sph\n\nresult = rounded_cube - cyl_cross\nVis.draw(result, numdivisions=100)\n\nVis.save(\"assets/csg_ex.png\") # hide","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"(Image: CSG code example image)","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"leaf\n∪\n∩\n-","category":"page"},{"location":"csg/#OpticSim.leaf","page":"CSG","title":"OpticSim.leaf","text":"leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a leaf node from a parametric surface with a given transform.\n\n\n\n\n\n","category":"function"},{"location":"csg/#Base.:∪","page":"CSG","title":"Base.:∪","text":"∪(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T<:Real}\n\nCreate a binary node in the CSG tree representing a union between a and b.\n\n(Image: Union Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Base.:∩","page":"CSG","title":"Base.:∩","text":"∩(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T<:Real}\n\nCreate a binary node in the CSG tree representing an intersection between a and b.\n\n(Image: Intersect Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Base.:-","page":"CSG","title":"Base.:-","text":"-(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T<:Real}\n\nCreate a binary node in the CSG tree representing the difference of a and b, essentially a - b.\n\n(Image: Difference Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Pre-made-CSG-Shapes","page":"CSG","title":"Pre-made CSG Shapes","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"There are also some shortcut methods available to create common CSG objects more easily:","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"BoundedCylinder\nCuboid\nHexagonalPrism\nRectangularPrism\nTriangularPrism\nSpider","category":"page"},{"location":"csg/#OpticSim.BoundedCylinder","page":"CSG","title":"OpticSim.BoundedCylinder","text":"BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cylinder with planar caps on both ends centred at (0, 0, 0) with axis (0, 0, 1).\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.Cuboid","page":"CSG","title":"OpticSim.Cuboid","text":"Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cuboid centred at (0, 0, 0).\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.HexagonalPrism","page":"CSG","title":"OpticSim.HexagonalPrism","text":"HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall hexagonal prism with axis (0, 0, 1), the longer hexagon diameter is along the x axis. For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.RectangularPrism","page":"CSG","title":"OpticSim.RectangularPrism","text":"RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall rectangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.TriangularPrism","page":"CSG","title":"OpticSim.TriangularPrism","text":"TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall triangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.Spider","page":"CSG","title":"OpticSim.Spider","text":"Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -> Vector{Rectangle{T}}\n\nCreates a 'spider' obscuration with narms rectangular arms evenly spaced around a circle defined by origin and normal. Each arm is a rectangle armwidth×radius.\n\ne.g. for 3 and 4 arms we get:\n\n   |         _|_\n  / \\         |\n\n\n\n\n\n","category":"function"},{"location":"csg/#CSG-Types","page":"CSG","title":"CSG Types","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"These are the types of the primary CSG elements, i.e. the nodes in the CSG tree.","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"OpticSim.CSGTree\nOpticSim.CSGGenerator\nOpticSim.ComplementNode\nOpticSim.UnionNode\nOpticSim.IntersectionNode\nOpticSim.LeafNode","category":"page"},{"location":"csg/#OpticSim.CSGTree","page":"CSG","title":"OpticSim.CSGTree","text":"Abstract type representing any evaluated CSG structure.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.CSGGenerator","page":"CSG","title":"OpticSim.CSGGenerator","text":"CSGGenerator{T<:Real}\n\nThis is the type you should use when making CSG objects. This type allows for the construction of CSGTree objects with different transforms. When the generator is evaluated, all transforms are propagated down to the LeafNodes and stored there.\n\nExample\n\na = Cylinder(1.0,1.0)\nb = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])\ngenerator = a ∩ b\n# now make a csg object that can be ray traced\ncsgobj = generator(Transform(1.0,1.0,2.0))\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.ComplementNode","page":"CSG","title":"OpticSim.ComplementNode","text":"ComplementNode{T,C<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated complement node within the CSG tree, must be the second child of a IntersectionNode forming a subtraction.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.UnionNode","page":"CSG","title":"OpticSim.UnionNode","text":"UnionNode{T,L<:CSGTree{T},R<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated union node within the CSG tree.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.IntersectionNode","page":"CSG","title":"OpticSim.IntersectionNode","text":"IntersectionNode{T,L<:CSGTree{T},R<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated intersection node within the CSG tree.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.LeafNode","page":"CSG","title":"OpticSim.LeafNode","text":"LeafNode{T,S<:ParametricSurface{T}} <: CSGTree{T}\n\nAn evaluated leaf node in the CSG tree, geometry attribute which contains a ParametricSurface of type S. The leaf node also has a transform associated which is the composition of all nodes above it in the tree. As such, transforming points from the geometry using this transform puts them in world space, and transforming rays by the inverse transform puts them in object space.\n\n\n\n\n\n","category":"type"},{"location":"csg/#Additional-Functions-and-Types","page":"CSG","title":"Additional Functions and Types","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"These are the internal types and functions used for geometric/CSG operations.","category":"page"},{"location":"csg/#Functions","page":"CSG","title":"Functions","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"surfaceintersection(::CSGTree{T}, ::AbstractRay{T,N}) where {T<:Real,N}\ninside(a::CSGTree{T}, x::T, y::T, z::T) where {T<:Real}\nonsurface(a::CSGTree{T}, x::T, y::T, z::T) where {T<:Real}","category":"page"},{"location":"csg/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T<:Real, N}","page":"CSG","title":"OpticSim.surfaceintersection","text":"surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})\n\nCalculates the intersection of r with CSG object, obj.\n\nReturns an EmptyInterval if there is no intersection, an Interval if there is one or two interesections and a DisjointUnion if there are more than two intersections.\n\nThe ray is intersected with the LeafNodes that make up the CSG object and the resulting Intervals and DisjointUnions are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in object space for that node before the intersection is carried out, typically this object space is centered at the origin, but may differ for each primitive.\n\nSome intersections are culled without actually evaluating them by first checking if the ray intersects the BoundingBox of each node in the CSGTree, this can substantially improve performance in some cases.\n\n\n\n\n\n","category":"method"},{"location":"csg/#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T<:Real","page":"CSG","title":"OpticSim.inside","text":"inside(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\ninside(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside obj.\n\n\n\n\n\n","category":"method"},{"location":"csg/#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T<:Real","page":"CSG","title":"OpticSim.onsurface","text":"onsurface(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\nonsurface(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on the surface (i.e. shell) of obj.\n\n\n\n\n\n","category":"method"},{"location":"csg/#Intervals","page":"CSG","title":"Intervals","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"Interval\nEmptyInterval\nDisjointUnion\nOpticSim.isemptyinterval\nOpticSim.ispositivehalfspace\nOpticSim.israyorigininterval\nOpticSim.halfspaceintersection\nOpticSim.closestintersection\nOpticSim.IntervalPool","category":"page"},{"location":"csg/#OpticSim.Interval","page":"CSG","title":"OpticSim.Interval","text":"Interval{T} <: AbstractRayInterval{T}\n\nDatatype representing an interval between two IntervalPoints on a ray.\n\nThe lower element can either be RayOrigin or an Intersection. The upper element can either be an Intersection or Infinity.\n\npositivehalfspace(int::Intersection) -> Interval with lower = int, upper = Infinity\nrayorigininterval(int::Intersection) -> Interval with lower = RayOrigin, upper = int\nInterval(low, high)\n\nHas the following accessor methods:\n\nlower(a::Interval{T}) -> Union{RayOrigin{T},Intersection{T,3}}\nupper(a::Interval{T}) -> Union{Intersection{T,3},Infinity{T}}\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.EmptyInterval","page":"CSG","title":"OpticSim.EmptyInterval","text":"EmptyInterval{T} <: AbstractRayInterval{T}\n\nAn interval with no Intersections which is also not infinite.\n\nEmptyInterval(T = Float64)\nEmptyInterval{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.DisjointUnion","page":"CSG","title":"OpticSim.DisjointUnion","text":"Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of Intervals can be input to the constructor and they will automatically be processed into a valid DisjointUnion (or a single Interval if appropriate).\n\nDisjointUnion(intervals::AbstractVector{Interval{R}})\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.isemptyinterval","page":"CSG","title":"OpticSim.isemptyinterval","text":"isemptyinterval(a) -> Bool\n\nReturns true if a is an EmptyInterval. In performance critical contexts use a isa EmptyInterval{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.ispositivehalfspace","page":"CSG","title":"OpticSim.ispositivehalfspace","text":"ispositivehalfspace(a) -> Bool\n\nReturns true if upper(a) is Infinity. In performance critical contexts check directly i.e. upper(a) isa Infinity{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.israyorigininterval","page":"CSG","title":"OpticSim.israyorigininterval","text":"israyorigininterval(a) -> Bool\n\nReturns true if lower(a) is RayOrigin. In performance critical contexts check directly i.e. lower(a) isa RayOrigin{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.halfspaceintersection","page":"CSG","title":"OpticSim.halfspaceintersection","text":"halfspaceintersection(a::Interval{T}) -> Intersection{T,3}\n\nReturns the Intersection from a half space Interval, throws an error if not a half space.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.closestintersection","page":"CSG","title":"OpticSim.closestintersection","text":"closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -> Union{Nothing,Intersection{T,3}}\n\nReturns the closest Intersection from an Interval or DisjointUnion. Ignores intersection with null interfaces if ignorenull is true. Will return nothing if there is no valid intersection.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.IntervalPool","page":"CSG","title":"OpticSim.IntervalPool","text":"To prevent allocations we have a manually managed pool of arrays of Intervals which are used to store values during execution. The memory is kept allocated and reused across runs of functions like trace.\n\nthreadedintervalpool is a global threadsafe pool which is accessed through the functions:\n\nnewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -> Vector{Interval{T}}\nindexednewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -> Tuple{Int,Vector{Interval{T}}}\nemptyintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid())\ngetfromintervalpool([::Type{T} = Float64], id::Int, tid::Int = Threads.threadid()) -> Vector{Interval{T}}\n\n\n\n\n\n","category":"type"},{"location":"csg/#Intersections","page":"CSG","title":"Intersections","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"OpticSim.IntervalPoint\nRayOrigin\nInfinity\nIntersection\nOpticSim.isinfinity\nOpticSim.israyorigin","category":"page"},{"location":"csg/#OpticSim.IntervalPoint","page":"CSG","title":"OpticSim.IntervalPoint","text":"Each Interval consists of two IntervalPoints, one of RayOrigin, Intersection or Infinity.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.RayOrigin","page":"CSG","title":"OpticSim.RayOrigin","text":"RayOrigin{T} <: IntervalPoint{T}\n\nPoint representing 0 within an Interval, i.e. the start of the ray.\n\nRayOrigin(T = Float64)\nRayOrigin{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.Infinity","page":"CSG","title":"OpticSim.Infinity","text":"Infinity{T} <: IntervalPoint{T}\n\nPoint representing ∞ within an Interval.\n\nInfinity(T = Float64)\nInfinity{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.Intersection","page":"CSG","title":"OpticSim.Intersection","text":"Intersection{T,N} <: IntervalPoint{T}\n\nRepresents the point at which an Ray hits a Surface. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the OpticalInterface hit.\n\nHas the following accessor methods:\n\npoint(a::Intersection{T,N}) -> SVector{N,T}\nnormal(a::Intersection{T,N}) -> SVector{N,T}\nuv(a::Intersection{T,N}) -> SVector{2,T}\nu(a::Intersection{T,N}) -> T\nv(a::Intersection{T,N}) -> T\nα(a::Intersection{T,N}) -> T\ninterface(a::Intersection{T,N}) -> OpticalInterface{T}\nflippednormal(a::Intersection{T,N}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.isinfinity","page":"CSG","title":"OpticSim.isinfinity","text":"isinfinity(a) -> Bool\n\nReturns true if a is Infinity. In performance critical contexts use a isa Infinity{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.israyorigin","page":"CSG","title":"OpticSim.israyorigin","text":"israyorigin(a) -> Bool\n\nReturns true if a is RayOrigin. In performance critical contexts use a isa RayOrigin{T}.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CodeTracking, Markdown, OpticSim.Examples\nmdparse(s) = Markdown.parse(\"```julia\\n$s\\n```\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpticSim.Examples","category":"page"},{"location":"examples/#Pluto-Notebooks","page":"Examples","title":"Pluto Notebooks","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The OpticSim package comes with several Pluto notebooks (code snippets are coming soon) that allow the user to change and run sample code and view the results in real-time. We highly recommend for you to try these out. The notebooks are located in the samples folder, and you can try them by running:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import OpticSim.NotebooksUtils as NB    # the **as** option was added in Julia v1.6\n\nNB.run_sample(\"EmittersIntro.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The run_sample method will copy the notebook to your current folder (if it does not exist) and launch Pluto to run the notebook in the browser.","category":"page"},{"location":"examples/#Cooke-Triplet","page":"Examples","title":"Cooke Triplet","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_cooketriplet()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sys = draw_cooketriplet(\"assets/cooke.png\"); @show sys; nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Cooke triplet visualization)","category":"page"},{"location":"examples/#Zoom-Lens","page":"Examples","title":"Zoom Lens","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_zoomlenses()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"syss = draw_zoomlenses([\"assets/zoom$i.png\" for i in 1:3]); @show syss[1]; nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Zoom position 1 visualization) (Image: Zoom position 2 visualization) (Image: Zoom position 3 visualization)","category":"page"},{"location":"examples/#Schmidt-Cassegrain-Telescope","page":"Examples","title":"Schmidt Cassegrain Telescope","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_schmidtcassegraintelescope()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"draw_schmidtcassegraintelescope(\"assets/tele.png\") # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Schmidt Cassegrain Telescope visualization)","category":"page"},{"location":"examples/#Lens-Construction","page":"Examples","title":"Lens Construction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_lensconstruction()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"draw_lensconstruction(\"assets/qtype.png\") # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: lens construction example)","category":"page"},{"location":"examples/#HOEs","page":"Examples","title":"HOEs","text":"","category":"section"},{"location":"examples/#Focusing","page":"Examples","title":"Focusing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_HOEfocus()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"draw_HOEfocus(\"assets/hoe_f.png\") # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Focusing HOE example)","category":"page"},{"location":"examples/#Collimating","page":"Examples","title":"Collimating","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_HOEcollimate()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"draw_HOEcollimate(\"assets/hoe_c.png\") # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Collimating HOE example)","category":"page"},{"location":"examples/#Multi","page":"Examples","title":"Multi","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_multiHOE()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"draw_multiHOE(\"assets/hoe_m.png\") # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Multi-HOE example)","category":"page"},{"location":"examples/#Deterministic-Raytracing","page":"Examples","title":"Deterministic Raytracing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"mdparse(@code_string draw_stackedbeamsplitters()) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"draw_stackedbeamsplitters([\"assets/deterministic_trace_$i.png\" for i in 1:3]) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Nondeterministic Raytrace) (Image: Transmission only) (Image: Reflection only)","category":"page"},{"location":"basic_types/#Basic-Types","page":"Basic Types","title":"Basic Types","text":"","category":"section"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"The following are basic geometric types and utilities, such as vectors and transforms, that are used all acoross the package. Using these types requires, in addition to the using OpticSim statement to also use the OpticSim.Geoemtry module like:","category":"page"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"using OpticSim, OpticSim.Geometry","category":"page"},{"location":"basic_types/#Vec3","page":"Basic Types","title":"Vec3","text":"","category":"section"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"Representing a 3D vector.","category":"page"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"OpticSim.Geometry.Vec3\nOpticSim.Geometry.unitX3\nOpticSim.Geometry.unitY3\nOpticSim.Geometry.unitZ3","category":"page"},{"location":"basic_types/#OpticSim.Geometry.Vec3","page":"Basic Types","title":"OpticSim.Geometry.Vec3","text":"Vec3{T} provides an immutable vector of fixed length 3 and type T.\n\nVec3 defines a series of convenience constructors, so you can just type e.g. Vec3(1, 2, 3) or Vec3([1.0, 2.0, 3.0]).  It also supports comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as Vec3(rand(3)).\n\n\n\n\n\n","category":"type"},{"location":"basic_types/#OpticSim.Geometry.unitX3","page":"Basic Types","title":"OpticSim.Geometry.unitX3","text":"returns the unit vector [1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.unitY3","page":"Basic Types","title":"OpticSim.Geometry.unitY3","text":"returns the unit vector [0, 1, 0]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.unitZ3","page":"Basic Types","title":"OpticSim.Geometry.unitZ3","text":"returns the unit vector [0, 0, 1]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#Vec4","page":"Basic Types","title":"Vec4","text":"","category":"section"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"Representing a 4D vector ","category":"page"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"OpticSim.Geometry.Vec4\nOpticSim.Geometry.unitX4\nOpticSim.Geometry.unitY4\nOpticSim.Geometry.unitZ4\nOpticSim.Geometry.unitW4","category":"page"},{"location":"basic_types/#OpticSim.Geometry.Vec4","page":"Basic Types","title":"OpticSim.Geometry.Vec4","text":"Vec4{T} provides an immutable vector of fixed length 4 and type T.\n\nVec4 defines a series of convenience constructors, so you can just type e.g. Vec3(1, 2, 3, 4) or Vec3([1.0, 2.0, 3.0, 4.0]).  It also supports comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as Vec4(rand(4)).\n\n\n\n\n\n","category":"type"},{"location":"basic_types/#OpticSim.Geometry.unitX4","page":"Basic Types","title":"OpticSim.Geometry.unitX4","text":"returns the unit vector [1, 0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.unitY4","page":"Basic Types","title":"OpticSim.Geometry.unitY4","text":"returns the unit vector [0, 1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.unitZ4","page":"Basic Types","title":"OpticSim.Geometry.unitZ4","text":"returns the unit vector [0, 0, 1, 0]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.unitW4","page":"Basic Types","title":"OpticSim.Geometry.unitW4","text":"returns the unit vector [0, 0, 0, 1]\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#Transform","page":"Basic Types","title":"Transform","text":"","category":"section"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"Representing a general 3D transform (4x4 matrix). Currently only used as a rigid-body transform. Transforms are used to position surfaces within the CSG tree, position emitters in 3D, etc. ","category":"page"},{"location":"basic_types/","page":"Basic Types","title":"Basic Types","text":"OpticSim.Geometry.Transform\nOpticSim.Geometry.identitytransform\nOpticSim.Geometry.rotationX\nOpticSim.Geometry.rotationY\nOpticSim.Geometry.rotationZ\nOpticSim.Geometry.rotation\nOpticSim.Geometry.rotationd\nOpticSim.Geometry.rotate\nOpticSim.Geometry.translation\nOpticSim.Geometry.rotmat\nOpticSim.Geometry.rotmatd\nOpticSim.Geometry.rotmatbetween","category":"page"},{"location":"basic_types/#OpticSim.Geometry.Transform","page":"Basic Types","title":"OpticSim.Geometry.Transform","text":"Transform{S<:Real}\n\nTransform encapsulating rotation, translation and scale in 3D space. Translation happens after rotation.\n\nTransform{S}(θ::T, ϕ::T, ψ::T, x::T, y::T, z::T)\nTransform(rotation::SMatrix{3,3,S}, translation::SVector{3,S})\nTransform(rotation::AbstractArray{S,2}, translation::AbstractArray{S,1})\n\nθ, ϕ and ψ in first constructor are in radians.\n\n\n\n\n\n","category":"type"},{"location":"basic_types/#OpticSim.Geometry.identitytransform","page":"Basic Types","title":"OpticSim.Geometry.identitytransform","text":"identitytransform([S::Type]) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotationX","page":"Basic Types","title":"OpticSim.Geometry.rotationX","text":"rotationX(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the x-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotationY","page":"Basic Types","title":"OpticSim.Geometry.rotationY","text":"rotationY(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the y-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotationZ","page":"Basic Types","title":"OpticSim.Geometry.rotationZ","text":"rotationZ(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the z-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotation","page":"Basic Types","title":"OpticSim.Geometry.rotation","text":"rotation(t::Transform{T}) where {T<:Real} -> SMatrix{3,3,T}\n\nreturns the rotation part of the transform t - a 3x3 matrix.\n\n\n\n\n\nrotation([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotationd","page":"Basic Types","title":"OpticSim.Geometry.rotationd","text":"rotationd([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotate","page":"Basic Types","title":"OpticSim.Geometry.rotate","text":"rotate(a::Transform{T}, vector::Union{Vec3{T}, SVector{3,T}}) where {T<:Real} -> Vec3{T}\n\napply the rotation part of the transform a to the vector vector - this operation is usually used to rotate direction vectors.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.translation","page":"Basic Types","title":"OpticSim.Geometry.translation","text":"translation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\ntranslation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotmat","page":"Basic Types","title":"OpticSim.Geometry.rotmat","text":"rotmat([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotmatd","page":"Basic Types","title":"OpticSim.Geometry.rotmatd","text":"rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"function"},{"location":"basic_types/#OpticSim.Geometry.rotmatbetween","page":"Basic Types","title":"OpticSim.Geometry.rotmatbetween","text":"rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation between vetors a and b, i.e. rotation(a,b) * a = b.\n\n\n\n\n\n","category":"function"},{"location":"repeat/#Repeating-Structures","page":"Repeating Structures","title":"Repeating Structures","text":"","category":"section"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"The Repeat module contains functions for creating regular repeated patterns. This could be pixels in a display grid, or mirrors in an active optics telescope. Repeated patterns are defined by creating an object that inherits from the abstract type Basis.","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"Subtypes supporting the Basis interface should implement these functions:","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"Returns the neighbors in ring n surrounding centerpoint, excluding centerpoint","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"neighbors(::Type{B},centerpoint::Tuple{T,T},neighborhoodsize::Int) where{T<:Real,B<:Basis}","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"Returns the lattice basis vectors that define the lattice","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"basis(a::S) where{S<:Basis}","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"Returns the vertices of the unit polygon for the basis that tiles the plane ","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"tilevertices(a::S) where{S<:Basis}","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"A lattice is described by a set of lattice vectors eᵢ which are stored in a Basis object. You can create bases in any dimension. Points in the lattice are indexed by integer coordinates. These lattice coordinates can be converted to Cartesian coordinates by indexing the LatticeBasis object. ","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"using OpticSim, OpticSim.Repeat\na = LatticeBasis([1.0,5.0],[0.0,1.0])\na[3,3]","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"The Lattice points are defined by a weighted sum of the basis vectors:","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"latticepoint = ∑αᵢ*eᵢ","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"where the αᵢ are integer weights.","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"The HexBasis1 constructor defines a symmetric basis for hexagonal lattices ","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"using OpticSim, OpticSim.Repeat\nbasis(HexBasis1())","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"The rectangularlattice function creates a rectangular lattice basis. ","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"There are a few visualization functions for special 2D lattices. Vis.drawhexcells draws a set of hexagonal cells. Using Repeat.hexcellsinbox we can draw all the hexagonal cells that fit in a rectangular box:","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"using OpticSim\nVis.drawhexcells(50,Repeat.hexcellsinbox(2,2))","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"There is also a function to compute the n rings of a cell x, i.e., the cells which can be reached by taking no more than n steps along the lattice from x:","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"using OpticSim\nVis.drawhexcells(50,Repeat.neighbors(Repeat.HexBasis1,(0,0),2))","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"You can also draw all the cells contained within an n ring:","category":"page"},{"location":"repeat/","page":"Repeating Structures","title":"Repeating Structures","text":"using OpticSim\nVis.drawhexcells(50,Repeat.region(Repeat.HexBasis1,(0,0),2))","category":"page"},{"location":"cloud/#Cloud-Execution","page":"Cloud Execution","title":"Cloud Execution","text":"","category":"section"},{"location":"cloud/#Azure","page":"Cloud Execution","title":"Azure","text":"","category":"section"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"A key benefit and design motivation of OpticSim is being able to execute many simulations/optimizations at once. This is best enabled through the use of cloud computing services such as Azure.","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"As part of the base package, we provide support for cloud execution using an Azure Machine Learning workspace.","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"To use this functionally you'll first need to set up an AML workspace with a compute cluster. Then you'll need to provide a few bits of information to OpticSim:","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"Subscription ID, of the form XXXXXXXX-XXX-XXX-XXXX-XXXXXXXXXXXX\nResource group name\nWorkspace name\nCompute cluster name","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"This information can be cached either to a specific file, or globally:","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"OpticSim.Cloud.cache_run_config\nOpticSim.Cloud.get_cached_run_config","category":"page"},{"location":"cloud/#OpticSim.Cloud.cache_run_config","page":"Cloud Execution","title":"OpticSim.Cloud.cache_run_config","text":"cache_run_config(subscription_id::String, resource_group::String, workspace_name::String, compute_name::String[, path::String])\n\nWrites the AML config information to a file at path. If path isn't set then the config will be used globally for that OpticSim install.\n\n\n\n\n\n","category":"function"},{"location":"cloud/#OpticSim.Cloud.get_cached_run_config","page":"Cloud Execution","title":"OpticSim.Cloud.get_cached_run_config","text":"get_cached_run_config([path::String])\n\nReads the AML config information from a file at path. If not specified then the global config will be read.\n\n\n\n\n\n","category":"function"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"You should also include an .amlignore file in the root of your project. This is similar to a .gitignore file and should include any files which should not be uploaded to AML as part of your source snapshot, for examples test/.","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"note: Note\nManifest.toml must be listed in your .amlignore file.","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"If an .amlignore doesn't already exist then one will be created on the first submission of a run to AML.","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"Once everything is configured, you can submit a run:","category":"page"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"OpticSim.Cloud.submit_run_to_AML","category":"page"},{"location":"cloud/#OpticSim.Cloud.submit_run_to_AML","page":"Cloud Execution","title":"OpticSim.Cloud.submit_run_to_AML","text":"submit_run_to_AML(run_name::String, path_to_script::String, script_args::Vector{String} = nothing, sampled_args:Dict{String,Vector{String}} = nothing, config_path::String; hyperdrive_concurrent_runs::Int = 10)\nsubmit_run_to_AML(run_name::String, path_to_script::String, subscription_id::String, resource_group::String, workspace_name::String, compute_name::String, script_args::Vector{String} = nothing, sampled_args::Dict{String, Vector{String}} = nothing; hyperdrive_concurrent_runs::Int = 10)\n\nSubmit a run to AML, path_to_script is relative to your local package root (i.e. location of Project.toml). script_args are a series of arguments to your script as strings. sampled_args is a dictionary where keys are argument names and values are lists of values (as strings) that that argument will take. config_path is a path to a config file as written by cache_run_config, if not specified the global config is used. Alternatively this information can be provided directly using the second method above. hyperdrive_concurrent_runs is the maximum number of concurrent runs that will execute on AML (limited by your compute cluster size).\n\n\n\n\n\n","category":"function"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"To retrieve outputs from your run simply write files to the outputs/ directory and the files will automatically appear as part of the AML run.","category":"page"},{"location":"cloud/#Examples","page":"Cloud Execution","title":"Examples","text":"","category":"section"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"using OpticSim.Cloud\n\ncache_run_config([subscription_id], [resource_group_name], [workspace_name], [compute_name], [path_to_config])\n\nsubmit_run_to_AML(\"example-run\", [path_to_script], [\"--arg1\", \"1\", \"--arg2\", \"2\"], nothing, [path_to_config])\n\nsubmit_run_to_AML(\"example-hyperdrive-run\", [path_to_script], [\"--arg1\", \"1\"], Dict(\"--arg2\" => [\"1\", \"2\", \"3\"]), [path_to_config])","category":"page"},{"location":"cloud/#Other-Cloud-Services","page":"Cloud Execution","title":"Other Cloud Services","text":"","category":"section"},{"location":"cloud/","page":"Cloud Execution","title":"Cloud Execution","text":"Currently no other services are supported, though it should be reasonably straightforward to add similar functionality to that for AML.","category":"page"},{"location":"ref/#Complete-Reference","page":"Reference","title":"Complete Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"This page contains what should be a complete list of all docstrings in the OpticSim module, and its submodule.","category":"page"},{"location":"ref/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Pages   = [\"ref.md\"]","category":"page"},{"location":"ref/#OpticSim","page":"Reference","title":"OpticSim","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim]","category":"page"},{"location":"ref/#OpticSim.BSplineCurve","page":"Reference","title":"OpticSim.BSplineCurve","text":"BSplineCurve{P,S,N,M} <: Spline{P,S,N,M}\n\nN is the spatial dimension of the curve. M is the curve order, i.e., the highest power of the parameterizing variable, u. All curve segments are assumed to be of the same order.\n\nBSplineCurve{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{MVector{N,S},1})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BeamState","page":"Reference","title":"OpticSim.BeamState","text":"ConvergingBeam, DivergingBeam or CollimatedBeam, defines the behavior of a beam in a HologramInterface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BezierCurve","page":"Reference","title":"OpticSim.BezierCurve","text":"BezierCurve{P,S,N,M} <: Spline{P,S,N,M}\n\nN is the dimension of the curve, M is the curve order\n\nBezierCurve{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},1})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CircularStopShape","page":"Reference","title":"OpticSim.CircularStopShape","text":"CircularStopShape <: StopShape\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ConvexPolygon","page":"Reference","title":"OpticSim.ConvexPolygon","text":"ConvexPolygon{N, T<:Real} <: PlanarShape{T}\n\nGeneral Convex Polygon surface, not a valid CSG object. The rotation of the polygon around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nConvexPolygon(local_frame::Transform{T}, local_polygon_points::Vector{SVector{2, T}}, interface::NullOrFresnel{T} = nullinterface(T))\n\nThe local frame defines the plane (spans by the right and up vectors) with the plane normal given by the forward vector. the localpolygonpoints are given with respect to the local frame and are 2D points. NOTE: This class uses static vectors to hold the points which will lead to more efficient performance, but should not be used with polygons with more than 20-30 points.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CurveType","page":"Reference","title":"OpticSim.CurveType","text":"Either Rational or Euclidean, used for Splines and SplineSurfaces.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.GeometricRayGenerator","page":"Reference","title":"OpticSim.GeometricRayGenerator","text":"GeometricRayGenerator{T,O<:RayOriginGenerator{T}} <: AbstractRayGenerator{T}\n\nGenerates geometric Rays according to the specific implementation of the subclass.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.GridSagInterpolation","page":"Reference","title":"OpticSim.GridSagInterpolation","text":"Either GridSagLinear or GridSagBicubic - determines the interpolation between sample points in the grid for a GridSagSurface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.InterfaceMode","page":"Reference","title":"OpticSim.InterfaceMode","text":"Valid modes for deterministic raytracing\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.KnotVector","page":"Reference","title":"OpticSim.KnotVector","text":"KnotVector{T<:Number}\n\nVector to define knots used for BSplineCurve and BSplineSurface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.OpticalRay","page":"Reference","title":"OpticSim.OpticalRay","text":"OpticalRay{T,N} <: AbstractRay{T,N}\n\nRay with power, wavelength and optical path length.\n\nNOTE: we use monte carlo integration to get accurate results on the detector, this means that all rays essentially hit the detector with power = 1 and some rays are thrown away at any interface to correctly match the reflection/transmission at that interface. For inspection purposes we also track the 'instantaneous' power of the ray in the power field of the OpticalRay.\n\nOpticalRay(ray::Ray{T,N}, power::T, wavelength::T, opl=zero(T))\nOpticalRay(origin::SVector{N,T}, direction::SVector{N,T}, power::T, wavelength::T, opl=zero(T))\n\nHas the following accessor methods:\n\nray(r::OpticalRay{T,N}) -> Ray{T,N}\ndirection(r::OpticalRay{T,N}) -> SVector{N,T}\norigin(r::OpticalRay{T,N}) -> SVector{N,T}\npower(r::OpticalRay{T,N}) -> T\nwavelength(r::OpticalRay{T,N}) -> T\npathlength(r::OpticalRay{T,N}) -> T\nsourcepower(r::OpticalRay{T,N}) -> T\nnhits(r::OpticalRay{T,N}) -> Int\nsourcenum(r::OpticalRay{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.OpticalRayGenerator","page":"Reference","title":"OpticSim.OpticalRayGenerator","text":"OpticalRayGenerator{T} <: AbstractRayGenerator{T}\n\nGenerates OpticalRays according to the specific implementation of the subclass.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.PlanarShape","page":"Reference","title":"OpticSim.PlanarShape","text":"The PlanarShape interface:\n\ndistancefromplane(p::PlanarShape,point)  returns distance of the point from the plane the planar shape lies within normal(p::PlanarShape) returns normal of plane interface(p::PlanarShape) returns optical interface of plane vertices(p::PlanarShape) returns vertices of shape. For Ellipse this is an approximation.\n\nThere are default functions for plane,normal,interface,vertices which assume each PlanarShape type has a field of the same name plane(a::PlanarShape) = a.plane     normal(a::PlanaShape) = a.plane.normal etc.\n\nIf your type doesn't have these fields then you should define a more specialized method to handle this.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Primitive","page":"Reference","title":"OpticSim.Primitive","text":"Primitive{T<:Real}\n\nT is the number type used to represent the primitive,  e.g., Float64. Primitives are the basic elements which can be stored in bounding volume hierarchies and include surfaces and CSG objects\n\nMust implement the following:\n\nboundingbox(a::Primitive{T})::BoundingBox{T}\ncentroid(a::Primitive{T})::SVector{3,T}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Ray","page":"Reference","title":"OpticSim.Ray","text":"Ray{T,N} <: AbstractRay{T,N}\n\nPurely geometric ray, defined as origin + alpha * direction.\n\nRay(origin::SVector{N,T}, direction::SVector{N,T})\n\nHas the following accessor methods:\n\ndirection(ray::Ray{T,N}) -> SVector{N,T}\norigin(ray::Ray{T,N}) -> SVector{N,T}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.RectangularStopShape","page":"Reference","title":"OpticSim.RectangularStopShape","text":"RectangularStopShape <: StopShape\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Spline","page":"Reference","title":"OpticSim.Spline","text":"Spline{P<:CurveType,S<:Number,N,M}\n\nM is the curve order, i.e., the highest power of the parameterizing variable, u. P determines the CurveType.\n\nAll Spline types must implement:\n\npoint(curve,u)\n\nand have field controlpolygon\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.SplineSurface","page":"Reference","title":"OpticSim.SplineSurface","text":"SplineSurface{P,S,N,M} <: ParametricSurface{S,N}\n\nCurve order, M, is the same in the u and v direction and fixed over all spans. P determines the CurveType.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.StopSurface","page":"Reference","title":"OpticSim.StopSurface","text":"StopSurface{T} <: Surface{T}\n\nAbstract type to encapsulate any surfaces acting as a stop.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ZernikeIndexType","page":"Reference","title":"OpticSim.ZernikeIndexType","text":"Either ZernikeIndexingOSA or ZernikeIndexingNoll, see Zernike polynomials wikipedia entry for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Intersection{T, 3}}} where T<:Real","page":"Reference","title":"Base.:*","text":"Apply a Transform to an Intersection object\n\n\n\n\n\n","category":"method"},{"location":"ref/#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Interval{T}}} where T<:Real","page":"Reference","title":"Base.:*","text":"Apply a Transform to an Interval object\n\n\n\n\n\n","category":"method"},{"location":"ref/#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Ray{T, 3}}} where T","page":"Reference","title":"Base.:*","text":"Apply a Transform to a Ray object\n\n\n\n\n\n","category":"method"},{"location":"ref/#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, TriangleMesh{T}}} where T<:Real","page":"Reference","title":"Base.:*","text":"Apply a Transform to a TriangleMesh object\n\n\n\n\n\n","category":"method"},{"location":"ref/#Base.:*-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, Triangle{T}}} where T<:Real","page":"Reference","title":"Base.:*","text":"Apply a Transform to a Triangle object\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Annulus","text":"Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a circle i.e. FiniteStop{T,CircularStopShape,CircularStopShape}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.ArizonaEye","text":"ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)\n\nThe popular Arizona eye model taken from this definition. The accommodation of the eye can be varied in this model. Returns a DataFrame specifying the prescription of the eye model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R<:OpticSim.GlassCat.AbstractGlass, Q<:OpticSim.GlassCat.AbstractGlass, T<:OpticSim.GlassCat.AbstractGlass, S<:Real}","page":"Reference","title":"OpticSim.AsphericLens","text":"AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nCosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.BoundedCylinder","text":"BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cylinder with planar caps on both ends centred at (0, 0, 0) with axis (0, 0, 1).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Circle","text":"Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))\n\nShortcut method to create a circle. The minimal case returns a circle centred at the origin with normal = [0, 0, 1].\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a plane i.e. InfiniteStop{T,CircularStopShape}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a circular aperture in a rectangle i.e. FiniteStop{T,CircularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S, S, S}} where {R<:OpticSim.GlassCat.AbstractGlass, Q<:OpticSim.GlassCat.AbstractGlass, T<:OpticSim.GlassCat.AbstractGlass, S<:Real}","page":"Reference","title":"OpticSim.ConicLens","text":"ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.Cuboid","text":"Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cuboid centred at (0, 0, 0).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, T, T, T, T, T}} where {T<:Real, G<:OpticSim.GlassCat.AbstractGlass, H<:OpticSim.GlassCat.AbstractGlass}","page":"Reference","title":"OpticSim.FresnelLens","text":"FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = OpticSim.GlassCat.Air)\n\nCreate a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on groovedepth. For negative radii the vertex on the central surface is at frontvertex, so the total thickness of the lens is thickness + groovedepth. Aspherics currently not supported.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.GridField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C<:(CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}})}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.GridField","text":"GridField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over the entrance pupil of the system in a rectangular grid pattern.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.GridField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.GridField","text":"GridField(semidiameter, pupilpos; collimated = true, samples = 20, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over a circular pupil with half-diameter defined by semidiameter, centred at pupilpos in a rectangular grid pattern. samples is the number of rays on each side of the grid, so there are samples×samples rays in total.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.HexagonalPrism","text":"HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall hexagonal prism with axis (0, 0, 1), the longer hexagon diameter is along the x axis. For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexapolarField-Union{Tuple{AxisymmetricOpticalSystem{T, C} where C<:(CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}})}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.HexapolarField","text":"HexapolarField(sys::AxisymmetricOpticalSystem; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over the entrance pupil of the system in a hexapolar pattern.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexapolarField-Union{Tuple{T}, Tuple{T, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.HexapolarField","text":"HexapolarField(semidiameter, pupilpos; collimated = true, samples = 8, wavelength = 0.55, sourcepos = (0.0, 0.0, 3.0), sourceangle = 0.0, sourcenum = 0)\n\nDistributes rays over a circular pupil with half-diameter defined by semidiameter, centred at pupilpos in a hexapolar pattern. samples is the number of rings in the hexapolar pattern, so the number of rays in total is samples * (samples + 1) / 2) * 6 + 1.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:Real}","page":"Reference","title":"OpticSim.ModelEye","text":"ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::Transform{T} = identitytransform(T))\n\nGeometrically accurate model of the human eye focussed at infinity with variable pupil_radius. The eye is added to the provided assembly to create a CSGOpticalSystem with the retina of the eye as the detector.\n\nThe eye can be positioned in the scene using the transform argument and the resolution of the detector specified with detpixels. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nnsamples determines the resolution at which accelerated surfaces within the eye are triangulated.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.RectangularAperture","text":"RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a plane i.e. InfiniteStop{T,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.RectangularAperture","text":"RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a rectangle i.e. FiniteStop{T,RectangularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.RectangularPrism","text":"RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall rectangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, S, S}} where {R<:OpticSim.GlassCat.AbstractGlass, Q<:OpticSim.GlassCat.AbstractGlass, T<:OpticSim.GlassCat.AbstractGlass, S<:Real}","page":"Reference","title":"OpticSim.SphericalLens","text":"SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = OpticSim.GlassCat.Air, nextmaterial = OpticSim.GlassCat.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}}, Tuple{Int64, T, T, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Spider","text":"Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -> Vector{Rectangle{T}}\n\nCreates a 'spider' obscuration with narms rectangular arms evenly spaced around a circle defined by origin and normal. Each arm is a rectangle armwidth×radius.\n\ne.g. for 3 and 4 arms we get:\n\n   |         _|_\n  / \\         |\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.TriangularPrism","text":"TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall triangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.area-Union{Tuple{SphericalPolygon{N, T}}, Tuple{N}, Tuple{T}} where {T<:Real, N}","page":"Reference","title":"OpticSim.area","text":"Conceptually breaks the convex spherical polygon into spherical triangles and computes the sum of the angles of all the triangles. The sum of all the angles around the centroid is 2π. Have to subtract π for each of the N triangles. Rather than compute the angles of triangles formed by taking edges from the centroid to each vertex, can instead just compute the internal angle of neighboring edges. Total polygon area is 2π -Nπ + ∑(interior angles).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.assembly","text":"assembly(system::AbstractOpticalSystem{T}) -> LensAssembly{T}\n\nGet the LensAssembly of system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.closestintersection","page":"Reference","title":"OpticSim.closestintersection","text":"closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -> Union{Nothing,Intersection{T,3}}\n\nReturns the closest Intersection from an Interval or DisjointUnion. Ignores intersection with null interfaces if ignorenull is true. Will return nothing if there is no valid intersection.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}","page":"Reference","title":"OpticSim.closestpointonray","text":"closestpointonray(r::Ray{T,N}, point::SVector{N,T}) -> SVector{T,N\n\nReturns the point on the ray closest to point.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.curvedimension-Tuple{Array}","page":"Reference","title":"OpticSim.curvedimension","text":"spatial dimension of curve represented as an array of coefficients x[i] = ∑Bj(θ)*x[i,j] where Bj(θ) is the curve basis\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.curveorder-Tuple{Array}","page":"Reference","title":"OpticSim.curveorder","text":"highest polynomial power of the curve represented as an array of coefficients x[i] = ∑Bj(θ)*x[i,j] where Bj(θ) is the curve basis\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.detectorimage-Tuple{CSGOpticalSystem}","page":"Reference","title":"OpticSim.detectorimage","text":"detectorimage(system::AbstractOpticalSystem{T}) -> HierarchicalImage{D}\n\nGet the detector image of system. D is the datatype of the detector image and is not necessarily the same as the datatype of the system T.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.distance-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T, N}","page":"Reference","title":"OpticSim.distance","text":"distance(r::Ray{T,N}, point::SVector{N,T}) -> Union{Nothing,T}\n\nReturns distance to the position on the ray closest to point. If t < 0 returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArrays.SVector{3, T} where T}","page":"Reference","title":"OpticSim.distancefromplane","text":"All planar shapes lie on a plane. This function computes the distance from a point to that plane. This is a signed distance. If the point is on the positive side of the plane (the side the normal points toward) the distance will be positive, otherwise negative or 0 if the point lies in the plane.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T<:Real","page":"Reference","title":"OpticSim.doesintersect","text":"doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Bool\n\nTests whether r intersects an axis-aligned BoundingBox, bbox.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.evalcsg","page":"Reference","title":"OpticSim.evalcsg","text":"evalcsg(\n    a::Union{UnionNode{T},IntersectionNode{T},ComplementNode{T},LeafNode{T}},\n    ray::AbstractRay{T,N},\n    normalreverse::Bool = false\n)::Union{EmptyInterval{T},DisjointUnion{T},Interval{T}}\n\n[TODO]\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.evaluatecurve-Union{Tuple{T}, Tuple{Matrix{T}, Real}} where T<:Real","page":"Reference","title":"OpticSim.evaluatecurve","text":"Evaluates a curve defined in the power basis. Curves and moving lines accessed like this: [xi,ci] where xi is the dimension index, and ci is the coefficient index.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.extractmovinglines-NTuple{4, Any}","page":"Reference","title":"OpticSim.extractmovinglines","text":"returns 3D array indexed like this: x[line curve order,spatial dimension, line number]`\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.fresnel-Union{Tuple{T}, NTuple{4, T}} where T<:Real","page":"Reference","title":"OpticSim.fresnel","text":"fresnel(nᵢ::T, nₜ::T, sinθᵢ::T, sinθₜ::T) -> Tuple{T,T}\n\nReturns reflectance and tranmission power coefficients according to the Fresnel equations. For geometric ray tracing this coefficient can be used directly to compute intensity on the detector plane. For Huygens phase optics need to take the square root to compute the amplitude. The power of the transmitted and refracted rays may not sum to one because of the area correction applied to the transmitted component. The intensity per area can increase or decrease depending on the indices of refraction.\n\nnᵢ is the RI of the material which the incident ray travels in, nₜ is the RI of the material the transmitted ray travels in. sinθᵢ and sinθₜ are the sin of the angles of incidence and transmission respectively.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.halfspaceintersection-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.halfspaceintersection","text":"halfspaceintersection(a::Interval{T}) -> Intersection{T,3}\n\nReturns the Intersection from a half space Interval, throws an error if not a half space.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S<:ParametricSurface{T, N}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.interface","text":"interface(surf::Surface{T}) -> OpticalInterface{T}\n\nReturn the OpticalInterface associated with surf.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T<:Real, N}","page":"Reference","title":"OpticSim.intersections","text":"returns an array of intersection points. Each element in the array is ([x,y,...],alpha,theta) where [x,y,...] is the n-dimensional intersection point, alpha is the line parameter value at the intersection point, and theta is the curve parameter value at the intersection point\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.isemptyinterval-Tuple{EmptyInterval}","page":"Reference","title":"OpticSim.isemptyinterval","text":"isemptyinterval(a) -> Bool\n\nReturns true if a is an EmptyInterval. In performance critical contexts use a isa EmptyInterval{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.isinfinity-Tuple{Infinity}","page":"Reference","title":"OpticSim.isinfinity","text":"isinfinity(a) -> Bool\n\nReturns true if a is Infinity. In performance critical contexts use a isa Infinity{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ispositivehalfspace-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.ispositivehalfspace","text":"ispositivehalfspace(a) -> Bool\n\nReturns true if upper(a) is Infinity. In performance critical contexts check directly i.e. upper(a) isa Infinity{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.israyorigin-Tuple{Any}","page":"Reference","title":"OpticSim.israyorigin","text":"israyorigin(a) -> Bool\n\nReturns true if a is RayOrigin. In performance critical contexts use a isa RayOrigin{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.israyorigininterval-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.israyorigininterval","text":"israyorigininterval(a) -> Bool\n\nReturns true if lower(a) is RayOrigin. In performance critical contexts check directly i.e. lower(a) isa RayOrigin{T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.jacobian-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, T, T, StaticArrays.SVector{M, T}, StaticArrays.SVector{M, T}}} where {T<:Real, N, M}","page":"Reference","title":"OpticSim.jacobian","text":"jacobian(surf::ParametricSurface{T,N}, u::T, v::T, P1::SVector{M,T}, P2::SVector{M,T})\n\nComputes Jacobian of f(t,u,v) = ( dot(P1,[surf(u,v),1],P2,[surf(u,v),1]) ). P1, P2 are orthogonal planes that pass through the ray. J = [ ∂f1/∂u ∂f1/∂v ; ∂f2/∂u ∂f2/∂v]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.leaf-Union{Tuple{ParametricSurface{T, N} where N}, Tuple{T}, Tuple{ParametricSurface{T, N} where N, StaticArrays.SMatrix{4, 4, T, 16}}} where T<:Real","page":"Reference","title":"OpticSim.leaf","text":"leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a leaf node from a parametric surface with a given transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.linedimension-Tuple{Array}","page":"Reference","title":"OpticSim.linedimension","text":"spatial dimension of the moving line represented as an array of coefficients g[i] = ∑Bl(θ)*gl[i,j] where Bl(θ) is the polynomial basis\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T<:Real}","page":"Reference","title":"OpticSim.makemesh","text":"makemesh(poly::ConvexPolygon{N, T}, ::Int = 0) where {N, T<:Real} -> TriangleMesh\n\nCreate a triangle mesh that can be rendered by iterating on the polygon's edges and for each edge use the centroid as the third vertex of the triangle.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}","page":"Reference","title":"OpticSim.makemesh","text":"makemesh(object, subdivisions::Int = 30) -> TriangleMesh\n\nCreates a TriangleMesh from an object, either a ParametricSurface, CSGTree or certain surfaces (e.g. Circle, Rectangle). This is used for visualization purposes only.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.matricesforeigen-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Array{T, 3}}} where {T, N}","page":"Reference","title":"OpticSim.matricesforeigen","text":"movinglines[:,i] is the ith moving line. For li = movinglines[:,i] (dimension+1,lineorder) = size(li). rline[:,1] = pt1 and rline[:,2] = pt2. The line equation is pt1 + alpha*pt2.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.newton-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, AbstractRay{T, N}, StaticArrays.SVector{2, T}}} where {T, N}","page":"Reference","title":"OpticSim.newton","text":"newton(surf::ParametricSurface{T,N}, r::AbstractRay{T,N}, startingpoint::SVector{2,T})\n\nNewton iteration to find the precise intersection of a parametric surface with a ray given a starting point (in uv space) on the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T, N} where N, T, T}} where T<:Real","page":"Reference","title":"OpticSim.normal","text":"normal(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\nnormal(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the normal to surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.numberoflines-Tuple{Array}","page":"Reference","title":"OpticSim.numberoflines","text":"number of lines in moving line array\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.orthogonalitymatrix-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T","page":"Reference","title":"OpticSim.orthogonalitymatrix","text":"returns a matrix expressing the relationship [x(θ) 1]⋅g(θ) = 0. The vectors in the right nullspace of this matrix contain the coefficients of the moving lines gᵢ(θ).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Tuple{OpticSim.VirtualPoint}","page":"Reference","title":"OpticSim.point","text":"This will return (Inf,Inf,Inf) if the point is at infinity. In this case you probably should be using the direction of the VirtualPoint rather than its position\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T<:Real}","page":"Reference","title":"OpticSim.point","text":"point(ray::AbstractRay{T,N}, alpha::T) -> SVector{T, N}\n\nReturns a point on the ray at origin + alpha * direction. Alpha must be >= 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArrays.SMatrix{2, N, T, L} where L}} where {N, T<:Real}","page":"Reference","title":"OpticSim.point","text":"returns a 3D point. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T<:Real","page":"Reference","title":"OpticSim.point","text":"returns a 3D point in the plane of the rectangle. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.pressure","text":"pressure(system::AbstractOpticalSystem{T}) -> T\n\nGet the pressure of system in Atm.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.processintersection-Union{Tuple{N}, Tuple{T}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool}, Tuple{FresnelInterface{T}, StaticArrays.SVector{N, T}, StaticArrays.SVector{N, T}, OpticalRay{T, N}, T, T, Bool, Bool}} where {T<:Real, N}","page":"Reference","title":"OpticSim.processintersection","text":"processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nProcesses an intersection of an OpticalRay with an OpticalInterface, distinct behaviors must be implemented for each subclass of OpticalInterface.\n\npoint is the 3D intersection point in global space, normal is the surface normal at the intersection point.\n\nIf test is true then the behavior of the ray should be deterministic. firstray indicates that this ray is the first segment of the trace and therefore the origin is not offset.\n\nThe values returned are the normalized direction of the ray after the intersection, the instantaneous power of the ray after the intersection and the optical path length of the ray up to the intersection.\n\nnothing is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration nothing should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T","page":"Reference","title":"OpticSim.reset!","text":"reset!(a::HierarchicalImage{T})\n\nResets the pixels in the image to zero(T). Do this rather than image .= zero(T) because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.resetdetector!","text":"resetdetector!(system::AbstractOpticalSystem{T})\n\nReset the deterctor image of system to zero.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.reversenormal-Union{Tuple{Intersection{T, N}}, Tuple{N}, Tuple{T}} where {T<:Real, N}","page":"Reference","title":"OpticSim.reversenormal","text":"reversenormal(a::Intersection{T,N})\n\nUsed by the CSG complement operator (i.e. -) to reverse the inside outside sense of the object.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T<:Real, N}","page":"Reference","title":"OpticSim.samplesurface","text":"samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)\n\nSample a parametric surface on an even numsamples×numsamples grid in UV space with provided function\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}","page":"Reference","title":"OpticSim.semidiameter","text":"semidiameter(system::AxisymmetricOpticalSystem{T}) -> T\n\nGet the semidiameter of system, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.snell-Union{Tuple{S}, Tuple{T}, Tuple{S, S, T, T}} where {T<:Real, S<:(AbstractArray{T, N} where N)}","page":"Reference","title":"OpticSim.snell","text":"snell(surfacenormal::AbstractVector{T}, raydirection::AbstractVector{T}, nᵢ::T, nₜ::T) -> Tuple{T,T}\n\nnᵢ is the index of refraction on the incidence side of the interface. nₜ is the index of refraction on the transmission side.\n\nReturns sinθᵢ and sinθₜ according to Snell's law.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.sphericalangle-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.sphericalangle","text":"returns the spherical angle formed by the cone with centervector at its center with neighbor1,neighbor2 the edges\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.sphericalcircle","page":"Reference","title":"OpticSim.sphericalcircle","text":"creates a circular polygon that subtends a half angle of θ\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T","page":"Reference","title":"OpticSim.sum!","text":"sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})\n\nAdd the contents of b to a in an efficient way.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S<:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}","page":"Reference","title":"OpticSim.surfaceintersection","text":"surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}\n\nCalculates the intersection of r with a surface of any type, surf. Note that some surfaces cannot be intersected analytically so must be wrapped in an AcceleratedParametricSurface in order to be intersected.\n\nReturns an EmptyInterval if there is no Intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.temperature","text":"temperature(system::AbstractOpticalSystem{T}) -> T\n\nGet the temperature of system in °C.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S<:Surface{T}, L<:LensAssembly{T}}, OpticalRay{T, N}}} where {T<:Real, N, D<:Number}","page":"Reference","title":"OpticSim.trace","text":"trace(system::AbstractOpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)\n\nTraces system with ray, if test is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a LensTrace if the ray hits the detector or nothing otherwise.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T<:Real, N}","page":"Reference","title":"OpticSim.trace","text":"trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)\n\nReturns the ray as it exits the assembly in the form of a LensTrace object if it hits any element in the assembly, otherwise nothing. Recursive rays are offset by a small amount (RAY_OFFSET) to prevent it from immediately reintersecting the same lens element.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the assembly.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.trace","text":"trace(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the detector image of the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T<:Real, S<:Number}","page":"Reference","title":"OpticSim.traceMT","text":"traceMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the accumulated detector image from all threads.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.tracehits","text":"tracehits(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.tracehitsMT","text":"tracehitsMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector, accumulated from all threads.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.transform-Union{Tuple{CSGGenerator{T}}, Tuple{T}, Tuple{CSGGenerator{T}, StaticArrays.SMatrix{4, 4, T, 16}}} where T<:Real","page":"Reference","title":"OpticSim.transform","text":"transform(surf::CSGGenerator{T}, transform::Transform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nReturns a new CSGGenerator with another transform applied. This is useful if you want multiple copies of a premade CSG structure with different transforms, for example in an MLA.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool, Bool}} where {T, N}","page":"Reference","title":"OpticSim.triangulate","text":"triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)\n\nCreate an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. detemining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.triangulatedintersection-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S}, AbstractRay{T, N}}} where {T<:Real, N, S}","page":"Reference","title":"OpticSim.triangulatedintersection","text":"triangulatedintersection(surf::AcceleratedParametricSurface{T,N,S}, r::AbstractRay{T,N})\n\nIntersection of a ray, r, with a triangulated surface, surf, no concept of inside so never returns a RayOrigin Interval.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.uv","text":"uv(surf::ParametricSurface{T}, p::SVector{3,T}) -> SVector{2,T}\nuv(surf::ParametricSurface{T}, x::T, y::T, z::T) -> SVector{2,T}\n\nReturns the uv coordinate on surf of a point, p, in 3D space. If onsurface(surf, p) is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uvrange-Tuple{S} where S<:ParametricSurface","page":"Reference","title":"OpticSim.uvrange","text":"uvrange(s::ParametricSurface)\nuvrange(::Type{S}) where {S<:ParametricSurface}\n\nReturns a tuple of the form: ((umin, umax), (vmin, vmax)) specifying the limits of the parameterisation for this surface type. Also implemented for some Surfaces which are not ParametricSurfaces (e.g. Rectangle).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uvtopix-Union{Tuple{T}, Tuple{Rectangle{T}, StaticArrays.SVector{2, T}, Tuple{Int64, Int64}}} where T<:Real","page":"Reference","title":"OpticSim.uvtopix","text":"uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\n\nConverts a uvcoordinate on surf to an integer index to a pixel in an image of size imsize. Not implemented on all Surface objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an AbstractOpticalSystem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices-Tuple{OpticSim.PlanarShape}","page":"Reference","title":"OpticSim.vertices","text":"The vertices of planar shapes are defined in a plane so they are two dimensional. In the local coordinate frame this is the x,y plane, so the implied z coordinate is 0\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices-Tuple{ParaxialLens}","page":"Reference","title":"OpticSim.vertices","text":"returns the 2 dimensional vertex points of the shape defining the lens aperture. These points lie in the plane of the shape\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T<:Real","page":"Reference","title":"OpticSim.vertices","text":"returns the 2D vertices in the plane of the rectangle\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.vertices3d","text":"Returns the vertices of the Hexagon represented in the local coordinate frame. The vertices lie in the z = 0 plane and are 2D\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T<:Real","page":"Reference","title":"OpticSim.vertices3d","text":"returns the vertices of the rectangle in 3D\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.virtualdistance-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.virtualdistance","text":"returns the virtual distance of the point from the lens plane. When |distance| == focallength then virtualdistance = ∞\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T","page":"Reference","title":"OpticSim.virtualpoint","text":"computes the virtual point position corresponding to the input point, or returns nothing for points at infinity. point is specified in the lens coordinate frame\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.α-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArrays.SVector{N, T}}} where {T<:Real, N}","page":"Reference","title":"OpticSim.α","text":"α(ray::AbstractRay{T,N}, point::SVector{N,T}) -> T\n\nComputes the alpha corresponding to the closest position on the ray to point\n\n\n\n\n\n","category":"method"},{"location":"ref/#Geometry","page":"Reference","title":"Geometry","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Geometry]","category":"page"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(origin, forward) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the local frame with origin and forward direction. the other 2 axes are computed automaticlly.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArrays.SVector{4, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T<:Real}\n\nCostruct a transform from the input columns.     \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(rotation::AbstractArray{T,2}, translation::AbstractArray{T,1}) where {T<:Real} -> Transform{S}\n\nReturns the Transform of type S (default Float64) created by a rotation matrix (3x3) and translation vector of length 3.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, L} where L, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(rotation::SMatrix{3,3,T}, translation::SVector{3,T}) where {T<:Real} -> Transform{S}\n\nReturns the Transform of type S (default Float64) created by a rotation matrix and translation vector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}, NTuple{4, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T<:Real}\n\nCostruct a transform from the input columns.     \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform([S::Type]) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SMatrix{3, N, T, L} where L}, Tuple{T}, Tuple{N}} where {N, T<:Real}","page":"Reference","title":"OpticSim.Geometry.Vec4","text":"Vec4(m::SMatrix{3,N,T} where{N,T<:Real} -> SMatrix{3,N,T})\n\nInput is matrix of 3d points, each column is one point. Returns matrix of 3d points with 1 appended in the last row.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Vec4-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Vec4","text":"Vec4(v::SVector{3, T}) where {T<:Real} -> Vec4{T}\n\nAccept SVector and create a Vec4 type [v[1], v[2], v[3], 1]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.decomposeRTS-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.decomposeRTS","text":"decomposeRTS(tr::Transform{T}) where {T<:Real}\n\nreturn a touple containing the rotation matrix, the translation vector and the scale vecto represnting the transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.forward-Tuple{StaticArrays.SMatrix{4, 4, var\"#s31\", 16} where var\"#s31\"<:Real}","page":"Reference","title":"OpticSim.Geometry.forward","text":"forward(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the third column, representing the \"Z\" axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.identitytransform","text":"identitytransform([S::Type]) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.local2world-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.local2world","text":"local2world(t::Transform{T}) where {T<:Real}\n\nreturn the transform matrix that takes a point in the local coordinate system to the global one\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.right-Tuple{StaticArrays.SMatrix{4, 4, var\"#s31\", 16} where var\"#s31\"<:Real}","page":"Reference","title":"OpticSim.Geometry.right","text":"right(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the first column, representing the \"X\" axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotate-Union{Tuple{T}, Tuple{StaticArrays.SMatrix{4, 4, T, 16}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotate","text":"rotate(a::Transform{T}, vector::Union{Vec3{T}, SVector{3,T}}) where {T<:Real} -> Vec3{T}\n\napply the rotation part of the transform a to the vector vector - this operation is usually used to rotate direction vectors.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotation-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotation","text":"rotation(t::Transform{T}) where {T<:Real} -> SMatrix{3,3,T}\n\nreturns the rotation part of the transform t - a 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotation","text":"rotation([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationX-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotationX","text":"rotationX(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the x-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationY-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotationY","text":"rotationY(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the y-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationZ-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotationZ","text":"rotationZ(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the z-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotationd","text":"rotationd([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotmat","text":"rotmat([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotmatbetween-Union{Tuple{T}, Tuple{StaticArrays.SVector{3, T}, StaticArrays.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotmatbetween","text":"rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation between vetors a and b, i.e. rotation(a,b) * a = b.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotmatd","text":"rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.scale-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.scale","text":"scale(s::T) where {T<:Real}\n\nCreates a uniform scaling transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.scale-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.scale","text":"scale(t::Vec3{T}) where {T<:Real}\n\nCreates a scaling transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.scale","text":"scale(x::T, y::T, z::T) where {T<:Real}\n\nCreates a scaling transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.translation-Union{Tuple{StaticArrays.SVector{3, T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.translation","text":"translation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T<:Number, S<:Real}","page":"Reference","title":"OpticSim.Geometry.translation","text":"translation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitW4","text":"returns the unit vector [0, 0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitX3","text":"returns the unit vector [1, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitX4","text":"returns the unit vector [1, 0, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitY3","text":"returns the unit vector [0, 1, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitY4","text":"returns the unit vector [0, 1, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitZ3","text":"returns the unit vector [0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitZ4","text":"returns the unit vector [0, 0, 1, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.up-Tuple{StaticArrays.SMatrix{4, 4, var\"#s31\", 16} where var\"#s31\"<:Real}","page":"Reference","title":"OpticSim.Geometry.up","text":"up(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the second column, representing the \"Y\" axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.world2local-Union{Tuple{StaticArrays.SMatrix{4, 4, T, 16}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.world2local","text":"world2local(t::Transform{T}) where {T<:Real}\n\nreturn the transform matrix that takes a point in the global coordinate system to the local one\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.origin-Tuple{StaticArrays.SMatrix{4, 4, var\"#s31\", 16} where var\"#s31\"<:Real}","page":"Reference","title":"OpticSim.origin","text":"origin(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the fourth column, containing the translation part of the transform in 3D.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Zernike","page":"Reference","title":"Zernike","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Zernike]","category":"page"},{"location":"ref/#OpticSim.Zernike","page":"Reference","title":"OpticSim.Zernike","text":"Module to enclose Zernike polynomial specific functionality.\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.Zernike.NolltoNM-Tuple{Int64}","page":"Reference","title":"OpticSim.Zernike.NolltoNM","text":"NolltoNM(j::Int) -> Tuple{Int, Int}\n\nConvert Noll zernike index j to (N,M) form.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.OSAtoNM-Tuple{Int64}","page":"Reference","title":"OpticSim.Zernike.OSAtoNM","text":"OSAtoNM(j::Int) -> Tuple{Int, Int}\n\nConvert OSA zernike index j to (N,M) form according to formula J = N * (N + 2) + M.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.R-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.R","text":"R(N::Int, M::Int, ρ::T) -> T\n\nEvaluate radial polynomial R_n^m(rho).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.normalisation-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.normalisation","text":"normalisation(::Type{T}, N::Int, M::Int) -> T\n\nNormalisation coefficient for Zernike polynomial term Z_n^m.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.δζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.δζ","text":"δζ(N::Int, M::Int, ρ::T, ϕ::T) -> Tuple{T,T}\n\nEvaluate partial derivatives of Zernike polynomial term Z_n^m(rho phi).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Zernike.ζ-Union{Tuple{T}, Tuple{Int64, Int64, T, T}} where T<:Real","page":"Reference","title":"OpticSim.Zernike.ζ","text":"ζ(N::Int, M::Int, ρ::T, ϕ::T) -> Tuple{T,T}\n\nEvaluate Zernike polynomial term Z_n^m(rho phi).\n\n\n\n\n\n","category":"method"},{"location":"ref/#QType","page":"Reference","title":"QType","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.QType]","category":"page"},{"location":"ref/#OpticSim.QType","page":"Reference","title":"OpticSim.QType","text":"Module to enclose QType polynomial specific functionality. For reference see:\n\nRobust, efficient computational methods for axially symmetric optical aspheres - G. W. Forbes, 2010\nCharacterizing the shape of freeform optics - G. W. Forbes, 2012\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.QType.S-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T<:Real, NP1}","page":"Reference","title":"OpticSim.QType.S","text":"S(coeffs::SVector{NP1,T}, m::Int x::T) -> T\n\nEvaluates sum_n=0^Nc_n^mQ_n^m(x) where c_n^m is either an alpha or beta QType coefficient and m gt 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.QType.S0-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T<:Real, NP1}","page":"Reference","title":"OpticSim.QType.S0","text":"S0(coeffs::SVector{NP1,T}, x::T) -> T\n\nEvaluates sum_n=0^Nalpha_n^0Q_n^0(x).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.QType.dS0dx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, T}} where {T<:Real, NP1}","page":"Reference","title":"OpticSim.QType.dS0dx","text":"dS0dx(coeffs::SVector{NP1,T}, x::T) -> T\n\nEvaluates fracpartialpartial xsum_n=0^Nalpha_n^0Q_n^0(x).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.QType.dSdx-Union{Tuple{NP1}, Tuple{T}, Tuple{StaticArrays.SVector{NP1, T}, Int64, T}} where {T<:Real, NP1}","page":"Reference","title":"OpticSim.QType.dSdx","text":"dSdx(coeffs::SVector{NP1,T}, x::T) -> T\n\nEvaluates fracpartialpartial xsum_n=0^Nc_n^mQ_n^m(x) where c_n^m is either an alpha or beta QType coefficient and m gt 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Chebyshev","page":"Reference","title":"Chebyshev","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Chebyshev]","category":"page"},{"location":"ref/#OpticSim.Chebyshev","page":"Reference","title":"OpticSim.Chebyshev","text":"Module to enclose Chebyshev polynomial specific functionality.\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.Chebyshev.T-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R<:Real","page":"Reference","title":"OpticSim.Chebyshev.T","text":"T(n::Int, q::R, fast::Bool = true) -> R\n\nEvaluate Chebyshev polynomial of the first kind T_n(q).\n\nfast will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Chebyshev.U-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R<:Real","page":"Reference","title":"OpticSim.Chebyshev.U","text":"U(n::Int, q::R, fast::Bool = true) -> R\n\nEvaluate Chebyshev polynomial of the second kind U_n(q).\n\nfast will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Chebyshev.dTdq-Union{Tuple{R}, Tuple{Int64, R}, Tuple{Int64, R, Bool}} where R<:Real","page":"Reference","title":"OpticSim.Chebyshev.dTdq","text":"dTdq(n::Int, q::R, fast::Bool = true) -> R\n\nEvaluate derivative of Chebyshev polynomial of the first kind fracdT_ndq(q).\n\nfast will use trigonometric definition, rather than the recursive definition which is much faster but slightly less precise.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Examples","page":"Reference","title":"Examples","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OpticSim.Examples]","category":"page"},{"location":"ref/#OpticSim.Examples","page":"Reference","title":"OpticSim.Examples","text":"Contains example usage of the features in the OpticSim.jl package.\n\n\n\n\n\n","category":"module"},{"location":"ref/#OpticSim.Examples.drawhex12RGB-Tuple{}","page":"Reference","title":"OpticSim.Examples.drawhex12RGB","text":"draw 3 repeats of hex12RGB cluster \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.drawhex3RGB-Tuple{}","page":"Reference","title":"OpticSim.Examples.drawhex3RGB","text":"draw 3 repeats of hex3RGB cluster \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.drawhexneighbors-Tuple{}","page":"Reference","title":"OpticSim.Examples.drawhexneighbors","text":"draw the 2 ring neighbors of the hex cell at coordinates (0,0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.drawhexrect-Tuple{}","page":"Reference","title":"OpticSim.Examples.drawhexrect","text":"draw hex cells that fit within a rectangular box centered at coordinates (0,0). Use fill color yellow.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.drawhexrectcolors-Tuple{}","page":"Reference","title":"OpticSim.Examples.drawhexrectcolors","text":"draw hex cells that fit within a rectangular box centered at coordinates (0,0). Use random fill colors selected for maximum distinguishability.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.drawhexregion-Tuple{}","page":"Reference","title":"OpticSim.Examples.drawhexregion","text":"draw hex cell at coordinates (0,0) and the 1 and 2 ring neighbors\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.hemisphere-Tuple{}","page":"Reference","title":"OpticSim.Examples.hemisphere","text":"hemisphere()\n\nCreate a geometric hemisphere\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.hex3RGB-Tuple{}","page":"Reference","title":"OpticSim.Examples.hex3RGB","text":"Create a ClusterWithProperties with three types of elements, R,G,B \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.hex3cluster-Tuple{}","page":"Reference","title":"OpticSim.Examples.hex3cluster","text":"Create a LatticeCluser with three elements at (0,0),(-1,0),(-1,1) coordinates in the HexBasis1 lattice\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.hexRGBW-Tuple{}","page":"Reference","title":"OpticSim.Examples.hexRGBW","text":"Create a ClusterWithProperties with four types of elements, R,G,B,W \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Examples.opticalhemisphere-Tuple{}","page":"Reference","title":"OpticSim.Examples.opticalhemisphere","text":"opticalhemisphere()\n\nCreate an optical hemisphere that has optical material properties so it will reflect and refract light. In the previous example the hemisphere object had optical properties of Air, which is the default optical interface, so it won't refract or reflect light.\n\n\n\n\n\n","category":"method"},{"location":"#OpticSim.jl","page":"Home","title":"OpticSim.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticSim.jl is a Julia package for geometric optics (ray tracing) simulation and optimization of complex optical systems developed by the Microsoft Research Interactive Media Group and the Microsoft Hardware Architecture Incubation Team (HART).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is designed to allow optical engineers to create optical systems procedurally and then to simulate and optimize them. Unlike Zemax, Code V, or other interactive optical design systems OpticSim.jl has limited support for interactivity, primarily in the tools for visualizing optical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A large variety of surface types are supported, and these can be composed into complex 3D objects through the use of constructive solid geometry (CSG). A complete catalog of optical materials is provided through the complementary GlassCat submodule.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This software provides extensive control over the modelling, simulation, visualization and optimization of optical systems. It is especially suited for designs that have a procedural architecture.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the Julia programming language from the official download page. OpticSim.jl is optimized for use with Julia 1.5.2-1.6.0; using other versions may result in reduced performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The system will automatically download glass catalog (.agf) files from some manufacturers when the package is built for the first time. These files are in an industry standard format and can be downloaded from many optical glass manufacturers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here are links to several publicly available glass files:","category":"page"},{"location":"","page":"Home","title":"Home","text":"NIKON (automatically downloaded)\nNHG (you have to manually download)\nOHARA (automatically downloaded)\nHOYA (automatically downloaded)\nSUMITA (automatically downloaded)\nSCHOTT (automatically downloaded)","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpticSim.jl will generate a glass database from the available files in deps/downloads/glasscat/ and store it in the file AGFClassCat.jl. See GlassCat for a detailed description, including instructions on how to add more catalogs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run this example to check that everything installed properly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OpticSim\nVis.draw(SphericalLens(OpticSim.GlassCat.SCHOTT.N_BK7, 0.0, 10.0, 10.0, 5.0, 5.0))\nVis.save(\"assets/test_install.png\") # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: install test image)","category":"page"},{"location":"#System-Image","page":"Home","title":"System Image","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are using Julia 1.5, we recommend compiling a custom Julia system image for the OpticSim.jl package to reduce startup time and improve first-time performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With VSCode, you can create a sysimage by opening the commant palette (CTRL-shift-P) and selecting Tasks: Run Build Task, julia: Build custom sysimage for current environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, we provide a Julia script that will build the sysimage using a representative workload. To do this, activate a Julia environment which has OpticSim installed and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"deps/sysimage.jl\")\ncompile()","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the sysimage is located in the current working directory. On Linux, it will be called JuliaSysimage.so; on Windows, the extension will be .dll. A custom path can be used instead which is passed as an argument to compile().","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the generated system image, run Julia with the --sysimage flag:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=[your_project] --sysimage=[path_to_sysimage]","category":"page"},{"location":"","page":"Home","title":"Home","text":"If OpticSim.jl is installed in the base project, then there is no need for the --project flag in the above command. If your current working directory is OpticSim.jl, then you can use the --project flag without needing to specify an argument.","category":"page"}]
}
